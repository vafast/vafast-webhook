{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @vafast/webhook - Webhook dispatch middleware for Vafast framework\n *\n * Automatically trigger webhooks based on route configuration.\n * Uses vafast RouteRegistry to query event configurations.\n */\nimport type { Middleware } from 'vafast'\nimport { getRoute } from 'vafast'\nimport * as crypto from 'crypto'\n\n// ============================================\n// Types\n// ============================================\n\n/**\n * Webhook configuration in route definition\n */\nexport interface WebhookConfig {\n  /** Custom event key (default: auto-generated from path) */\n  eventKey?: string\n  /** Fields to include in payload (whitelist) */\n  include?: string[]\n  /** Fields to exclude from payload (blacklist) */\n  exclude?: string[]\n  /** Condition function to determine if webhook should trigger */\n  condition?: (data: Record<string, unknown>) => boolean\n  /** Custom transform function for payload */\n  transform?: (data: Record<string, unknown>, req: Request) => Record<string, unknown>\n}\n\n/**\n * Webhook event configuration (resolved from route)\n */\nexport interface WebhookEventConfig {\n  eventKey: string\n  name: string\n  description: string\n  category: string\n  method: string\n  path: string\n  config: WebhookConfig\n}\n\n/**\n * Webhook subscription document (from database)\n */\nexport interface WebhookSubscription {\n  id: string\n  appId: string\n  eventKey: string\n  endpointUrl: string\n  secret?: string\n  status: 'enabled' | 'disabled'\n}\n\n/**\n * Webhook log document\n */\nexport interface WebhookLog {\n  appId: string\n  webhookId: string\n  eventKey: string\n  endpointUrl: string\n  payload: Record<string, unknown>\n  status: 'success' | 'failed'\n  statusCode: number | null\n  error: string | null\n  duration: number\n  createdAt: Date\n}\n\n/**\n * Storage adapter interface\n */\nexport interface WebhookStorage {\n  /** Find enabled subscriptions for an event */\n  findSubscriptions(appId: string, eventKey: string): Promise<WebhookSubscription[]>\n  /** Save webhook log */\n  saveLog(log: WebhookLog): Promise<void>\n}\n\n/**\n * Logger interface\n */\nexport interface WebhookLogger {\n  debug(message: string, meta?: Record<string, unknown>): void\n  info(message: string, meta?: Record<string, unknown>): void\n  warn(message: string, meta?: Record<string, unknown>): void\n  error(message: string, meta?: Record<string, unknown>): void\n}\n\n/**\n * Webhook middleware configuration\n */\nexport interface WebhookMiddlewareConfig {\n  /** Storage adapter for subscriptions and logs */\n  storage: WebhookStorage\n  /** Logger (optional, defaults to console) */\n  logger?: WebhookLogger\n  /** API path prefix to strip (e.g., '/restfulApi') */\n  pathPrefix?: string\n  /** Header name for app ID (default: 'app-id') */\n  appIdHeader?: string\n  /** Timeout for webhook requests in ms (default: 30000) */\n  timeout?: number\n  /** Fields to always exclude from payload */\n  sensitiveFields?: string[]\n  /** Success response code to check (default: 20001) */\n  successCode?: number\n}\n\n// ============================================\n// Default values\n// ============================================\n\nconst DEFAULT_SENSITIVE_FIELDS = [\n  'password',\n  'token',\n  'jwtToken',\n  'refreshToken',\n  'secret',\n  'accessToken',\n  'apiKey',\n]\n\nconst DEFAULT_LOGGER: WebhookLogger = {\n  debug: (msg, meta) => console.debug(`[Webhook] ${msg}`, meta || ''),\n  info: (msg, meta) => console.info(`[Webhook] ${msg}`, meta || ''),\n  warn: (msg, meta) => console.warn(`[Webhook] ${msg}`, meta || ''),\n  error: (msg, meta) => console.error(`[Webhook] ${msg}`, meta || ''),\n}\n\n// ============================================\n// Utility functions\n// ============================================\n\n/**\n * Get client IP from request\n */\nfunction getClientIp(req: Request): string {\n  return (\n    req.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ||\n    req.headers.get('x-real-ip') ||\n    'unknown'\n  )\n}\n\n/**\n * Generate HMAC-SHA256 signature\n */\nfunction generateSignature(payload: string, secret: string): string {\n  return crypto.createHmac('sha256', secret).update(payload).digest('hex')\n}\n\n/**\n * Generate event key from path\n */\nfunction generateEventKey(path: string): string {\n  const segments = path.split('/').filter(Boolean)\n  if (segments.length === 0) return 'unknown'\n  if (segments.length === 1) return segments[0]\n  return `${segments[0]}.${segments.slice(1).join('.')}`\n}\n\n/**\n * Extract category from path\n */\nfunction extractCategory(path: string): string {\n  const segments = path.split('/').filter(Boolean)\n  return segments[0] || 'unknown'\n}\n\n/**\n * Generate default name from path\n */\nfunction generateName(path: string): string {\n  const segments = path.split('/').filter(Boolean)\n  return segments.join(' / ') || 'Unknown'\n}\n\n/**\n * Get webhook event config from route\n */\nfunction getWebhookEventConfig(\n  method: string,\n  path: string\n): WebhookEventConfig | undefined {\n  const route = getRoute<{ webhook?: WebhookConfig }>(method, path)\n  if (!route?.webhook) return undefined\n\n  const webhookConfig = route.webhook\n  const fullPath = route.fullPath\n\n  return {\n    eventKey: webhookConfig.eventKey || generateEventKey(fullPath),\n    name: (route as { name?: string }).name || generateName(fullPath),\n    description: (route as { description?: string }).description || '',\n    category: extractCategory(fullPath),\n    method: route.method,\n    path: fullPath,\n    config: webhookConfig,\n  }\n}\n\n/**\n * Process payload fields\n */\nfunction processFields(\n  data: Record<string, unknown>,\n  config: WebhookConfig,\n  req: Request,\n  sensitiveFields: string[]\n): Record<string, unknown> {\n  let result: Record<string, unknown> = { ...data }\n\n  // 1. Always filter sensitive fields\n  for (const field of sensitiveFields) {\n    delete result[field]\n  }\n\n  // 2. Handle include (whitelist)\n  if (config.include && config.include.length > 0) {\n    const newResult: Record<string, unknown> = {}\n    for (const field of config.include) {\n      if (field in result) {\n        newResult[field] = result[field]\n      }\n    }\n    result = newResult\n  }\n\n  // 3. Handle exclude (blacklist)\n  if (config.exclude && config.exclude.length > 0) {\n    for (const field of config.exclude) {\n      delete result[field]\n    }\n  }\n\n  // 4. Custom transform\n  if (config.transform) {\n    result = config.transform(result, req)\n  }\n\n  // 5. Add common fields\n  return {\n    ...result,\n    clientIp: getClientIp(req),\n    userAgent: req.headers.get('user-agent') || 'unknown',\n    timestamp: new Date().toISOString(),\n  }\n}\n\n/**\n * Check trigger condition\n */\nfunction checkCondition(\n  data: Record<string, unknown>,\n  config: WebhookConfig\n): boolean {\n  if (config.condition) {\n    return config.condition(data)\n  }\n  return true\n}\n\n// ============================================\n// Core functions\n// ============================================\n\n/**\n * Send webhook and log result\n */\nasync function sendWebhook(\n  subscription: WebhookSubscription,\n  appId: string,\n  eventKey: string,\n  data: Record<string, unknown>,\n  storage: WebhookStorage,\n  logger: WebhookLogger,\n  timeout: number\n): Promise<void> {\n  const startTime = Date.now()\n  const payload = {\n    appId,\n    eventType: eventKey.split('.')[0],\n    eventKey,\n    timestamp: new Date().toISOString(),\n    data,\n  }\n\n  const bodyString = JSON.stringify(payload)\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n    'X-Webhook-Event': eventKey,\n    'X-Webhook-Timestamp': payload.timestamp,\n  }\n\n  // Add signature if secret is configured\n  if (subscription.secret) {\n    headers['X-Webhook-Signature'] = generateSignature(bodyString, subscription.secret)\n  }\n\n  let status: 'success' | 'failed' = 'success'\n  let statusCode: number | null = null\n  let errorMsg: string | null = null\n\n  try {\n    const response = await fetch(subscription.endpointUrl, {\n      method: 'POST',\n      headers,\n      body: bodyString,\n      signal: AbortSignal.timeout(timeout),\n    })\n\n    statusCode = response.status\n    if (!response.ok) {\n      status = 'failed'\n      errorMsg = `HTTP ${response.status}`\n    }\n  } catch (err) {\n    status = 'failed'\n    errorMsg = err instanceof Error ? err.message : String(err)\n  }\n\n  const duration = Date.now() - startTime\n\n  // Log result\n  try {\n    await storage.saveLog({\n      appId,\n      webhookId: subscription.id,\n      eventKey,\n      endpointUrl: subscription.endpointUrl,\n      payload,\n      status,\n      statusCode,\n      error: errorMsg,\n      duration,\n      createdAt: new Date(),\n    })\n  } catch (logErr) {\n    logger.error('Failed to save webhook log', { error: logErr })\n  }\n\n  if (status === 'failed') {\n    logger.warn('Webhook delivery failed', {\n      eventKey,\n      endpointUrl: subscription.endpointUrl,\n      error: errorMsg,\n      duration,\n    })\n  } else {\n    logger.debug('Webhook delivered successfully', {\n      eventKey,\n      endpointUrl: subscription.endpointUrl,\n      statusCode,\n      duration,\n    })\n  }\n}\n\n/**\n * Dispatch webhook event to all subscribers\n */\nasync function dispatchEvent(\n  appId: string,\n  eventKey: string,\n  data: Record<string, unknown>,\n  storage: WebhookStorage,\n  logger: WebhookLogger,\n  timeout: number\n): Promise<void> {\n  try {\n    const subscriptions = await storage.findSubscriptions(appId, eventKey)\n\n    if (subscriptions.length === 0) return\n\n    logger.info('Dispatching webhook event', {\n      appId,\n      eventKey,\n      count: subscriptions.length,\n    })\n\n    // Send to all subscribers in parallel\n    await Promise.all(\n      subscriptions.map((sub) =>\n        sendWebhook(sub, appId, eventKey, data, storage, logger, timeout)\n      )\n    )\n  } catch (err) {\n    logger.error('Webhook dispatch failed', { error: err })\n  }\n}\n\n// ============================================\n// Middleware\n// ============================================\n\n/**\n * Create webhook dispatch middleware\n *\n * @example\n * ```typescript\n * import { webhook } from '@vafast/webhook'\n *\n * const webhookMiddleware = webhook({\n *   storage: myStorageAdapter,\n *   pathPrefix: '/restfulApi',\n * })\n *\n * server.use(webhookMiddleware)\n * ```\n */\nexport function webhook(config: WebhookMiddlewareConfig): Middleware {\n  const {\n    storage,\n    logger = DEFAULT_LOGGER,\n    pathPrefix = '',\n    appIdHeader = 'app-id',\n    timeout = 30000,\n    sensitiveFields = DEFAULT_SENSITIVE_FIELDS,\n    successCode = 20001,\n  } = config\n\n  return async (req: Request, next: () => Promise<Response>) => {\n    const response = await next()\n\n    // Only process successful JSON responses\n    if (!response.ok) return response\n\n    const contentType = response.headers.get('content-type')\n    if (!contentType?.includes('application/json')) return response\n\n    const appId = req.headers.get(appIdHeader)\n    if (!appId) return response\n\n    // Get request path (strip prefix)\n    const url = new URL(req.url)\n    const pathname = pathPrefix\n      ? url.pathname.replace(new RegExp(`^${pathPrefix}`), '')\n      : url.pathname\n\n    // Get event config from route registry\n    const eventConfig = getWebhookEventConfig(req.method, pathname)\n    if (!eventConfig) return response\n\n    try {\n      // Clone response to read body\n      const clonedResponse = response.clone()\n      const responseData = (await clonedResponse.json()) as {\n        success?: boolean\n        code?: number\n        data?: Record<string, unknown>\n      }\n\n      // Only process business-successful responses\n      if (!responseData.success || responseData.code !== successCode) return response\n\n      const rawData = responseData.data || {}\n\n      // Check trigger condition\n      if (!checkCondition(rawData, eventConfig.config)) return response\n\n      // Process payload\n      const payload = processFields(rawData, eventConfig.config, req, sensitiveFields)\n\n      // Dispatch asynchronously (don't block response)\n      setImmediate(() => {\n        dispatchEvent(appId, eventConfig.eventKey, payload, storage, logger, timeout).catch(\n          (err) => {\n            logger.error('Async dispatch failed', { error: err })\n          }\n        )\n      })\n    } catch {\n      // Parse error doesn't affect response\n    }\n\n    return response\n  }\n}\n\n/**\n * Manually dispatch webhook (for redirect scenarios like OAuth)\n *\n * @example\n * ```typescript\n * import { dispatchWebhook } from '@vafast/webhook'\n *\n * // In OAuth callback handler\n * dispatchWebhook(storage, logger, {\n *   appId,\n *   eventKey: 'auth.oauth',\n *   data: { userId, provider },\n *   req,\n * })\n * ```\n */\nexport function dispatchWebhook(\n  storage: WebhookStorage,\n  logger: WebhookLogger,\n  options: {\n    appId: string\n    eventKey: string\n    data: Record<string, unknown>\n    req: Request\n    timeout?: number\n  }\n): void {\n  const { appId, eventKey, data, req, timeout = 30000 } = options\n\n  const payload = {\n    ...data,\n    clientIp: getClientIp(req),\n    userAgent: req.headers.get('user-agent') || 'unknown',\n    timestamp: new Date().toISOString(),\n  }\n\n  setImmediate(() => {\n    dispatchEvent(appId, eventKey, payload, storage, logger, timeout).catch((err) => {\n      logger.error('Manual dispatch failed', { error: err })\n    })\n  })\n}\n\n// ============================================\n// Exports\n// ============================================\n\nexport default webhook\n\n// Re-export utility functions\nexport {\n  getWebhookEventConfig,\n  generateEventKey,\n  extractCategory,\n  generateName,\n  generateSignature,\n  getClientIp,\n  DEFAULT_SENSITIVE_FIELDS,\n}\n\n"],"mappings":"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","names":[]}