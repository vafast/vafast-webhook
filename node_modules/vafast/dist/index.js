// src/router.ts
function flattenNestedRoutes(routes) {
  const flattened = [];
  function processRoute(route2, parentPath = "", parentMiddleware = []) {
    const currentPath = normalizePath(parentPath + route2.path);
    const currentMiddleware = [
      ...parentMiddleware,
      ...route2.middleware || []
    ];
    if ("method" in route2 && "handler" in route2) {
      const leafRoute = route2;
      flattened.push({
        ...leafRoute,
        fullPath: currentPath,
        middlewareChain: currentMiddleware
      });
    } else if ("children" in route2 && route2.children) {
      for (const child of route2.children) {
        processRoute(child, currentPath, currentMiddleware);
      }
    }
  }
  for (const route2 of routes) {
    processRoute(route2);
  }
  return flattened;
}
function normalizePath(path) {
  let normalized = decodeURIComponent(path);
  normalized = normalized.replace(/\/+/g, "/");
  if (normalized === "") return "/";
  if (normalized !== "/" && normalized.endsWith("/")) {
    normalized = normalized.slice(0, -1);
  }
  return normalized;
}

// src/utils/response.ts
function json(data, status = 200, headers = {}) {
  const body = JSON.stringify(data);
  if (Object.keys(headers).length === 0) {
    return new Response(body, {
      status,
      headers: { "Content-Type": "application/json" }
    });
  }
  const h = new Headers({
    "Content-Type": "application/json",
    ...headers
  });
  return new Response(body, {
    status,
    headers: h
  });
}
var JSON_HEADERS = { "Content-Type": "application/json" };
var TEXT_HEADERS = { "Content-Type": "text/plain" };
function mapResponse(response) {
  if (response instanceof Response) return response;
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response, { headers: TEXT_HEADERS });
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: JSON_HEADERS });
    case "Number":
    case "Boolean":
      return new Response(String(response), { headers: TEXT_HEADERS });
    case void 0:
      return new Response(null, { status: 204 });
    case "ReadableStream":
      return new Response(response);
    case "Blob":
      return new Response(response);
    case "ArrayBuffer":
      return new Response(response);
    case "Uint8Array":
      return new Response(response);
    default:
      if (response instanceof Promise) {
        return response.then(mapResponse);
      }
      return new Response(JSON.stringify(response), { headers: JSON_HEADERS });
  }
}
function redirect(location, status = 302) {
  return new Response(null, {
    status,
    headers: {
      Location: location
    }
  });
}
function text(content, status = 200, headers = {}) {
  const h = new Headers({
    "Content-Type": "text/plain; charset=utf-8",
    ...headers
  });
  return new Response(content, {
    status,
    headers: h
  });
}
function html(content, status = 200, headers = {}) {
  const h = new Headers({
    "Content-Type": "text/html; charset=utf-8",
    ...headers
  });
  return new Response(content, {
    status,
    headers: h
  });
}
function empty(status = 204, headers = {}) {
  return new Response(null, {
    status,
    headers
  });
}
function stream(stream2, status = 200, headers = {}) {
  const h = new Headers({
    "Content-Type": "application/octet-stream",
    ...headers
  });
  return new Response(stream2, {
    status,
    headers: h
  });
}

// src/middleware.ts
var VafastError = class extends Error {
  status;
  type;
  expose;
  constructor(message, options = {}) {
    super(message);
    this.name = "VafastError";
    this.status = options.status ?? 500;
    this.type = options.type ?? "internal_error";
    this.expose = options.expose ?? false;
    if (options.cause) this.cause = options.cause;
  }
};
function composeMiddleware(middleware, finalHandler) {
  const all = [errorHandler, ...middleware];
  return function composedHandler(req) {
    let i = -1;
    const dispatch = (index) => {
      if (index <= i)
        return Promise.reject(new Error("next() called multiple times"));
      i = index;
      if (index < all.length) {
        const mw = all[index];
        return Promise.resolve(mw(req, () => dispatch(index + 1)));
      }
      return Promise.resolve(finalHandler(req)).then(mapResponse);
    };
    return dispatch(0);
  };
}
var errorHandler = async (req, next) => {
  try {
    return await next();
  } catch (err) {
    console.error("\u672A\u5904\u7406\u7684\u9519\u8BEF:", err);
    if (err instanceof VafastError) {
      return json(
        {
          error: err.type,
          message: err.expose ? err.message : "\u53D1\u751F\u4E86\u4E00\u4E2A\u9519\u8BEF"
        },
        err.status
      );
    }
    return json({ error: "internal_error", message: "\u51FA\u73B0\u4E86\u4E00\u4E9B\u95EE\u9898" }, 500);
  }
};

// src/server/base-server.ts
var BaseServer = class {
  globalMiddleware = [];
  use(mw) {
    this.globalMiddleware.push(mw);
  }
  /**
   * 打印扁平化后的路由信息，用于调试
   */
  logFlattenedRoutes(routes, type = "\u8DEF\u7531") {
    console.log(`\u{1F680} \u6241\u5E73\u5316\u540E\u7684${type}:`);
    for (const route2 of routes) {
      const method = route2.method || "GET";
      const path = route2.fullPath || route2.path;
      console.log(`  ${method} ${path}`);
      if (route2.middlewareChain && route2.middlewareChain.length > 0) {
        console.log(`    \u4E2D\u95F4\u4EF6\u94FE: ${route2.middlewareChain.length} \u4E2A`);
      }
    }
    console.log("");
  }
  /**
   * 检测路由冲突
   * 检查是否有路径相同但方法不同的路由，以及潜在的路径冲突
   */
  detectRouteConflicts(routes) {
    const pathGroups = /* @__PURE__ */ new Map();
    for (const route2 of routes) {
      const path = route2.fullPath || route2.path;
      const method = route2.method || "GET";
      if (!pathGroups.has(path)) {
        pathGroups.set(path, []);
      }
      pathGroups.get(path).push({ ...route2, method });
    }
    for (const [path, routeList] of pathGroups) {
      if (routeList.length > 1) {
        const methods = routeList.map((r) => r.method);
        const uniqueMethods = [...new Set(methods)];
        if (uniqueMethods.length === 1) {
          console.warn(
            `\u26A0\uFE0F  \u8DEF\u7531\u51B2\u7A81: ${uniqueMethods[0]} ${path} \u5B9A\u4E49\u4E86 ${routeList.length} \u6B21`
          );
          routeList.forEach((route2, index) => {
            console.warn(`   ${index + 1}. ${route2.method} ${path}`);
          });
        } else {
          console.log(`\u2139\uFE0F  \u8DEF\u5F84 ${path} \u652F\u6301\u65B9\u6CD5: ${uniqueMethods.join(", ")}`);
        }
      }
    }
    this.detectDynamicRouteConflicts(routes);
  }
  /**
   * 检测动态路由的潜在冲突
   */
  detectDynamicRouteConflicts(routes) {
    const dynamicRoutes = routes.filter((r) => {
      const path = r.fullPath || r.path;
      return path.includes(":") || path.includes("*");
    });
    for (let i = 0; i < dynamicRoutes.length; i++) {
      for (let j = i + 1; j < dynamicRoutes.length; j++) {
        const route1 = dynamicRoutes[i];
        const route2 = dynamicRoutes[j];
        const method1 = route1.method || "GET";
        const method2 = route2.method || "GET";
        if (method1 === method2) {
          const path1 = route1.fullPath || route1.path;
          const path2 = route2.fullPath || route2.path;
          if (this.pathsMayConflict(path1, path2)) {
            console.warn(
              `\u26A0\uFE0F  \u6F5C\u5728\u8DEF\u7531\u51B2\u7A81: ${method1} ${path1} \u53EF\u80FD\u4E0E ${path2} \u51B2\u7A81`
            );
          }
        }
      }
    }
  }
  /**
   * 判断两个路径是否可能冲突
   */
  pathsMayConflict(path1, path2) {
    const parts1 = path1.split("/").filter(Boolean);
    const parts2 = path2.split("/").filter(Boolean);
    if (parts1.length !== parts2.length) return false;
    for (let i = 0; i < parts1.length; i++) {
      const p1 = parts1[i];
      const p2 = parts2[i];
      if (!p1.startsWith(":") && !p1.startsWith("*") && !p2.startsWith(":") && !p2.startsWith("*") && p1 !== p2) {
        return false;
      }
      if (p1 === "*" && p2.startsWith(":") || p2 === "*" && p1.startsWith(":")) {
        return true;
      }
    }
    return false;
  }
  /**
   * 路径匹配
   */
  matchPath(pattern, path) {
    const patternParts = pattern.split("/").filter(Boolean);
    const pathParts = path.split("/").filter(Boolean);
    if (patternParts.length !== pathParts.length) {
      return false;
    }
    for (let i = 0; i < patternParts.length; i++) {
      if (patternParts[i] !== pathParts[i] && !patternParts[i].startsWith(":")) {
        return false;
      }
    }
    return true;
  }
  /**
   * 提取路径参数
   */
  extractParams(pattern, path) {
    const params = {};
    const patternParts = pattern.split("/").filter(Boolean);
    const pathParts = path.split("/").filter(Boolean);
    for (let i = 0; i < patternParts.length; i++) {
      if (patternParts[i].startsWith(":")) {
        const paramName = patternParts[i].slice(1);
        params[paramName] = pathParts[i];
      }
    }
    return params;
  }
};

// src/router/radix-tree.ts
var RadixRouter = class {
  root;
  constructor() {
    this.root = this.createNode("");
  }
  createNode(path) {
    return {
      path,
      children: /* @__PURE__ */ Object.create(null),
      handlers: /* @__PURE__ */ Object.create(null)
    };
  }
  /** 分割路径 */
  splitPath(path) {
    return path.split("/").filter(Boolean);
  }
  /** 编译器函数 - 用于预编译中间件链 */
  compiler;
  /** 设置中间件编译器 */
  setCompiler(compiler) {
    this.compiler = compiler;
  }
  /** 注册路由 */
  register(method, pattern, handler, middleware = []) {
    const segments = this.splitPath(pattern);
    let node = this.root;
    for (const segment of segments) {
      const firstChar = segment[0];
      if (firstChar === ":") {
        if (!node.paramChild) {
          node.paramChild = this.createNode(segment);
          node.paramChild.paramName = segment.substring(1);
        }
        node = node.paramChild;
      } else if (firstChar === "*") {
        if (!node.wildcardChild) {
          node.wildcardChild = this.createNode(segment);
          node.wildcardChild.paramName = segment.length > 1 ? segment.substring(1) : "*";
        }
        node = node.wildcardChild;
        break;
      } else {
        if (!node.children[segment]) {
          node.children[segment] = this.createNode(segment);
        }
        node = node.children[segment];
      }
    }
    const routeHandler = { handler, middleware };
    if (this.compiler && middleware.length === 0) {
      routeHandler.compiled = this.compiler([], handler);
    }
    node.handlers[method] = routeHandler;
  }
  /** 预编译所有路由（在添加全局中间件后调用） */
  precompileAll(globalMiddleware) {
    if (!this.compiler) return;
    this.precompileNode(this.root, globalMiddleware);
  }
  precompileNode(node, globalMiddleware) {
    for (const method in node.handlers) {
      const routeHandler = node.handlers[method];
      if (routeHandler) {
        const allMiddleware = [...globalMiddleware, ...routeHandler.middleware];
        routeHandler.compiled = this.compiler(
          allMiddleware,
          routeHandler.handler
        );
      }
    }
    for (const key in node.children) {
      this.precompileNode(node.children[key], globalMiddleware);
    }
    if (node.paramChild) {
      this.precompileNode(node.paramChild, globalMiddleware);
    }
    if (node.wildcardChild) {
      this.precompileNode(node.wildcardChild, globalMiddleware);
    }
  }
  /** 匹配路由 */
  match(method, path) {
    const segments = this.splitPath(path);
    const params = /* @__PURE__ */ Object.create(null);
    const node = this.matchNode(this.root, segments, 0, params);
    if (!node) return null;
    const routeHandler = node.handlers[method];
    if (!routeHandler) return null;
    return {
      handler: routeHandler.handler,
      middleware: routeHandler.middleware,
      params,
      compiled: routeHandler.compiled
    };
  }
  /** 递归匹配节点 (优先级: 静态 > 动态参数 > 通配符) */
  matchNode(node, segments, index, params) {
    if (index === segments.length) {
      for (const method in node.handlers) {
        if (node.handlers[method]) return node;
      }
      return null;
    }
    const segment = segments[index];
    const staticChild = node.children[segment];
    if (staticChild) {
      const result = this.matchNode(staticChild, segments, index + 1, params);
      if (result) return result;
    }
    if (node.paramChild) {
      const paramName = node.paramChild.paramName;
      const oldValue = params[paramName];
      params[paramName] = segment;
      const result = this.matchNode(
        node.paramChild,
        segments,
        index + 1,
        params
      );
      if (result) return result;
      if (oldValue === void 0) {
        delete params[paramName];
      } else {
        params[paramName] = oldValue;
      }
    }
    if (node.wildcardChild) {
      params[node.wildcardChild.paramName || "*"] = segments.slice(index).join("/");
      return node.wildcardChild;
    }
    return null;
  }
  /** 获取路径允许的 HTTP 方法 */
  getAllowedMethods(path) {
    const segments = this.splitPath(path);
    const node = this.findNode(segments);
    if (!node) return [];
    const methods = [];
    for (const method in node.handlers) {
      if (node.handlers[method]) {
        methods.push(method);
      }
    }
    return methods;
  }
  /** 查找节点（不提取参数） */
  findNode(segments) {
    let node = this.root;
    for (const segment of segments) {
      if (node.children[segment]) {
        node = node.children[segment];
      } else if (node.paramChild) {
        node = node.paramChild;
      } else if (node.wildcardChild) {
        return node.wildcardChild;
      } else {
        return null;
      }
    }
    return node;
  }
  /** 获取所有已注册的路由 */
  getRoutes() {
    const routes = [];
    this.collectRoutes(this.root, "", routes);
    return routes;
  }
  collectRoutes(node, prefix, routes) {
    const currentPath = prefix + (node.path ? "/" + node.path : "");
    for (const method in node.handlers) {
      if (node.handlers[method]) {
        routes.push({ method, path: currentPath || "/" });
      }
    }
    for (const key in node.children) {
      this.collectRoutes(node.children[key], currentPath, routes);
    }
    if (node.paramChild) {
      this.collectRoutes(node.paramChild, currentPath, routes);
    }
    if (node.wildcardChild) {
      this.collectRoutes(node.wildcardChild, currentPath, routes);
    }
  }
};

// src/utils/route-registry.ts
var RouteRegistry = class {
  /** 所有路由元信息 */
  routes = [];
  /** 路由映射表：METHOD:fullPath -> RouteMeta */
  routeMap = /* @__PURE__ */ new Map();
  /** 分类映射表：category -> RouteMeta[] */
  categoryMap = /* @__PURE__ */ new Map();
  constructor(routes) {
    this.buildRegistry(routes);
  }
  /**
   * 构建注册表
   */
  buildRegistry(routes) {
    for (const route2 of routes) {
      const meta = {
        method: route2.method,
        path: route2.path,
        fullPath: route2.fullPath,
        name: route2.name,
        description: route2.description
      };
      for (const key of Object.keys(route2)) {
        if (!["method", "path", "fullPath", "name", "description", "handler", "middleware", "middlewareChain"].includes(key)) {
          meta[key] = route2[key];
        }
      }
      this.routes.push(meta);
      this.routeMap.set(`${route2.method}:${route2.fullPath}`, meta);
      const category = this.extractCategory(route2.fullPath);
      if (!this.categoryMap.has(category)) {
        this.categoryMap.set(category, []);
      }
      this.categoryMap.get(category).push(meta);
    }
  }
  /**
   * 提取分类（第一段路径）
   */
  extractCategory(path) {
    const segments = path.split("/").filter(Boolean);
    return segments[0] || "root";
  }
  // ============================================
  // 查询接口
  // ============================================
  /**
   * 获取所有路由元信息
   */
  getAll() {
    return [...this.routes];
  }
  /**
   * 按 method + path 查询路由
   */
  get(method, path) {
    return this.routeMap.get(`${method}:${path}`);
  }
  /**
   * 检查路由是否存在
   */
  has(method, path) {
    return this.routeMap.has(`${method}:${path}`);
  }
  /**
   * 按分类获取路由
   */
  getByCategory(category) {
    return this.categoryMap.get(category) || [];
  }
  /**
   * 获取所有分类
   */
  getCategories() {
    return Array.from(this.categoryMap.keys()).sort();
  }
  /**
   * 筛选有特定字段的路由
   *
   * @example
   * ```typescript
   * // 获取所有配置了 webhook 的路由
   * const webhookRoutes = registry.filter('webhook')
   * ```
   */
  filter(field) {
    return this.routes.filter((r) => field in r && r[field] !== void 0);
  }
  /**
   * 按条件筛选路由
   *
   * @example
   * ```typescript
   * // 获取所有 POST 请求
   * const postRoutes = registry.filterBy(r => r.method === 'POST')
   * ```
   */
  filterBy(predicate) {
    return this.routes.filter(predicate);
  }
  /**
   * 获取路由数量
   */
  get size() {
    return this.routes.length;
  }
  /**
   * 遍历所有路由
   */
  forEach(callback) {
    this.routes.forEach(callback);
  }
  /**
   * 映射所有路由
   */
  map(callback) {
    return this.routes.map(callback);
  }
};
function createRouteRegistry(routes) {
  return new RouteRegistry(routes);
}
var globalRegistry = null;
function setGlobalRegistry(registry) {
  globalRegistry = registry;
}
function getRouteRegistry() {
  if (!globalRegistry) {
    throw new Error("RouteRegistry not initialized. Make sure Server is created first.");
  }
  return globalRegistry;
}
function getRoute(method, path) {
  return getRouteRegistry().get(method, path);
}
function getAllRoutes() {
  return getRouteRegistry().getAll();
}
function filterRoutes(field) {
  return getRouteRegistry().filter(field);
}

// src/server/server.ts
var Server = class extends BaseServer {
  router;
  routes;
  /** 是否已预编译 */
  isCompiled = false;
  /** 预编译时的全局中间件数量 */
  compiledWithMiddlewareCount = 0;
  constructor(routes = []) {
    super();
    this.router = new RadixRouter();
    this.routes = [];
    this.router.setCompiler(
      (middleware, handler) => composeMiddleware(middleware, handler)
    );
    if (routes.length > 0) {
      this.registerRoutes(routes);
    }
  }
  /**
   * 预编译所有路由处理链
   * 在添加所有路由和全局中间件后调用，可提升运行时性能
   */
  compile() {
    this.router.precompileAll(this.globalMiddleware);
    this.isCompiled = true;
    this.compiledWithMiddlewareCount = this.globalMiddleware.length;
    return this;
  }
  registerRoutes(routes) {
    const flattened = flattenNestedRoutes(routes);
    this.routes.push(...flattened);
    for (const route2 of flattened) {
      this.router.register(
        route2.method,
        route2.fullPath,
        route2.handler,
        route2.middlewareChain || []
      );
    }
    this.detectRouteConflicts(flattened);
    this.logFlattenedRoutes(flattened);
    if (this.globalMiddleware.length === 0 && !this.isCompiled) {
      this.compile();
    }
    setGlobalRegistry(new RouteRegistry(this.routes));
  }
  /** 快速提取 pathname */
  extractPathname(url) {
    let start = url.indexOf("://");
    start = start === -1 ? 0 : start + 3;
    const pathStart = url.indexOf("/", start);
    if (pathStart === -1) return "/";
    let end = url.indexOf("?", pathStart);
    if (end === -1) end = url.indexOf("#", pathStart);
    if (end === -1) end = url.length;
    return url.substring(pathStart, end) || "/";
  }
  /** 生成 404/405 响应 */
  createErrorResponse(method, pathname) {
    const allowedMethods = this.router.getAllowedMethods(pathname);
    if (allowedMethods.length > 0) {
      return json(
        {
          success: false,
          error: "Method Not Allowed",
          message: `Method ${method} not allowed for this endpoint`,
          allowedMethods
        },
        405,
        { Allow: allowedMethods.join(", ") }
      );
    }
    return json({ success: false, error: "Not Found" }, 404);
  }
  /** 处理请求 */
  fetch = async (req) => {
    const pathname = this.extractPathname(req.url);
    const method = req.method;
    const match = this.router.match(method, pathname);
    if (match) {
      req.params = match.params;
      if (match.compiled && this.globalMiddleware.length === this.compiledWithMiddlewareCount) {
        return match.compiled(req);
      }
      const allMiddleware = [...this.globalMiddleware, ...match.middleware];
      const handler = composeMiddleware(allMiddleware, match.handler);
      return handler(req);
    }
    if (method === "OPTIONS") {
      const allowedMethods = this.router.getAllowedMethods(pathname);
      if (allowedMethods.length > 0) {
        const anyMatch = this.router.match(
          allowedMethods[0],
          pathname
        );
        const routeMiddleware = anyMatch?.middleware || [];
        const allMiddleware = [...this.globalMiddleware, ...routeMiddleware];
        const optionsHandler = () => new Response(null, {
          status: 204,
          headers: { Allow: allowedMethods.join(", ") }
        });
        const handler = composeMiddleware(allMiddleware, optionsHandler);
        return handler(req);
      }
    }
    if (this.globalMiddleware.length > 0) {
      const handler = composeMiddleware(
        this.globalMiddleware,
        () => this.createErrorResponse(method, pathname)
      );
      return handler(req);
    }
    return this.createErrorResponse(method, pathname);
  };
  addRoute(route2) {
    const flattenedRoute = {
      ...route2,
      fullPath: route2.path,
      middlewareChain: route2.middleware || []
    };
    this.routes.push(flattenedRoute);
    this.router.register(
      route2.method,
      route2.path,
      route2.handler,
      route2.middleware || []
    );
  }
  addRoutes(routes) {
    this.registerRoutes(routes);
  }
  getRoutes() {
    return this.router.getRoutes();
  }
  /**
   * 获取完整的路由元信息（不含 handler 和 middleware）
   *
   * 用于 API 文档生成、Webhook 事件注册、权限检查等场景
   *
   * @example
   * ```typescript
   * const routes = server.getRoutesWithMeta()
   * for (const route of routes) {
   *   console.log(route.fullPath, route.name, route.description)
   * }
   * ```
   */
  getRoutesWithMeta() {
    return this.routes;
  }
};

// src/middleware/component-router.ts
function flattenComponentRoutes(routes) {
  const flattened = [];
  function processRoute(route2, parentPath = "", parentMiddleware = []) {
    const currentPath = parentPath + route2.path;
    const currentMiddleware = [
      ...parentMiddleware,
      ...route2.middleware || []
    ];
    if ("component" in route2) {
      flattened.push({
        ...route2,
        fullPath: currentPath,
        middlewareChain: currentMiddleware
      });
    } else if ("children" in route2 && route2.children) {
      for (const child of route2.children) {
        processRoute(child, currentPath, currentMiddleware);
      }
    }
  }
  for (const route2 of routes) {
    processRoute(route2);
  }
  return flattened;
}

// src/utils/path-matcher.ts
var PathMatcher = class {
  /**
   * 路径匹配
   */
  static matchPath(pattern, path) {
    const patternParts = pattern.split("/").filter(Boolean);
    const pathParts = path.split("/").filter(Boolean);
    if (patternParts.length !== pathParts.length) {
      return false;
    }
    for (let i = 0; i < patternParts.length; i++) {
      if (patternParts[i] !== pathParts[i] && !patternParts[i].startsWith(":")) {
        return false;
      }
    }
    return true;
  }
  /**
   * 提取路径参数
   */
  static extractParams(pattern, path) {
    const params = {};
    const patternParts = pattern.split("/").filter(Boolean);
    const pathParts = path.split("/").filter(Boolean);
    for (let i = 0; i < patternParts.length; i++) {
      if (patternParts[i].startsWith(":")) {
        const paramName = patternParts[i].slice(1);
        params[paramName] = pathParts[i];
      }
    }
    return params;
  }
  /**
   * 计算路径特异性分数
   * 用于路由排序：静态 > 动态(:param) > 通配符(*)
   */
  static calculatePathScore(path) {
    const parts = path.split("/").filter(Boolean);
    let score = 0;
    for (const p of parts) {
      if (p === "*")
        score += 1;
      else if (p.startsWith(":"))
        score += 2;
      else score += 3;
    }
    return score * 10 + parts.length;
  }
  /**
   * 判断两个路径是否可能冲突
   */
  static pathsMayConflict(path1, path2) {
    const parts1 = path1.split("/").filter(Boolean);
    const parts2 = path2.split("/").filter(Boolean);
    if (parts1.length !== parts2.length) return false;
    for (let i = 0; i < parts1.length; i++) {
      const p1 = parts1[i];
      const p2 = parts2[i];
      if (!p1.startsWith(":") && !p1.startsWith("*") && !p2.startsWith(":") && !p2.startsWith("*") && p1 !== p2) {
        return false;
      }
      if (p1 === "*" && p2.startsWith(":") || p2 === "*" && p1.startsWith(":")) {
        return true;
      }
    }
    return false;
  }
};

// src/utils/html-renderer.ts
var HtmlRenderer = class {
  /**
   * 生成基础HTML模板
   */
  static generateBaseHtml(content, context, clientScriptPath = "/client.js") {
    return `
      <!doctype html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>Vafast SSR App</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
        </head>
        <body>
          <div id="app">${content}</div>
          <script>
            window.__ROUTE_INFO__ = {
              params: ${JSON.stringify(context.params || {})},
              query: ${JSON.stringify(context.query || {})},
              pathname: '${context.pathname}'
            };
          </script>
          <script type="module" src="${clientScriptPath}"></script>
        </body>
      </html>
    `;
  }
  /**
   * 生成Vue组件HTML
   */
  static generateVueHtml(content, context, clientScriptPath = "/client.js") {
    return this.generateBaseHtml(content, context, clientScriptPath);
  }
  /**
   * 生成React组件HTML
   */
  static generateReactHtml(content, context, clientScriptPath = "/client.js") {
    return `
      <!doctype html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>Vafast SSR App</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
        </head>
        <body>
          <div id="root">${content}</div>
          <script>
            window.__ROUTE_INFO__ = {
              params: ${JSON.stringify(context.params || {})},
              query: ${JSON.stringify(context.query || {})},
              pathname: '${context.pathname}'
            };
          </script>
          <script type="module" src="${clientScriptPath}"></script>
        </body>
      </html>
    `;
  }
};

// src/utils/dependency-manager.ts
var DependencyManager = class {
  dependencyCache = /* @__PURE__ */ new Map();
  /**
   * 按需获取框架依赖
   */
  async getFrameworkDeps(framework) {
    if (this.dependencyCache.has(framework)) {
      return this.dependencyCache.get(framework);
    }
    console.log(`\u{1F4E6} \u6309\u9700\u52A0\u8F7D ${framework} \u4F9D\u8D56...`);
    try {
      let deps;
      switch (framework) {
        case "vue":
          deps = await Promise.all([
            import("vue"),
            import("@vue/server-renderer")
          ]);
          break;
        case "react":
          deps = await Promise.all([
            import("react"),
            import("react-dom/server")
          ]);
          break;
        default:
          throw new Error(`\u4E0D\u652F\u6301\u7684\u6846\u67B6: ${framework}`);
      }
      this.dependencyCache.set(framework, deps);
      console.log(`\u2705 ${framework} \u4F9D\u8D56\u52A0\u8F7D\u5B8C\u6210`);
      return deps;
    } catch (error) {
      console.error(`\u274C ${framework} \u4F9D\u8D56\u52A0\u8F7D\u5931\u8D25:`, error);
      throw error;
    }
  }
  /**
   * 检测组件类型
   */
  detectComponentType(component) {
    if (component.render && typeof component.render === "function") {
      return "vue";
    }
    if (component.$$typeof) {
      return "react";
    }
    return "vue";
  }
  /**
   * 清除缓存
   */
  clearCache() {
    this.dependencyCache.clear();
    console.log("\u{1F9F9} \u4F9D\u8D56\u7F13\u5B58\u5DF2\u6E05\u9664");
  }
  /**
   * 获取缓存状态
   */
  getCacheStatus() {
    const status = {};
    for (const [framework] of this.dependencyCache) {
      status[framework] = true;
    }
    return status;
  }
};

// src/server/component-server.ts
var ComponentServer = class extends BaseServer {
  routes;
  dependencyManager;
  constructor(routes) {
    super();
    this.routes = flattenComponentRoutes(routes);
    this.dependencyManager = new DependencyManager();
    this.detectRouteConflicts(this.routes);
    this.logFlattenedRoutes(this.routes, "\u7EC4\u4EF6\u8DEF\u7531");
    console.log("\u{1F680} \u4F9D\u8D56\u6309\u9700\u52A0\u8F7D\uFF0C\u670D\u52A1\u5668\u542F\u52A8\u5B8C\u6210");
  }
  /**
   * 处理请求
   */
  async fetch(req) {
    const url = new URL(req.url);
    const pathname = url.pathname;
    const method = req.method;
    if (method !== "GET") {
      return new Response("Method Not Allowed", { status: 405 });
    }
    let matchedRoute = null;
    for (const route2 of this.routes) {
      if (PathMatcher.matchPath(route2.fullPath, pathname)) {
        matchedRoute = route2;
        break;
      }
    }
    if (!matchedRoute) {
      return new Response("Not Found", { status: 404 });
    }
    try {
      const context = {
        req,
        params: PathMatcher.extractParams(matchedRoute.fullPath, pathname),
        query: Object.fromEntries(url.searchParams),
        pathname
      };
      return await this.executeMiddlewareChain(
        matchedRoute.middlewareChain,
        context,
        matchedRoute.component
      );
    } catch (error) {
      console.error("\u7EC4\u4EF6\u6E32\u67D3\u5931\u8D25:", error);
      return new Response("Internal Server Error", { status: 500 });
    }
  }
  /**
   * 执行中间件链
   */
  async executeMiddlewareChain(middlewareChain, context, componentImport) {
    const renderComponent = async () => {
      const componentModule = await componentImport();
      const component = componentModule.default || componentModule;
      const componentType = this.dependencyManager.detectComponentType(component);
      const deps = await this.dependencyManager.getFrameworkDeps(componentType);
      if (componentType === "vue") {
        return await this.renderVueComponent(component, context, deps);
      } else if (componentType === "react") {
        return await this.renderReactComponent(component, context, deps);
      } else {
        throw new Error(`\u4E0D\u652F\u6301\u7684\u7EC4\u4EF6\u7C7B\u578B: ${componentType}`);
      }
    };
    let index = 0;
    const next = async () => {
      if (index >= middlewareChain.length) {
        return await renderComponent();
      }
      const middleware = middlewareChain[index++];
      return await middleware(context.req, next);
    };
    return await next();
  }
  /**
   * 渲染 Vue 组件
   */
  async renderVueComponent(component, context, deps) {
    try {
      const [vue, renderer] = deps;
      const app = vue.createSSRApp(component);
      app.provide("routeInfo", {
        params: context.params || {},
        query: context.query || {},
        pathname: context.pathname
      });
      const html2 = await renderer.renderToString(app);
      const fullHtml = HtmlRenderer.generateVueHtml(html2, context);
      return new Response(fullHtml, {
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    } catch (error) {
      console.error("Vue \u7EC4\u4EF6\u6E32\u67D3\u5931\u8D25:", error);
      return new Response("Vue Component Render Error", { status: 500 });
    }
  }
  /**
   * 渲染 React 组件
   */
  async renderReactComponent(component, context, deps) {
    try {
      const [react, renderer] = deps;
      const content = react.createElement(component, {
        req: context.req,
        params: context.params || {},
        query: context.query || {}
      });
      const html2 = renderer.renderToString(content);
      const fullHtml = HtmlRenderer.generateReactHtml(html2, context);
      return new Response(fullHtml, {
        headers: { "Content-Type": "text/html; charset=utf-8" }
      });
    } catch (error) {
      console.error("React \u7EC4\u4EF6\u6E32\u67D3\u5931\u8D25:", error);
      return new Response("React Component Render Error", { status: 500 });
    }
  }
  /**
   * 获取依赖管理器（用于外部访问）
   */
  getDependencyManager() {
    return this.dependencyManager;
  }
};

// src/server/server-factory.ts
var ServerFactory = class {
  servers = /* @__PURE__ */ new Map();
  /**
   * 创建标准REST API服务器
   */
  createRestServer(routes) {
    const server = new Server(routes);
    this.servers.set("rest", server);
    return server;
  }
  /**
   * 创建组件服务器
   */
  createComponentServer(routes) {
    const server = new ComponentServer(routes);
    this.servers.set("component", server);
    return server;
  }
  /**
   * 获取指定类型的服务器
   */
  getServer(type) {
    return this.servers.get(type);
  }
  /**
   * 获取所有服务器
   */
  getAllServers() {
    return this.servers;
  }
  /**
   * 移除指定类型的服务器
   */
  removeServer(type) {
    return this.servers.delete(type);
  }
  /**
   * 清除所有服务器
   */
  clearServers() {
    this.servers.clear();
  }
  /**
   * 获取服务器状态信息
   */
  getServerStatus() {
    const status = {};
    for (const [name, server] of this.servers) {
      if (server instanceof Server) {
        status[name] = {
          type: "REST API",
          routes: server.routes?.length || 0
        };
      } else if (server instanceof ComponentServer) {
        status[name] = {
          type: "Component",
          routes: server.routes?.length || 0
        };
      }
    }
    return status;
  }
};

// src/utils/parsers.ts
import qs from "qs";
import cookie from "cookie";
async function parseBody(req) {
  const contentType = req.headers.get("content-type") || "";
  if (contentType.includes("application/json")) {
    return await req.json();
  }
  if (contentType.includes("application/x-www-form-urlencoded")) {
    const text2 = await req.text();
    return Object.fromEntries(new URLSearchParams(text2));
  }
  return await req.text();
}
function extractQueryString(url) {
  const qIndex = url.indexOf("?");
  if (qIndex === -1) return "";
  const hashIndex = url.indexOf("#", qIndex);
  return hashIndex === -1 ? url.substring(qIndex + 1) : url.substring(qIndex + 1, hashIndex);
}
function parseQuery(req) {
  const queryString = extractQueryString(req.url);
  if (!queryString) return {};
  return qs.parse(queryString);
}
function parseQueryFast(req) {
  const queryString = extractQueryString(req.url);
  if (!queryString) return {};
  const result = /* @__PURE__ */ Object.create(null);
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const eqIndex = pair.indexOf("=");
    if (eqIndex === -1) {
      result[decodeURIComponent(pair)] = "";
    } else {
      const key = decodeURIComponent(pair.substring(0, eqIndex));
      const value = decodeURIComponent(pair.substring(eqIndex + 1));
      result[key] = value;
    }
  }
  return result;
}
function parseHeaders(req) {
  const headers = /* @__PURE__ */ Object.create(null);
  req.headers.forEach((value, key) => {
    headers[key] = value;
  });
  return headers;
}
function getHeader(req, name) {
  return req.headers.get(name);
}
function parseCookies(req) {
  const cookieHeader = req.headers.get("cookie");
  if (!cookieHeader) return {};
  try {
    const parsed = cookie.parse(cookieHeader);
    const result = {};
    for (const [key, value] of Object.entries(parsed)) {
      if (value !== void 0 && value !== null) {
        result[key] = value;
      }
    }
    return result;
  } catch {
    return {};
  }
}
function parseCookiesFast(req) {
  const cookieHeader = req.headers.get("cookie");
  if (!cookieHeader) return {};
  const result = /* @__PURE__ */ Object.create(null);
  const pairs = cookieHeader.split(";");
  for (const pair of pairs) {
    const trimmed = pair.trim();
    const eqIndex = trimmed.indexOf("=");
    if (eqIndex > 0) {
      const key = trimmed.substring(0, eqIndex).trim();
      const value = trimmed.substring(eqIndex + 1).trim();
      result[key] = value.startsWith('"') && value.endsWith('"') ? value.slice(1, -1) : value;
    }
  }
  return result;
}
function getCookie(req, name) {
  const cookieHeader = req.headers.get("cookie");
  if (!cookieHeader) return null;
  const prefix = `${name}=`;
  const pairs = cookieHeader.split(";");
  for (const pair of pairs) {
    const trimmed = pair.trim();
    if (trimmed.startsWith(prefix)) {
      const value = trimmed.substring(prefix.length).trim();
      return value.startsWith('"') && value.endsWith('"') ? value.slice(1, -1) : value;
    }
  }
  return null;
}

// src/utils/go-await.ts
function goAwait(promise) {
  return promise.then((data) => [null, data]).catch((err) => [err instanceof Error ? err : new Error(String(err)), void 0]);
}

// src/utils/validators/validators.ts
import { Type } from "@sinclair/typebox";
import { TypeCompiler } from "@sinclair/typebox/compiler";
var compilerCache = /* @__PURE__ */ new WeakMap();
function getCompiledValidator(schema) {
  let compiler = compilerCache.get(schema);
  if (!compiler) {
    compiler = TypeCompiler.Compile(schema);
    compilerCache.set(schema, compiler);
  }
  return compiler;
}
function validateSchema(schema, data) {
  try {
    const compiler = getCompiledValidator(schema);
    if (compiler.Check(data)) {
      return { success: true, data };
    }
    const errors = [];
    for (const error of compiler.Errors(data)) {
      errors.push({
        path: error.path,
        message: error.message,
        code: "VALIDATION_FAILED",
        value: error.value
      });
    }
    return { success: false, errors };
  } catch (error) {
    return {
      success: false,
      errors: [
        {
          path: "",
          message: error instanceof Error ? error.message : "\u9A8C\u8BC1\u5F02\u5E38",
          code: "VALIDATION_EXCEPTION"
        }
      ]
    };
  }
}
function validateSchemaOrThrow(schema, data, context) {
  const compiler = getCompiledValidator(schema);
  if (!compiler.Check(data)) {
    throw new Error(`${context}\u9A8C\u8BC1\u5931\u8D25`);
  }
  return data;
}
function validateFast(schema, data) {
  const compiler = getCompiledValidator(schema);
  return compiler.Check(data);
}
function validateAllSchemas(config, data) {
  if (config.body) {
    validateSchemaOrThrow(config.body, data.body, "\u8BF7\u6C42\u4F53");
  }
  if (config.query) {
    validateSchemaOrThrow(config.query, data.query, "Query\u53C2\u6570");
  }
  if (config.params) {
    validateSchemaOrThrow(config.params, data.params, "\u8DEF\u5F84\u53C2\u6570");
  }
  if (config.headers) {
    validateSchemaOrThrow(config.headers, data.headers, "\u8BF7\u6C42\u5934");
  }
  if (config.cookies) {
    validateSchemaOrThrow(config.cookies, data.cookies, "Cookie");
  }
  return data;
}
function precompileSchemas(config) {
  if (config.body) getCompiledValidator(config.body);
  if (config.query) getCompiledValidator(config.query);
  if (config.params) getCompiledValidator(config.params);
  if (config.headers) getCompiledValidator(config.headers);
  if (config.cookies) getCompiledValidator(config.cookies);
}
function createValidator(schema) {
  return (data) => validateSchema(schema, data);
}
function getValidatorCacheStats() {
  return {
    cacheType: "WeakMap",
    note: "WeakMap \u7F13\u5B58\u4F1A\u968F Schema \u5BF9\u8C61\u81EA\u52A8\u6E05\u7406\uFF0C\u65E0\u5185\u5B58\u6CC4\u6F0F\u98CE\u9669"
  };
}

// src/utils/create-handler.ts
function autoResponse(result) {
  if (result instanceof Response) {
    return result;
  }
  if (result === null || result === void 0) {
    return new Response(null, { status: 204 });
  }
  if (typeof result === "string") {
    return new Response(result, {
      headers: { "Content-Type": "text/plain; charset=utf-8" }
    });
  }
  if (typeof result === "number" || typeof result === "boolean") {
    return new Response(String(result), {
      headers: { "Content-Type": "text/plain; charset=utf-8" }
    });
  }
  if (typeof result === "object") {
    const obj = result;
    if ("data" in obj && ("status" in obj || "headers" in obj)) {
      const { data, status = 200, headers = {} } = obj;
      if (data === null || data === void 0) {
        return new Response(null, {
          status: status === 200 ? 204 : status,
          headers
        });
      }
      if (typeof data === "string" || typeof data === "number" || typeof data === "boolean") {
        return new Response(String(data), {
          status,
          headers: {
            "Content-Type": "text/plain; charset=utf-8",
            ...headers
          }
        });
      }
      return json(data, status, headers);
    }
    return json(result);
  }
  return new Response(null, { status: 204 });
}
function handleValidationError(error) {
  return json(
    {
      success: false,
      error: "Validation Error",
      message: error.message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    },
    400
  );
}
function handleInternalError(error) {
  return json(
    {
      success: false,
      error: "Internal Error",
      message: error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF"
    },
    500
  );
}
function isHandler(value) {
  return typeof value === "function";
}
function createHandler(schemaOrHandler, maybeHandler) {
  const hasSchema = !isHandler(schemaOrHandler);
  const schema = hasSchema ? schemaOrHandler : {};
  const handler = hasSchema ? maybeHandler : schemaOrHandler;
  if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
    precompileSchemas(schema);
  }
  const handlerFn = async (req) => {
    try {
      const query = parseQuery(req);
      const headers = parseHeaders(req);
      const cookies = parseCookies(req);
      const params = req.params || {};
      let body = void 0;
      if (req.method !== "GET" && req.method !== "HEAD") {
        const [, parsedBody] = await goAwait(parseBody(req));
        body = parsedBody;
      }
      const data = { body, query, params, headers, cookies };
      if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
        validateAllSchemas(schema, data);
      }
      const result = await handler({
        req,
        body,
        query,
        params,
        headers,
        cookies
      });
      return autoResponse(result);
    } catch (error) {
      if (error instanceof Error && error.message.includes("\u9A8C\u8BC1\u5931\u8D25")) {
        return handleValidationError(error);
      }
      return handleInternalError(error);
    }
  };
  return handlerFn;
}
function createHandlerWithExtra(schemaOrHandler, maybeHandler) {
  const hasSchema = !isHandler(schemaOrHandler);
  const schema = hasSchema ? schemaOrHandler : {};
  const handler = hasSchema ? maybeHandler : schemaOrHandler;
  if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
    precompileSchemas(schema);
  }
  return async (req) => {
    try {
      const query = parseQuery(req);
      const headers = parseHeaders(req);
      const cookies = parseCookies(req);
      const params = req.params || {};
      let body = void 0;
      if (req.method !== "GET" && req.method !== "HEAD") {
        const [, parsedBody] = await goAwait(parseBody(req));
        body = parsedBody;
      }
      const data = { body, query, params, headers, cookies };
      if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
        validateAllSchemas(schema, data);
      }
      const extras = req.__locals ?? {};
      const result = await handler({
        req,
        body,
        query,
        params,
        headers,
        cookies,
        ...extras
      });
      return autoResponse(result);
    } catch (error) {
      if (error instanceof Error && error.message.includes("\u9A8C\u8BC1\u5931\u8D25")) {
        return handleValidationError(error);
      }
      return handleInternalError(error);
    }
  };
}
function simpleHandler(handler) {
  return async (req) => {
    try {
      const result = await handler({ req });
      return autoResponse(result);
    } catch (error) {
      return handleInternalError(error);
    }
  };
}

// src/utils/base64url.ts
function base64urlEncode(str) {
  return btoa(str).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64urlDecode(str) {
  const pad = str.length % 4 === 0 ? "" : "=".repeat(4 - str.length % 4);
  const base64 = str.replace(/-/g, "+").replace(/_/g, "/") + pad;
  return atob(base64);
}

// src/utils/handle.ts
function getCookie2(req, key) {
  const cookies = parseCookies(req);
  return cookies[key] || null;
}
function setLocals(req, extras) {
  const target = req;
  target.__locals = { ...target.__locals ?? {}, ...extras };
}
function getLocals(req) {
  const target = req;
  return target.__locals ?? {};
}

// src/utils/request-validator.ts
async function parseRequest(request, params) {
  const requestData = {
    body: void 0,
    query: parseQuery(request),
    params: params || {},
    headers: parseHeaders(request),
    cookies: parseCookies(request)
  };
  if (request.method !== "GET" && request.method !== "HEAD") {
    requestData.body = await parseBody(request);
  }
  return requestData;
}
function validateRequest(config, requestData) {
  try {
    const validatedData = validateAllSchemas(config, requestData);
    return {
      success: true,
      data: validatedData
    };
  } catch (error) {
    return {
      success: false,
      errors: [
        {
          field: "unknown",
          message: error instanceof Error ? error.message : "\u9A8C\u8BC1\u5931\u8D25"
        }
      ]
    };
  }
}
async function parseAndValidateRequest(request, config, params) {
  try {
    const requestData = await parseRequest(request, params);
    return validateRequest(config, requestData);
  } catch (error) {
    return {
      success: false,
      errors: [
        {
          field: "unknown",
          message: error instanceof Error ? error.message : "\u8BF7\u6C42\u89E3\u6790\u5931\u8D25"
        }
      ]
    };
  }
}
function createRequestValidator(config) {
  return async (request, params) => {
    return parseAndValidateRequest(request, config, params);
  };
}

// src/utils/formats.ts
import { FormatRegistry } from "@sinclair/typebox";
var EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
var UUID_ANY_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
var CUID_REGEX = /^c[^\s-]{8,}$/i;
var CUID2_REGEX = /^[0-9a-z]+$/;
var ULID_REGEX = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var NANOID_REGEX = /^[A-Za-z0-9_-]{21}$/;
var URL_REGEX = /^https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b[-a-zA-Z0-9()@:%_+.~#?&/=]*$/;
var IPV4_REGEX = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
var IPV6_REGEX = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^::(?:[0-9a-fA-F]{1,4}:){0,6}[0-9a-fA-F]{1,4}$|^(?:[0-9a-fA-F]{1,4}:){1,7}:$|^(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}$|^(?:[0-9a-fA-F]{1,4}:){1,5}(?::[0-9a-fA-F]{1,4}){1,2}$|^(?:[0-9a-fA-F]{1,4}:){1,4}(?::[0-9a-fA-F]{1,4}){1,3}$|^(?:[0-9a-fA-F]{1,4}:){1,3}(?::[0-9a-fA-F]{1,4}){1,4}$|^(?:[0-9a-fA-F]{1,4}:){1,2}(?::[0-9a-fA-F]{1,4}){1,5}$|^[0-9a-fA-F]{1,4}:(?::[0-9a-fA-F]{1,4}){1,6}$/;
var CIDR_REGEX = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\/(?:3[0-2]|[12]?[0-9])$/;
var DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12][0-9]|3[01])$/;
var TIME_REGEX = /^(?:[01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](?:\.\d{1,3})?$/;
var DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12][0-9]|3[01])T(?:[01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](?:\.\d{1,3})?(?:Z|[+-](?:[01][0-9]|2[0-3]):[0-5][0-9])?$/;
var DURATION_REGEX = /^P(?:\d+Y)?(?:\d+M)?(?:\d+W)?(?:\d+D)?(?:T(?:\d+H)?(?:\d+M)?(?:\d+(?:\.\d+)?S)?)?$/;
var HOSTNAME_REGEX = /^(?=.{1,253}$)(?:(?!-)[a-zA-Z0-9-]{1,63}(?<!-)\.)*(?!-)[a-zA-Z0-9-]{1,63}(?<!-)$/;
var PHONE_CN_REGEX = /^1[3-9]\d{9}$/;
var PHONE_E164_REGEX = /^\+[1-9]\d{6,14}$/;
var OBJECTID_REGEX = /^[0-9a-fA-F]{24}$/;
var HEX_COLOR_REGEX = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
var RGB_COLOR_REGEX = /^rgba?\(\s*(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\s*,\s*(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\s*,\s*(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?:\s*,\s*(?:0|1|0?\.\d+))?\s*\)$/;
var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
var BASE64URL_REGEX = /^[A-Za-z0-9_-]+$/;
var JWT_REGEX = /^[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+$/;
var EMOJI_REGEX = /^[\p{Emoji}]+$/u;
var SLUG_REGEX = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
var SEMVER_REGEX = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
function isValidCreditCard(value) {
  const digits = value.replace(/\D/g, "");
  if (digits.length < 13 || digits.length > 19) return false;
  let sum = 0;
  let isEven = false;
  for (let i = digits.length - 1; i >= 0; i--) {
    let digit = parseInt(digits[i], 10);
    if (isEven) {
      digit *= 2;
      if (digit > 9) digit -= 9;
    }
    sum += digit;
    isEven = !isEven;
  }
  return sum % 10 === 0;
}
var isRegistered = false;
function registerFormats() {
  if (isRegistered) return;
  isRegistered = true;
  FormatRegistry.Set("email", (v) => EMAIL_REGEX.test(v));
  FormatRegistry.Set("uuid", (v) => UUID_REGEX.test(v));
  FormatRegistry.Set("uuid-any", (v) => UUID_ANY_REGEX.test(v));
  FormatRegistry.Set("cuid", (v) => CUID_REGEX.test(v));
  FormatRegistry.Set("cuid2", (v) => CUID2_REGEX.test(v) && v.length >= 1);
  FormatRegistry.Set("ulid", (v) => ULID_REGEX.test(v));
  FormatRegistry.Set("nanoid", (v) => NANOID_REGEX.test(v));
  FormatRegistry.Set("objectid", (v) => OBJECTID_REGEX.test(v));
  FormatRegistry.Set("slug", (v) => SLUG_REGEX.test(v));
  FormatRegistry.Set("url", (v) => URL_REGEX.test(v));
  FormatRegistry.Set("uri", (v) => URL_REGEX.test(v));
  FormatRegistry.Set("ipv4", (v) => IPV4_REGEX.test(v));
  FormatRegistry.Set("ipv6", (v) => IPV6_REGEX.test(v));
  FormatRegistry.Set("ip", (v) => IPV4_REGEX.test(v) || IPV6_REGEX.test(v));
  FormatRegistry.Set("cidr", (v) => CIDR_REGEX.test(v));
  FormatRegistry.Set("hostname", (v) => HOSTNAME_REGEX.test(v));
  FormatRegistry.Set("date", (v) => DATE_REGEX.test(v));
  FormatRegistry.Set("time", (v) => TIME_REGEX.test(v));
  FormatRegistry.Set("date-time", (v) => DATE_TIME_REGEX.test(v));
  FormatRegistry.Set("datetime", (v) => DATE_TIME_REGEX.test(v));
  FormatRegistry.Set("duration", (v) => DURATION_REGEX.test(v));
  FormatRegistry.Set("phone", (v) => PHONE_CN_REGEX.test(v));
  FormatRegistry.Set("phone-cn", (v) => PHONE_CN_REGEX.test(v));
  FormatRegistry.Set("phone-e164", (v) => PHONE_E164_REGEX.test(v));
  FormatRegistry.Set("base64", (v) => BASE64_REGEX.test(v));
  FormatRegistry.Set("base64url", (v) => BASE64URL_REGEX.test(v));
  FormatRegistry.Set("jwt", (v) => JWT_REGEX.test(v));
  FormatRegistry.Set("hex-color", (v) => HEX_COLOR_REGEX.test(v));
  FormatRegistry.Set("rgb-color", (v) => RGB_COLOR_REGEX.test(v));
  FormatRegistry.Set(
    "color",
    (v) => HEX_COLOR_REGEX.test(v) || RGB_COLOR_REGEX.test(v)
  );
  FormatRegistry.Set("emoji", (v) => EMOJI_REGEX.test(v));
  FormatRegistry.Set("semver", (v) => SEMVER_REGEX.test(v));
  FormatRegistry.Set("credit-card", isValidCreditCard);
}
function registerFormat(name, validator) {
  FormatRegistry.Set(name, validator);
}
function hasFormat(name) {
  return FormatRegistry.Has(name);
}
var Patterns = {
  EMAIL: EMAIL_REGEX,
  UUID: UUID_REGEX,
  URL: URL_REGEX,
  IPV4: IPV4_REGEX,
  IPV6: IPV6_REGEX,
  DATE: DATE_REGEX,
  TIME: TIME_REGEX,
  DATE_TIME: DATE_TIME_REGEX,
  PHONE_CN: PHONE_CN_REGEX,
  PHONE_E164: PHONE_E164_REGEX,
  OBJECTID: OBJECTID_REGEX,
  HEX_COLOR: HEX_COLOR_REGEX,
  SLUG: SLUG_REGEX,
  SEMVER: SEMVER_REGEX,
  JWT: JWT_REGEX
};

// src/utils/sse.ts
function formatSSEEvent(event) {
  const lines = [];
  if (event.id !== void 0) {
    lines.push(`id: ${event.id}`);
  }
  if (event.event !== void 0) {
    lines.push(`event: ${event.event}`);
  }
  if (event.retry !== void 0) {
    lines.push(`retry: ${event.retry}`);
  }
  const dataStr = typeof event.data === "string" ? event.data : JSON.stringify(event.data);
  const dataLines = dataStr.split("\n");
  for (const line of dataLines) {
    lines.push(`data: ${line}`);
  }
  return lines.join("\n") + "\n\n";
}
function createSSEHandler(schemaOrGenerator, maybeGenerator) {
  const hasSchema = typeof schemaOrGenerator !== "function";
  const schema = hasSchema ? schemaOrGenerator : {};
  const generator = hasSchema ? maybeGenerator : schemaOrGenerator;
  if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
    precompileSchemas(schema);
  }
  const handlerFn = async (req) => {
    try {
      const query = parseQuery(req);
      const headers = parseHeaders(req);
      const cookies = parseCookies(req);
      const params = req.params || {};
      const data = { body: void 0, query, params, headers, cookies };
      if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
        validateAllSchemas(schema, data);
      }
      const stream2 = new ReadableStream({
        async start(controller) {
          const encoder2 = new TextEncoder();
          try {
            const gen = generator({
              req,
              body: void 0,
              query,
              params,
              headers,
              cookies
            });
            for await (const event of gen) {
              const formatted = formatSSEEvent(event);
              controller.enqueue(encoder2.encode(formatted));
            }
          } catch (error) {
            const errorEvent = formatSSEEvent({
              event: "error",
              data: {
                message: error instanceof Error ? error.message : "Unknown error"
              }
            });
            controller.enqueue(encoder2.encode(errorEvent));
          } finally {
            controller.close();
          }
        }
      });
      return new Response(stream2, {
        headers: {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          "Connection": "keep-alive",
          "X-Accel-Buffering": "no"
          // Nginx 禁用缓冲
        }
      });
    } catch (error) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Validation Error",
          message: error instanceof Error ? error.message : "Unknown error"
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
  };
  const handler = handlerFn;
  handler.__sse = { __brand: "SSE" };
  handler.__schema = schema;
  handler.__returnType = void 0;
  return handler;
}

// src/middleware/authMiddleware.ts
var requireAuth = async (req, next) => {
  const token = getCookie2(req, "auth");
  if (!token || token !== "valid-token") {
    throw new VafastError("Unauthorized", {
      status: 401,
      type: "unauthorized",
      expose: true
    });
  }
  return next();
};

// src/middleware/rateLimit.ts
var store = /* @__PURE__ */ new Map();
function rateLimit(options = {}) {
  const windowMs = options.windowMs ?? 6e4;
  const max = options.max ?? 30;
  const keyFn = options.keyFn ?? getIP;
  return async (req, next) => {
    const key = keyFn(req);
    const now = Date.now();
    const entry = store.get(key);
    if (entry && entry.expires > now) {
      if (entry.count >= max) {
        throw new VafastError("Too many requests", {
          status: 429,
          type: "rate_limit",
          expose: true
        });
      }
      entry.count += 1;
    } else {
      store.set(key, { count: 1, expires: now + windowMs });
    }
    return next();
  };
}
function getIP(req) {
  return req.headers.get("cf-connecting-ip") || // Cloudflare
  req.headers.get("x-forwarded-for")?.split(",")[0]?.trim() || // Vercel
  "unknown";
}

// src/middleware/cors.ts
function createCORS(options = {}) {
  const {
    origin = [],
    methods = ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    headers = [],
    credentials = false,
    maxAge
  } = options;
  return async (req, next) => {
    const reqOrigin = req.headers.get("Origin") || "";
    const isAllowedOrigin = origin === "*" || origin.includes(reqOrigin);
    if (req.method === "OPTIONS") {
      const resHeaders = new Headers();
      if (isAllowedOrigin) {
        resHeaders.set(
          "Access-Control-Allow-Origin",
          origin === "*" ? "*" : reqOrigin
        );
        resHeaders.set("Access-Control-Allow-Methods", methods.join(","));
        resHeaders.set("Access-Control-Allow-Headers", headers.join(","));
        if (credentials)
          resHeaders.set("Access-Control-Allow-Credentials", "true");
        if (maxAge) resHeaders.set("Access-Control-Max-Age", maxAge.toString());
      }
      return new Response(null, { status: 204, headers: resHeaders });
    }
    const res = await next();
    if (isAllowedOrigin) {
      res.headers.set(
        "Access-Control-Allow-Origin",
        origin === "*" ? "*" : reqOrigin
      );
      if (credentials)
        res.headers.set("Access-Control-Allow-Credentials", "true");
    }
    return res;
  };
}

// src/auth/token.ts
var TokenError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = "TokenError";
  }
};
var encoder = new TextEncoder();
async function sign(data, secret) {
  const key = await crypto.subtle.importKey(
    "raw",
    encoder.encode(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const signature = await crypto.subtle.sign("HMAC", key, encoder.encode(data));
  return btoa(
    String.fromCharCode.apply(null, Array.from(new Uint8Array(signature)))
  );
}
async function generateToken(payload, secret, options = {}) {
  const { expiresIn = 3600, issuer, audience, subject } = options;
  const now = Math.floor(Date.now() / 1e3);
  const tokenPayload = {
    ...payload,
    iat: now,
    exp: now + expiresIn
  };
  if (issuer) tokenPayload.iss = issuer;
  if (audience) tokenPayload.aud = audience;
  if (subject) tokenPayload.sub = subject;
  const data = base64urlEncode(JSON.stringify(tokenPayload));
  const sig = await sign(data, secret);
  const token = `${data}.${base64urlEncode(sig)}`;
  return {
    payload: tokenPayload,
    token,
    expiresAt: tokenPayload.exp * 1e3
    // 转换为毫秒
  };
}
async function verifyToken(token, secret) {
  try {
    const [data, sig] = token.split(".");
    if (!data || !sig) {
      throw new TokenError("\u4EE4\u724C\u683C\u5F0F\u65E0\u6548", "MALFORMED_TOKEN");
    }
    const expectedSig = await sign(data, secret);
    const expected = base64urlEncode(expectedSig);
    if (sig !== expected) {
      throw new TokenError("\u4EE4\u724C\u7B7E\u540D\u65E0\u6548", "INVALID_SIGNATURE");
    }
    const payload = JSON.parse(base64urlDecode(data));
    if (payload.exp && Date.now() / 1e3 > payload.exp) {
      throw new TokenError("\u4EE4\u724C\u5DF2\u8FC7\u671F", "EXPIRED_TOKEN");
    }
    return payload;
  } catch (error) {
    if (error instanceof TokenError) {
      throw error;
    }
    throw new TokenError("\u4EE4\u724C\u9A8C\u8BC1\u5931\u8D25", "INVALID_TOKEN");
  }
}
function parseToken(token) {
  try {
    const [data] = token.split(".");
    if (!data) return null;
    return JSON.parse(base64urlDecode(data));
  } catch {
    return null;
  }
}
function isTokenExpired(token) {
  const payload = parseToken(token);
  if (!payload || !payload.exp) return true;
  return Date.now() / 1e3 > payload.exp;
}
function getTokenTimeRemaining(token) {
  const payload = parseToken(token);
  if (!payload || !payload.exp) return 0;
  const remaining = payload.exp - Date.now() / 1e3;
  return Math.max(0, Math.floor(remaining));
}
async function refreshToken(token, secret, options = {}) {
  try {
    const payload = await verifyToken(token, secret);
    if (!payload) return null;
    const { exp, iat, ...cleanPayload } = payload;
    await new Promise((resolve) => setTimeout(resolve, 10));
    return await generateToken(cleanPayload, secret, options);
  } catch {
    return null;
  }
}
async function createTokenPair(payload, secret, options = {}) {
  const accessToken = await generateToken(payload, secret, {
    ...options,
    expiresIn: options.expiresIn || 3600
    // 1小时
  });
  const refreshToken2 = await generateToken(payload, secret, {
    ...options,
    expiresIn: 7 * 24 * 3600
    // 7天
  });
  return { accessToken, refreshToken: refreshToken2 };
}

// src/middleware/auth.ts
function createAuth(options) {
  const {
    secret,
    cookieName = "auth",
    headerName = "authorization",
    required = true,
    roles = [],
    permissions = []
  } = options;
  return async (req, next) => {
    const token = getCookie2(req, cookieName) || req.headers.get(headerName)?.replace("Bearer ", "") || "";
    if (!token && required) {
      throw new VafastError("\u7F3A\u5C11\u8BA4\u8BC1\u4EE4\u724C", {
        status: 401,
        type: "unauthorized",
        expose: true
      });
    }
    if (!token && !required) {
      return next();
    }
    try {
      const user = await verifyToken(token, secret);
      if (!user) {
        throw new VafastError("\u4EE4\u724C\u9A8C\u8BC1\u5931\u8D25", {
          status: 401,
          type: "unauthorized",
          expose: true
        });
      }
      if (roles.length > 0 && user.role && !roles.includes(user.role)) {
        throw new VafastError("\u6743\u9650\u4E0D\u8DB3", {
          status: 403,
          type: "forbidden",
          expose: true
        });
      }
      if (permissions.length > 0 && user.permissions) {
        const userPermissions = Array.isArray(user.permissions) ? user.permissions : [user.permissions];
        const hasPermission = permissions.some(
          (permission) => userPermissions.includes(permission)
        );
        if (!hasPermission) {
          throw new VafastError("\u6743\u9650\u4E0D\u8DB3", {
            status: 403,
            type: "forbidden",
            expose: true
          });
        }
      }
      req.user = user;
      req.token = token;
      return next();
    } catch (error) {
      if (error instanceof TokenError) {
        let status = 401;
        let message = "\u8BA4\u8BC1\u5931\u8D25";
        switch (error.code) {
          case "EXPIRED_TOKEN":
            status = 401;
            message = "\u4EE4\u724C\u5DF2\u8FC7\u671F";
            break;
          case "INVALID_SIGNATURE":
            status = 401;
            message = "\u4EE4\u724C\u7B7E\u540D\u65E0\u6548";
            break;
          case "MALFORMED_TOKEN":
            status = 400;
            message = "\u4EE4\u724C\u683C\u5F0F\u9519\u8BEF";
            break;
          default:
            status = 401;
            message = "\u4EE4\u724C\u9A8C\u8BC1\u5931\u8D25";
        }
        throw new VafastError(message, {
          status,
          type: "unauthorized",
          expose: true
        });
      }
      if (error instanceof VafastError) {
        throw error;
      }
      throw new VafastError("\u8BA4\u8BC1\u8FC7\u7A0B\u4E2D\u53D1\u751F\u9519\u8BEF", {
        status: 500,
        type: "internal_error",
        expose: false
      });
    }
  };
}
function createOptionalAuth(options) {
  return createAuth({ ...options, required: false });
}
function createRoleAuth(roles, options) {
  return createAuth({ ...options, roles });
}
function createPermissionAuth(permissions, options) {
  return createAuth({ ...options, permissions });
}

// src/defineRoute.ts
function route(method, path, handler, middleware) {
  return {
    method,
    path,
    handler,
    middleware
  };
}
function get(path, handler, middleware) {
  return route("GET", path, handler, middleware);
}
function post(path, handler, middleware) {
  return route("POST", path, handler, middleware);
}
function put(path, handler, middleware) {
  return route("PUT", path, handler, middleware);
}
function del(path, handler, middleware) {
  return route("DELETE", path, handler, middleware);
}
function patch(path, handler, middleware) {
  return route("PATCH", path, handler, middleware);
}
function defineRoutes(routes) {
  return routes;
}

// src/types/route.ts
function createTypedRoute(config) {
  return config;
}
function isTypedRoute(route2) {
  return route2 && typeof route2 === "object" && "method" in route2 && "path" in route2 && "handler" in route2;
}

// src/node-server/serve.ts
import {
  createServer
} from "http";

// src/node-server/request.ts
import { Readable } from "stream";
var requestCache = /* @__PURE__ */ Symbol("requestCache");
var incomingKey = /* @__PURE__ */ Symbol("incoming");
var urlKey = /* @__PURE__ */ Symbol("url");
var headersKey = /* @__PURE__ */ Symbol("headers");
function parseHeaders2(rawHeaders) {
  const headers = new Headers();
  for (let i = 0; i < rawHeaders.length; i += 2) {
    const key = rawHeaders[i];
    const value = rawHeaders[i + 1];
    if (key.charCodeAt(0) !== 58) {
      headers.append(key, value);
    }
  }
  return headers;
}
function toWebStream(nodeStream) {
  return nodeStream;
}
function createRealRequest(proxy) {
  const incoming = proxy[incomingKey];
  const method = incoming.method || "GET";
  const init = {
    method,
    headers: proxy[headersKey] || parseHeaders2(incoming.rawHeaders)
  };
  if (method !== "GET" && method !== "HEAD") {
    const nodeWebStream = Readable.toWeb(
      incoming
    );
    init.body = toWebStream(nodeWebStream);
    init.duplex = "half";
  }
  return new Request(proxy[urlKey], init);
}
var requestPrototype = {};
Object.defineProperty(requestPrototype, "method", {
  get() {
    const self = this;
    return self[incomingKey].method || "GET";
  },
  enumerable: true
});
Object.defineProperty(requestPrototype, "url", {
  get() {
    const self = this;
    return self[urlKey];
  },
  enumerable: true
});
Object.defineProperty(requestPrototype, "headers", {
  get() {
    const self = this;
    if (!self[headersKey]) {
      self[headersKey] = parseHeaders2(self[incomingKey].rawHeaders);
    }
    return self[headersKey];
  },
  enumerable: true
});
Object.defineProperty(requestPrototype, "_getRequest", {
  value: function() {
    const self = this;
    if (!self[requestCache]) {
      self[requestCache] = createRealRequest(self);
    }
    return self[requestCache];
  },
  enumerable: false
});
var proxyGetters = [
  "body",
  "bodyUsed",
  "signal",
  "cache",
  "credentials",
  "destination",
  "integrity",
  "mode",
  "redirect",
  "referrer",
  "referrerPolicy",
  "keepalive"
];
proxyGetters.forEach((key) => {
  Object.defineProperty(requestPrototype, key, {
    get() {
      const self = this;
      return self._getRequest()[key];
    },
    enumerable: true
  });
});
var proxyMethods = [
  "arrayBuffer",
  "blob",
  "clone",
  "formData",
  "json",
  "text"
];
proxyMethods.forEach((key) => {
  Object.defineProperty(requestPrototype, key, {
    value: function() {
      const self = this;
      const req = self._getRequest();
      return req[key].call(req);
    },
    enumerable: true
  });
});
Object.setPrototypeOf(requestPrototype, Request.prototype);
function createProxyRequest(incoming, defaultHost) {
  const req = Object.create(requestPrototype);
  req[incomingKey] = incoming;
  const host = incoming.headers.host || defaultHost;
  const protocol = incoming.socket.encrypted ? "https" : "http";
  req[urlKey] = `${protocol}://${host}${incoming.url || "/"}`;
  return req;
}

// src/node-server/response.ts
function buildOutgoingHeaders(headers) {
  const result = {};
  const cookies = [];
  headers.forEach((value, key) => {
    if (key === "set-cookie") {
      cookies.push(value);
    } else {
      result[key] = value;
    }
  });
  if (cookies.length > 0) {
    result["set-cookie"] = cookies;
  }
  return result;
}
async function writeBodyStream(body, outgoing) {
  const reader = body.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      const canContinue = outgoing.write(value);
      if (!canContinue) {
        await new Promise((resolve) => {
          outgoing.once("drain", resolve);
        });
      }
    }
  } finally {
    reader.releaseLock();
  }
}
async function writeResponse(response, outgoing) {
  outgoing.statusCode = response.status;
  const headers = buildOutgoingHeaders(response.headers);
  for (const [key, value] of Object.entries(headers)) {
    outgoing.setHeader(key, value);
  }
  const body = response.body;
  if (!body) {
    outgoing.end();
    return;
  }
  try {
    await writeBodyStream(body, outgoing);
    outgoing.end();
  } catch (error) {
    if (!outgoing.destroyed) {
      outgoing.destroy(
        error instanceof Error ? error : new Error(String(error))
      );
    }
  }
}

// src/node-server/serve.ts
function createRequestHandler(fetch, defaultHost, onError) {
  return async (incoming, outgoing) => {
    try {
      const request = createProxyRequest(incoming, defaultHost);
      const response = await fetch(request);
      await writeResponse(response, outgoing);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      if (onError) {
        try {
          const errorResponse = await onError(err);
          await writeResponse(errorResponse, outgoing);
          return;
        } catch {
        }
      }
      if (!outgoing.headersSent) {
        outgoing.statusCode = 500;
        outgoing.setHeader("Content-Type", "text/plain");
        outgoing.end("Internal Server Error");
      }
    }
  };
}
function serve(options, callback) {
  const { fetch, port = 3e3, hostname = "0.0.0.0", onError, gracefulShutdown } = options;
  const defaultHost = `${hostname === "0.0.0.0" ? "localhost" : hostname}:${port}`;
  const handler = createRequestHandler(fetch, defaultHost, onError);
  const server = createServer(handler);
  const connections = /* @__PURE__ */ new Set();
  server.on("connection", (socket) => {
    connections.add(socket);
    socket.on("close", () => connections.delete(socket));
  });
  let isShuttingDown = false;
  const shutdown = async () => {
    if (isShuttingDown) return;
    isShuttingDown = true;
    const shutdownOptions = typeof gracefulShutdown === "object" ? gracefulShutdown : {};
    const timeout = shutdownOptions.timeout ?? 3e4;
    if (shutdownOptions.onShutdown) {
      await shutdownOptions.onShutdown();
    }
    return new Promise((resolve) => {
      const forceCloseTimer = setTimeout(() => {
        for (const socket of connections) {
          socket.destroy();
        }
        connections.clear();
        resolve();
      }, timeout);
      server.close(() => {
        clearTimeout(forceCloseTimer);
        shutdownOptions.onShutdownComplete?.();
        resolve();
      });
      for (const socket of connections) {
        if (!socket.writableLength) {
          socket.end();
        }
      }
    });
  };
  if (gracefulShutdown) {
    const shutdownOptions = typeof gracefulShutdown === "object" ? gracefulShutdown : {};
    const signals = shutdownOptions.signals ?? ["SIGINT", "SIGTERM"];
    for (const signal of signals) {
      process.on(signal, () => {
        shutdown().then(() => process.exit(0));
      });
    }
  }
  server.listen(port, hostname, callback);
  return {
    server,
    port,
    hostname,
    stop: () => new Promise((resolve, reject) => {
      server.close((err) => {
        if (err) reject(err);
        else resolve();
      });
    }),
    shutdown
  };
}

// src/index.ts
import { Type as Type2, FormatRegistry as FormatRegistry2 } from "@sinclair/typebox";
registerFormats();
export {
  BaseServer,
  ComponentServer,
  DependencyManager,
  FormatRegistry2 as FormatRegistry,
  HtmlRenderer,
  Patterns,
  RouteRegistry,
  Server,
  ServerFactory,
  TokenError,
  Type2 as Type,
  VafastError,
  base64urlDecode,
  base64urlEncode,
  composeMiddleware,
  createAuth,
  createCORS,
  createHandler,
  createHandlerWithExtra,
  createOptionalAuth,
  createPermissionAuth,
  createRequestValidator,
  createRoleAuth,
  createRouteRegistry,
  createSSEHandler,
  createTokenPair,
  createTypedRoute,
  createValidator,
  defineRoutes,
  del,
  empty,
  filterRoutes,
  flattenNestedRoutes,
  generateToken,
  get,
  getAllRoutes,
  getCookie,
  getHeader,
  getLocals,
  getRoute,
  getRouteRegistry,
  getTokenTimeRemaining,
  getValidatorCacheStats,
  goAwait,
  hasFormat,
  html,
  isTokenExpired,
  isTypedRoute,
  json,
  normalizePath,
  parseAndValidateRequest,
  parseBody,
  parseCookies,
  parseCookiesFast,
  parseHeaders,
  parseQuery,
  parseQueryFast,
  parseRequest,
  parseToken,
  patch,
  post,
  precompileSchemas,
  put,
  rateLimit,
  redirect,
  refreshToken,
  registerFormat,
  registerFormats,
  requireAuth,
  route,
  serve,
  setLocals,
  simpleHandler,
  stream,
  text,
  validateAllSchemas,
  validateFast,
  validateRequest,
  validateSchema,
  validateSchemaOrThrow,
  verifyToken
};
/**
 * Go 风格的错误处理工具
 * 将 Promise 转换为 [Error | null, T | undefined] 格式
 *
 * @author Framework Team
 * @version 1.0.0
 * @license MIT
 */
/**
 * 类型安全的路由处理器工厂
 *
 * 非柯里化设计，API 更简洁
 *
 * @author Framework Team
 * @version 3.0.0
 * @license MIT
 */
/**
 * 请求解析和验证器
 *
 * 解析handler的req参数，使用Ultra验证器进行验证，
 * 并类型安全地返回解析出来的值
 *
 * @author Framework Team
 * @version 1.0.0
 * @license MIT
 */
/**
 * Schema 类型定义
 *
 * 使用 TSchema 约束替代 any，提供完整的类型安全
 *
 * @author Framework Team
 * @version 1.0.0
 * @license MIT
 */
//# sourceMappingURL=index.js.map