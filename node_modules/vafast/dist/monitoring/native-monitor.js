var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/router.ts
function flattenNestedRoutes(routes) {
  const flattened = [];
  function processRoute(route, parentPath = "", parentMiddleware = []) {
    const currentPath = normalizePath(parentPath + route.path);
    const currentMiddleware = [
      ...parentMiddleware,
      ...route.middleware || []
    ];
    if ("method" in route && "handler" in route) {
      const leafRoute = route;
      flattened.push({
        ...leafRoute,
        fullPath: currentPath,
        middlewareChain: currentMiddleware
      });
    } else if ("children" in route && route.children) {
      for (const child of route.children) {
        processRoute(child, currentPath, currentMiddleware);
      }
    }
  }
  for (const route of routes) {
    processRoute(route);
  }
  return flattened;
}
function normalizePath(path) {
  let normalized = decodeURIComponent(path);
  normalized = normalized.replace(/\/+/g, "/");
  if (normalized === "") return "/";
  if (normalized !== "/" && normalized.endsWith("/")) {
    normalized = normalized.slice(0, -1);
  }
  return normalized;
}
var init_router = __esm({
  "src/router.ts"() {
    "use strict";
  }
});

// src/utils/response.ts
function json(data, status = 200, headers = {}) {
  const body = JSON.stringify(data);
  if (Object.keys(headers).length === 0) {
    return new Response(body, {
      status,
      headers: { "Content-Type": "application/json" }
    });
  }
  const h = new Headers({
    "Content-Type": "application/json",
    ...headers
  });
  return new Response(body, {
    status,
    headers: h
  });
}
function mapResponse(response) {
  if (response instanceof Response) return response;
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response, { headers: TEXT_HEADERS });
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: JSON_HEADERS });
    case "Number":
    case "Boolean":
      return new Response(String(response), { headers: TEXT_HEADERS });
    case void 0:
      return new Response(null, { status: 204 });
    case "ReadableStream":
      return new Response(response);
    case "Blob":
      return new Response(response);
    case "ArrayBuffer":
      return new Response(response);
    case "Uint8Array":
      return new Response(response);
    default:
      if (response instanceof Promise) {
        return response.then(mapResponse);
      }
      return new Response(JSON.stringify(response), { headers: JSON_HEADERS });
  }
}
var JSON_HEADERS, TEXT_HEADERS;
var init_response = __esm({
  "src/utils/response.ts"() {
    "use strict";
    JSON_HEADERS = { "Content-Type": "application/json" };
    TEXT_HEADERS = { "Content-Type": "text/plain" };
  }
});

// src/middleware.ts
function composeMiddleware(middleware, finalHandler) {
  const all = [errorHandler, ...middleware];
  return function composedHandler(req) {
    let i = -1;
    const dispatch = (index) => {
      if (index <= i)
        return Promise.reject(new Error("next() called multiple times"));
      i = index;
      if (index < all.length) {
        const mw = all[index];
        return Promise.resolve(mw(req, () => dispatch(index + 1)));
      }
      return Promise.resolve(finalHandler(req)).then(mapResponse);
    };
    return dispatch(0);
  };
}
var VafastError, errorHandler;
var init_middleware = __esm({
  "src/middleware.ts"() {
    "use strict";
    init_response();
    VafastError = class extends Error {
      status;
      type;
      expose;
      constructor(message, options = {}) {
        super(message);
        this.name = "VafastError";
        this.status = options.status ?? 500;
        this.type = options.type ?? "internal_error";
        this.expose = options.expose ?? false;
        if (options.cause) this.cause = options.cause;
      }
    };
    errorHandler = async (req, next) => {
      try {
        return await next();
      } catch (err) {
        console.error("\u672A\u5904\u7406\u7684\u9519\u8BEF:", err);
        if (err instanceof VafastError) {
          return json(
            {
              error: err.type,
              message: err.expose ? err.message : "\u53D1\u751F\u4E86\u4E00\u4E2A\u9519\u8BEF"
            },
            err.status
          );
        }
        return json({ error: "internal_error", message: "\u51FA\u73B0\u4E86\u4E00\u4E9B\u95EE\u9898" }, 500);
      }
    };
  }
});

// src/server/base-server.ts
var BaseServer;
var init_base_server = __esm({
  "src/server/base-server.ts"() {
    "use strict";
    BaseServer = class {
      globalMiddleware = [];
      use(mw) {
        this.globalMiddleware.push(mw);
      }
      /**
       * 打印扁平化后的路由信息，用于调试
       */
      logFlattenedRoutes(routes, type = "\u8DEF\u7531") {
        console.log(`\u{1F680} \u6241\u5E73\u5316\u540E\u7684${type}:`);
        for (const route of routes) {
          const method = route.method || "GET";
          const path = route.fullPath || route.path;
          console.log(`  ${method} ${path}`);
          if (route.middlewareChain && route.middlewareChain.length > 0) {
            console.log(`    \u4E2D\u95F4\u4EF6\u94FE: ${route.middlewareChain.length} \u4E2A`);
          }
        }
        console.log("");
      }
      /**
       * 检测路由冲突
       * 检查是否有路径相同但方法不同的路由，以及潜在的路径冲突
       */
      detectRouteConflicts(routes) {
        const pathGroups = /* @__PURE__ */ new Map();
        for (const route of routes) {
          const path = route.fullPath || route.path;
          const method = route.method || "GET";
          if (!pathGroups.has(path)) {
            pathGroups.set(path, []);
          }
          pathGroups.get(path).push({ ...route, method });
        }
        for (const [path, routeList] of pathGroups) {
          if (routeList.length > 1) {
            const methods = routeList.map((r) => r.method);
            const uniqueMethods = [...new Set(methods)];
            if (uniqueMethods.length === 1) {
              console.warn(
                `\u26A0\uFE0F  \u8DEF\u7531\u51B2\u7A81: ${uniqueMethods[0]} ${path} \u5B9A\u4E49\u4E86 ${routeList.length} \u6B21`
              );
              routeList.forEach((route, index) => {
                console.warn(`   ${index + 1}. ${route.method} ${path}`);
              });
            } else {
              console.log(`\u2139\uFE0F  \u8DEF\u5F84 ${path} \u652F\u6301\u65B9\u6CD5: ${uniqueMethods.join(", ")}`);
            }
          }
        }
        this.detectDynamicRouteConflicts(routes);
      }
      /**
       * 检测动态路由的潜在冲突
       */
      detectDynamicRouteConflicts(routes) {
        const dynamicRoutes = routes.filter((r) => {
          const path = r.fullPath || r.path;
          return path.includes(":") || path.includes("*");
        });
        for (let i = 0; i < dynamicRoutes.length; i++) {
          for (let j = i + 1; j < dynamicRoutes.length; j++) {
            const route1 = dynamicRoutes[i];
            const route2 = dynamicRoutes[j];
            const method1 = route1.method || "GET";
            const method2 = route2.method || "GET";
            if (method1 === method2) {
              const path1 = route1.fullPath || route1.path;
              const path2 = route2.fullPath || route2.path;
              if (this.pathsMayConflict(path1, path2)) {
                console.warn(
                  `\u26A0\uFE0F  \u6F5C\u5728\u8DEF\u7531\u51B2\u7A81: ${method1} ${path1} \u53EF\u80FD\u4E0E ${path2} \u51B2\u7A81`
                );
              }
            }
          }
        }
      }
      /**
       * 判断两个路径是否可能冲突
       */
      pathsMayConflict(path1, path2) {
        const parts1 = path1.split("/").filter(Boolean);
        const parts2 = path2.split("/").filter(Boolean);
        if (parts1.length !== parts2.length) return false;
        for (let i = 0; i < parts1.length; i++) {
          const p1 = parts1[i];
          const p2 = parts2[i];
          if (!p1.startsWith(":") && !p1.startsWith("*") && !p2.startsWith(":") && !p2.startsWith("*") && p1 !== p2) {
            return false;
          }
          if (p1 === "*" && p2.startsWith(":") || p2 === "*" && p1.startsWith(":")) {
            return true;
          }
        }
        return false;
      }
      /**
       * 路径匹配
       */
      matchPath(pattern, path) {
        const patternParts = pattern.split("/").filter(Boolean);
        const pathParts = path.split("/").filter(Boolean);
        if (patternParts.length !== pathParts.length) {
          return false;
        }
        for (let i = 0; i < patternParts.length; i++) {
          if (patternParts[i] !== pathParts[i] && !patternParts[i].startsWith(":")) {
            return false;
          }
        }
        return true;
      }
      /**
       * 提取路径参数
       */
      extractParams(pattern, path) {
        const params = {};
        const patternParts = pattern.split("/").filter(Boolean);
        const pathParts = path.split("/").filter(Boolean);
        for (let i = 0; i < patternParts.length; i++) {
          if (patternParts[i].startsWith(":")) {
            const paramName = patternParts[i].slice(1);
            params[paramName] = pathParts[i];
          }
        }
        return params;
      }
    };
  }
});

// src/router/radix-tree.ts
var RadixRouter;
var init_radix_tree = __esm({
  "src/router/radix-tree.ts"() {
    "use strict";
    RadixRouter = class {
      root;
      constructor() {
        this.root = this.createNode("");
      }
      createNode(path) {
        return {
          path,
          children: /* @__PURE__ */ Object.create(null),
          handlers: /* @__PURE__ */ Object.create(null)
        };
      }
      /** 分割路径 */
      splitPath(path) {
        return path.split("/").filter(Boolean);
      }
      /** 编译器函数 - 用于预编译中间件链 */
      compiler;
      /** 设置中间件编译器 */
      setCompiler(compiler) {
        this.compiler = compiler;
      }
      /** 注册路由 */
      register(method, pattern, handler, middleware = []) {
        const segments = this.splitPath(pattern);
        let node = this.root;
        for (const segment of segments) {
          const firstChar = segment[0];
          if (firstChar === ":") {
            if (!node.paramChild) {
              node.paramChild = this.createNode(segment);
              node.paramChild.paramName = segment.substring(1);
            }
            node = node.paramChild;
          } else if (firstChar === "*") {
            if (!node.wildcardChild) {
              node.wildcardChild = this.createNode(segment);
              node.wildcardChild.paramName = segment.length > 1 ? segment.substring(1) : "*";
            }
            node = node.wildcardChild;
            break;
          } else {
            if (!node.children[segment]) {
              node.children[segment] = this.createNode(segment);
            }
            node = node.children[segment];
          }
        }
        const routeHandler = { handler, middleware };
        if (this.compiler && middleware.length === 0) {
          routeHandler.compiled = this.compiler([], handler);
        }
        node.handlers[method] = routeHandler;
      }
      /** 预编译所有路由（在添加全局中间件后调用） */
      precompileAll(globalMiddleware) {
        if (!this.compiler) return;
        this.precompileNode(this.root, globalMiddleware);
      }
      precompileNode(node, globalMiddleware) {
        for (const method in node.handlers) {
          const routeHandler = node.handlers[method];
          if (routeHandler) {
            const allMiddleware = [...globalMiddleware, ...routeHandler.middleware];
            routeHandler.compiled = this.compiler(
              allMiddleware,
              routeHandler.handler
            );
          }
        }
        for (const key in node.children) {
          this.precompileNode(node.children[key], globalMiddleware);
        }
        if (node.paramChild) {
          this.precompileNode(node.paramChild, globalMiddleware);
        }
        if (node.wildcardChild) {
          this.precompileNode(node.wildcardChild, globalMiddleware);
        }
      }
      /** 匹配路由 */
      match(method, path) {
        const segments = this.splitPath(path);
        const params = /* @__PURE__ */ Object.create(null);
        const node = this.matchNode(this.root, segments, 0, params);
        if (!node) return null;
        const routeHandler = node.handlers[method];
        if (!routeHandler) return null;
        return {
          handler: routeHandler.handler,
          middleware: routeHandler.middleware,
          params,
          compiled: routeHandler.compiled
        };
      }
      /** 递归匹配节点 (优先级: 静态 > 动态参数 > 通配符) */
      matchNode(node, segments, index, params) {
        if (index === segments.length) {
          for (const method in node.handlers) {
            if (node.handlers[method]) return node;
          }
          return null;
        }
        const segment = segments[index];
        const staticChild = node.children[segment];
        if (staticChild) {
          const result = this.matchNode(staticChild, segments, index + 1, params);
          if (result) return result;
        }
        if (node.paramChild) {
          const paramName = node.paramChild.paramName;
          const oldValue = params[paramName];
          params[paramName] = segment;
          const result = this.matchNode(
            node.paramChild,
            segments,
            index + 1,
            params
          );
          if (result) return result;
          if (oldValue === void 0) {
            delete params[paramName];
          } else {
            params[paramName] = oldValue;
          }
        }
        if (node.wildcardChild) {
          params[node.wildcardChild.paramName || "*"] = segments.slice(index).join("/");
          return node.wildcardChild;
        }
        return null;
      }
      /** 获取路径允许的 HTTP 方法 */
      getAllowedMethods(path) {
        const segments = this.splitPath(path);
        const node = this.findNode(segments);
        if (!node) return [];
        const methods = [];
        for (const method in node.handlers) {
          if (node.handlers[method]) {
            methods.push(method);
          }
        }
        return methods;
      }
      /** 查找节点（不提取参数） */
      findNode(segments) {
        let node = this.root;
        for (const segment of segments) {
          if (node.children[segment]) {
            node = node.children[segment];
          } else if (node.paramChild) {
            node = node.paramChild;
          } else if (node.wildcardChild) {
            return node.wildcardChild;
          } else {
            return null;
          }
        }
        return node;
      }
      /** 获取所有已注册的路由 */
      getRoutes() {
        const routes = [];
        this.collectRoutes(this.root, "", routes);
        return routes;
      }
      collectRoutes(node, prefix, routes) {
        const currentPath = prefix + (node.path ? "/" + node.path : "");
        for (const method in node.handlers) {
          if (node.handlers[method]) {
            routes.push({ method, path: currentPath || "/" });
          }
        }
        for (const key in node.children) {
          this.collectRoutes(node.children[key], currentPath, routes);
        }
        if (node.paramChild) {
          this.collectRoutes(node.paramChild, currentPath, routes);
        }
        if (node.wildcardChild) {
          this.collectRoutes(node.wildcardChild, currentPath, routes);
        }
      }
    };
  }
});

// src/utils/route-registry.ts
function setGlobalRegistry(registry) {
  globalRegistry = registry;
}
var RouteRegistry, globalRegistry;
var init_route_registry = __esm({
  "src/utils/route-registry.ts"() {
    "use strict";
    RouteRegistry = class {
      /** 所有路由元信息 */
      routes = [];
      /** 路由映射表：METHOD:fullPath -> RouteMeta */
      routeMap = /* @__PURE__ */ new Map();
      /** 分类映射表：category -> RouteMeta[] */
      categoryMap = /* @__PURE__ */ new Map();
      constructor(routes) {
        this.buildRegistry(routes);
      }
      /**
       * 构建注册表
       */
      buildRegistry(routes) {
        for (const route of routes) {
          const meta = {
            method: route.method,
            path: route.path,
            fullPath: route.fullPath,
            name: route.name,
            description: route.description
          };
          for (const key of Object.keys(route)) {
            if (!["method", "path", "fullPath", "name", "description", "handler", "middleware", "middlewareChain"].includes(key)) {
              meta[key] = route[key];
            }
          }
          this.routes.push(meta);
          this.routeMap.set(`${route.method}:${route.fullPath}`, meta);
          const category = this.extractCategory(route.fullPath);
          if (!this.categoryMap.has(category)) {
            this.categoryMap.set(category, []);
          }
          this.categoryMap.get(category).push(meta);
        }
      }
      /**
       * 提取分类（第一段路径）
       */
      extractCategory(path) {
        const segments = path.split("/").filter(Boolean);
        return segments[0] || "root";
      }
      // ============================================
      // 查询接口
      // ============================================
      /**
       * 获取所有路由元信息
       */
      getAll() {
        return [...this.routes];
      }
      /**
       * 按 method + path 查询路由
       */
      get(method, path) {
        return this.routeMap.get(`${method}:${path}`);
      }
      /**
       * 检查路由是否存在
       */
      has(method, path) {
        return this.routeMap.has(`${method}:${path}`);
      }
      /**
       * 按分类获取路由
       */
      getByCategory(category) {
        return this.categoryMap.get(category) || [];
      }
      /**
       * 获取所有分类
       */
      getCategories() {
        return Array.from(this.categoryMap.keys()).sort();
      }
      /**
       * 筛选有特定字段的路由
       *
       * @example
       * ```typescript
       * // 获取所有配置了 webhook 的路由
       * const webhookRoutes = registry.filter('webhook')
       * ```
       */
      filter(field) {
        return this.routes.filter((r) => field in r && r[field] !== void 0);
      }
      /**
       * 按条件筛选路由
       *
       * @example
       * ```typescript
       * // 获取所有 POST 请求
       * const postRoutes = registry.filterBy(r => r.method === 'POST')
       * ```
       */
      filterBy(predicate) {
        return this.routes.filter(predicate);
      }
      /**
       * 获取路由数量
       */
      get size() {
        return this.routes.length;
      }
      /**
       * 遍历所有路由
       */
      forEach(callback) {
        this.routes.forEach(callback);
      }
      /**
       * 映射所有路由
       */
      map(callback) {
        return this.routes.map(callback);
      }
    };
    globalRegistry = null;
  }
});

// src/server/server.ts
var Server;
var init_server = __esm({
  "src/server/server.ts"() {
    "use strict";
    init_router();
    init_middleware();
    init_response();
    init_base_server();
    init_radix_tree();
    init_route_registry();
    Server = class extends BaseServer {
      router;
      routes;
      /** 是否已预编译 */
      isCompiled = false;
      /** 预编译时的全局中间件数量 */
      compiledWithMiddlewareCount = 0;
      constructor(routes = []) {
        super();
        this.router = new RadixRouter();
        this.routes = [];
        this.router.setCompiler(
          (middleware, handler) => composeMiddleware(middleware, handler)
        );
        if (routes.length > 0) {
          this.registerRoutes(routes);
        }
      }
      /**
       * 预编译所有路由处理链
       * 在添加所有路由和全局中间件后调用，可提升运行时性能
       */
      compile() {
        this.router.precompileAll(this.globalMiddleware);
        this.isCompiled = true;
        this.compiledWithMiddlewareCount = this.globalMiddleware.length;
        return this;
      }
      registerRoutes(routes) {
        const flattened = flattenNestedRoutes(routes);
        this.routes.push(...flattened);
        for (const route of flattened) {
          this.router.register(
            route.method,
            route.fullPath,
            route.handler,
            route.middlewareChain || []
          );
        }
        this.detectRouteConflicts(flattened);
        this.logFlattenedRoutes(flattened);
        if (this.globalMiddleware.length === 0 && !this.isCompiled) {
          this.compile();
        }
        setGlobalRegistry(new RouteRegistry(this.routes));
      }
      /** 快速提取 pathname */
      extractPathname(url) {
        let start = url.indexOf("://");
        start = start === -1 ? 0 : start + 3;
        const pathStart = url.indexOf("/", start);
        if (pathStart === -1) return "/";
        let end = url.indexOf("?", pathStart);
        if (end === -1) end = url.indexOf("#", pathStart);
        if (end === -1) end = url.length;
        return url.substring(pathStart, end) || "/";
      }
      /** 生成 404/405 响应 */
      createErrorResponse(method, pathname) {
        const allowedMethods = this.router.getAllowedMethods(pathname);
        if (allowedMethods.length > 0) {
          return json(
            {
              success: false,
              error: "Method Not Allowed",
              message: `Method ${method} not allowed for this endpoint`,
              allowedMethods
            },
            405,
            { Allow: allowedMethods.join(", ") }
          );
        }
        return json({ success: false, error: "Not Found" }, 404);
      }
      /** 处理请求 */
      fetch = async (req) => {
        const pathname = this.extractPathname(req.url);
        const method = req.method;
        const match = this.router.match(method, pathname);
        if (match) {
          req.params = match.params;
          if (match.compiled && this.globalMiddleware.length === this.compiledWithMiddlewareCount) {
            return match.compiled(req);
          }
          const allMiddleware = [...this.globalMiddleware, ...match.middleware];
          const handler = composeMiddleware(allMiddleware, match.handler);
          return handler(req);
        }
        if (method === "OPTIONS") {
          const allowedMethods = this.router.getAllowedMethods(pathname);
          if (allowedMethods.length > 0) {
            const anyMatch = this.router.match(
              allowedMethods[0],
              pathname
            );
            const routeMiddleware = anyMatch?.middleware || [];
            const allMiddleware = [...this.globalMiddleware, ...routeMiddleware];
            const optionsHandler = () => new Response(null, {
              status: 204,
              headers: { Allow: allowedMethods.join(", ") }
            });
            const handler = composeMiddleware(allMiddleware, optionsHandler);
            return handler(req);
          }
        }
        if (this.globalMiddleware.length > 0) {
          const handler = composeMiddleware(
            this.globalMiddleware,
            () => this.createErrorResponse(method, pathname)
          );
          return handler(req);
        }
        return this.createErrorResponse(method, pathname);
      };
      addRoute(route) {
        const flattenedRoute = {
          ...route,
          fullPath: route.path,
          middlewareChain: route.middleware || []
        };
        this.routes.push(flattenedRoute);
        this.router.register(
          route.method,
          route.path,
          route.handler,
          route.middleware || []
        );
      }
      addRoutes(routes) {
        this.registerRoutes(routes);
      }
      getRoutes() {
        return this.router.getRoutes();
      }
      /**
       * 获取完整的路由元信息（不含 handler 和 middleware）
       *
       * 用于 API 文档生成、Webhook 事件注册、权限检查等场景
       *
       * @example
       * ```typescript
       * const routes = server.getRoutesWithMeta()
       * for (const route of routes) {
       *   console.log(route.fullPath, route.name, route.description)
       * }
       * ```
       */
      getRoutesWithMeta() {
        return this.routes;
      }
    };
  }
});

// src/middleware/component-router.ts
function flattenComponentRoutes(routes) {
  const flattened = [];
  function processRoute(route, parentPath = "", parentMiddleware = []) {
    const currentPath = parentPath + route.path;
    const currentMiddleware = [
      ...parentMiddleware,
      ...route.middleware || []
    ];
    if ("component" in route) {
      flattened.push({
        ...route,
        fullPath: currentPath,
        middlewareChain: currentMiddleware
      });
    } else if ("children" in route && route.children) {
      for (const child of route.children) {
        processRoute(child, currentPath, currentMiddleware);
      }
    }
  }
  for (const route of routes) {
    processRoute(route);
  }
  return flattened;
}
var init_component_router = __esm({
  "src/middleware/component-router.ts"() {
    "use strict";
  }
});

// src/utils/path-matcher.ts
var PathMatcher;
var init_path_matcher = __esm({
  "src/utils/path-matcher.ts"() {
    "use strict";
    PathMatcher = class {
      /**
       * 路径匹配
       */
      static matchPath(pattern, path) {
        const patternParts = pattern.split("/").filter(Boolean);
        const pathParts = path.split("/").filter(Boolean);
        if (patternParts.length !== pathParts.length) {
          return false;
        }
        for (let i = 0; i < patternParts.length; i++) {
          if (patternParts[i] !== pathParts[i] && !patternParts[i].startsWith(":")) {
            return false;
          }
        }
        return true;
      }
      /**
       * 提取路径参数
       */
      static extractParams(pattern, path) {
        const params = {};
        const patternParts = pattern.split("/").filter(Boolean);
        const pathParts = path.split("/").filter(Boolean);
        for (let i = 0; i < patternParts.length; i++) {
          if (patternParts[i].startsWith(":")) {
            const paramName = patternParts[i].slice(1);
            params[paramName] = pathParts[i];
          }
        }
        return params;
      }
      /**
       * 计算路径特异性分数
       * 用于路由排序：静态 > 动态(:param) > 通配符(*)
       */
      static calculatePathScore(path) {
        const parts = path.split("/").filter(Boolean);
        let score = 0;
        for (const p of parts) {
          if (p === "*")
            score += 1;
          else if (p.startsWith(":"))
            score += 2;
          else score += 3;
        }
        return score * 10 + parts.length;
      }
      /**
       * 判断两个路径是否可能冲突
       */
      static pathsMayConflict(path1, path2) {
        const parts1 = path1.split("/").filter(Boolean);
        const parts2 = path2.split("/").filter(Boolean);
        if (parts1.length !== parts2.length) return false;
        for (let i = 0; i < parts1.length; i++) {
          const p1 = parts1[i];
          const p2 = parts2[i];
          if (!p1.startsWith(":") && !p1.startsWith("*") && !p2.startsWith(":") && !p2.startsWith("*") && p1 !== p2) {
            return false;
          }
          if (p1 === "*" && p2.startsWith(":") || p2 === "*" && p1.startsWith(":")) {
            return true;
          }
        }
        return false;
      }
    };
  }
});

// src/utils/html-renderer.ts
var HtmlRenderer;
var init_html_renderer = __esm({
  "src/utils/html-renderer.ts"() {
    "use strict";
    HtmlRenderer = class {
      /**
       * 生成基础HTML模板
       */
      static generateBaseHtml(content, context, clientScriptPath = "/client.js") {
        return `
      <!doctype html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>Vafast SSR App</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
        </head>
        <body>
          <div id="app">${content}</div>
          <script>
            window.__ROUTE_INFO__ = {
              params: ${JSON.stringify(context.params || {})},
              query: ${JSON.stringify(context.query || {})},
              pathname: '${context.pathname}'
            };
          </script>
          <script type="module" src="${clientScriptPath}"></script>
        </body>
      </html>
    `;
      }
      /**
       * 生成Vue组件HTML
       */
      static generateVueHtml(content, context, clientScriptPath = "/client.js") {
        return this.generateBaseHtml(content, context, clientScriptPath);
      }
      /**
       * 生成React组件HTML
       */
      static generateReactHtml(content, context, clientScriptPath = "/client.js") {
        return `
      <!doctype html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>Vafast SSR App</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
        </head>
        <body>
          <div id="root">${content}</div>
          <script>
            window.__ROUTE_INFO__ = {
              params: ${JSON.stringify(context.params || {})},
              query: ${JSON.stringify(context.query || {})},
              pathname: '${context.pathname}'
            };
          </script>
          <script type="module" src="${clientScriptPath}"></script>
        </body>
      </html>
    `;
      }
    };
  }
});

// src/utils/dependency-manager.ts
var DependencyManager;
var init_dependency_manager = __esm({
  "src/utils/dependency-manager.ts"() {
    "use strict";
    DependencyManager = class {
      dependencyCache = /* @__PURE__ */ new Map();
      /**
       * 按需获取框架依赖
       */
      async getFrameworkDeps(framework) {
        if (this.dependencyCache.has(framework)) {
          return this.dependencyCache.get(framework);
        }
        console.log(`\u{1F4E6} \u6309\u9700\u52A0\u8F7D ${framework} \u4F9D\u8D56...`);
        try {
          let deps;
          switch (framework) {
            case "vue":
              deps = await Promise.all([
                import("vue"),
                import("@vue/server-renderer")
              ]);
              break;
            case "react":
              deps = await Promise.all([
                import("react"),
                import("react-dom/server")
              ]);
              break;
            default:
              throw new Error(`\u4E0D\u652F\u6301\u7684\u6846\u67B6: ${framework}`);
          }
          this.dependencyCache.set(framework, deps);
          console.log(`\u2705 ${framework} \u4F9D\u8D56\u52A0\u8F7D\u5B8C\u6210`);
          return deps;
        } catch (error) {
          console.error(`\u274C ${framework} \u4F9D\u8D56\u52A0\u8F7D\u5931\u8D25:`, error);
          throw error;
        }
      }
      /**
       * 检测组件类型
       */
      detectComponentType(component) {
        if (component.render && typeof component.render === "function") {
          return "vue";
        }
        if (component.$$typeof) {
          return "react";
        }
        return "vue";
      }
      /**
       * 清除缓存
       */
      clearCache() {
        this.dependencyCache.clear();
        console.log("\u{1F9F9} \u4F9D\u8D56\u7F13\u5B58\u5DF2\u6E05\u9664");
      }
      /**
       * 获取缓存状态
       */
      getCacheStatus() {
        const status = {};
        for (const [framework] of this.dependencyCache) {
          status[framework] = true;
        }
        return status;
      }
    };
  }
});

// src/server/component-server.ts
var ComponentServer;
var init_component_server = __esm({
  "src/server/component-server.ts"() {
    "use strict";
    init_component_router();
    init_base_server();
    init_path_matcher();
    init_html_renderer();
    init_dependency_manager();
    ComponentServer = class extends BaseServer {
      routes;
      dependencyManager;
      constructor(routes) {
        super();
        this.routes = flattenComponentRoutes(routes);
        this.dependencyManager = new DependencyManager();
        this.detectRouteConflicts(this.routes);
        this.logFlattenedRoutes(this.routes, "\u7EC4\u4EF6\u8DEF\u7531");
        console.log("\u{1F680} \u4F9D\u8D56\u6309\u9700\u52A0\u8F7D\uFF0C\u670D\u52A1\u5668\u542F\u52A8\u5B8C\u6210");
      }
      /**
       * 处理请求
       */
      async fetch(req) {
        const url = new URL(req.url);
        const pathname = url.pathname;
        const method = req.method;
        if (method !== "GET") {
          return new Response("Method Not Allowed", { status: 405 });
        }
        let matchedRoute = null;
        for (const route of this.routes) {
          if (PathMatcher.matchPath(route.fullPath, pathname)) {
            matchedRoute = route;
            break;
          }
        }
        if (!matchedRoute) {
          return new Response("Not Found", { status: 404 });
        }
        try {
          const context = {
            req,
            params: PathMatcher.extractParams(matchedRoute.fullPath, pathname),
            query: Object.fromEntries(url.searchParams),
            pathname
          };
          return await this.executeMiddlewareChain(
            matchedRoute.middlewareChain,
            context,
            matchedRoute.component
          );
        } catch (error) {
          console.error("\u7EC4\u4EF6\u6E32\u67D3\u5931\u8D25:", error);
          return new Response("Internal Server Error", { status: 500 });
        }
      }
      /**
       * 执行中间件链
       */
      async executeMiddlewareChain(middlewareChain, context, componentImport) {
        const renderComponent = async () => {
          const componentModule = await componentImport();
          const component = componentModule.default || componentModule;
          const componentType = this.dependencyManager.detectComponentType(component);
          const deps = await this.dependencyManager.getFrameworkDeps(componentType);
          if (componentType === "vue") {
            return await this.renderVueComponent(component, context, deps);
          } else if (componentType === "react") {
            return await this.renderReactComponent(component, context, deps);
          } else {
            throw new Error(`\u4E0D\u652F\u6301\u7684\u7EC4\u4EF6\u7C7B\u578B: ${componentType}`);
          }
        };
        let index = 0;
        const next = async () => {
          if (index >= middlewareChain.length) {
            return await renderComponent();
          }
          const middleware = middlewareChain[index++];
          return await middleware(context.req, next);
        };
        return await next();
      }
      /**
       * 渲染 Vue 组件
       */
      async renderVueComponent(component, context, deps) {
        try {
          const [vue, renderer] = deps;
          const app = vue.createSSRApp(component);
          app.provide("routeInfo", {
            params: context.params || {},
            query: context.query || {},
            pathname: context.pathname
          });
          const html = await renderer.renderToString(app);
          const fullHtml = HtmlRenderer.generateVueHtml(html, context);
          return new Response(fullHtml, {
            headers: { "Content-Type": "text/html; charset=utf-8" }
          });
        } catch (error) {
          console.error("Vue \u7EC4\u4EF6\u6E32\u67D3\u5931\u8D25:", error);
          return new Response("Vue Component Render Error", { status: 500 });
        }
      }
      /**
       * 渲染 React 组件
       */
      async renderReactComponent(component, context, deps) {
        try {
          const [react, renderer] = deps;
          const content = react.createElement(component, {
            req: context.req,
            params: context.params || {},
            query: context.query || {}
          });
          const html = renderer.renderToString(content);
          const fullHtml = HtmlRenderer.generateReactHtml(html, context);
          return new Response(fullHtml, {
            headers: { "Content-Type": "text/html; charset=utf-8" }
          });
        } catch (error) {
          console.error("React \u7EC4\u4EF6\u6E32\u67D3\u5931\u8D25:", error);
          return new Response("React Component Render Error", { status: 500 });
        }
      }
      /**
       * 获取依赖管理器（用于外部访问）
       */
      getDependencyManager() {
        return this.dependencyManager;
      }
    };
  }
});

// src/server/server-factory.ts
var ServerFactory;
var init_server_factory = __esm({
  "src/server/server-factory.ts"() {
    "use strict";
    init_server2();
    init_component_server();
    ServerFactory = class {
      servers = /* @__PURE__ */ new Map();
      /**
       * 创建标准REST API服务器
       */
      createRestServer(routes) {
        const server = new Server(routes);
        this.servers.set("rest", server);
        return server;
      }
      /**
       * 创建组件服务器
       */
      createComponentServer(routes) {
        const server = new ComponentServer(routes);
        this.servers.set("component", server);
        return server;
      }
      /**
       * 获取指定类型的服务器
       */
      getServer(type) {
        return this.servers.get(type);
      }
      /**
       * 获取所有服务器
       */
      getAllServers() {
        return this.servers;
      }
      /**
       * 移除指定类型的服务器
       */
      removeServer(type) {
        return this.servers.delete(type);
      }
      /**
       * 清除所有服务器
       */
      clearServers() {
        this.servers.clear();
      }
      /**
       * 获取服务器状态信息
       */
      getServerStatus() {
        const status = {};
        for (const [name, server] of this.servers) {
          if (server instanceof Server) {
            status[name] = {
              type: "REST API",
              routes: server.routes?.length || 0
            };
          } else if (server instanceof ComponentServer) {
            status[name] = {
              type: "Component",
              routes: server.routes?.length || 0
            };
          }
        }
        return status;
      }
    };
  }
});

// src/server/index.ts
var server_exports = {};
__export(server_exports, {
  BaseServer: () => BaseServer,
  ComponentServer: () => ComponentServer,
  Server: () => Server,
  ServerFactory: () => ServerFactory
});
var init_server2 = __esm({
  "src/server/index.ts"() {
    "use strict";
    init_server();
    init_component_server();
    init_server_factory();
    init_base_server();
  }
});

// src/monitoring/native-monitor.ts
var NativeMonitor = class {
  config;
  metrics = [];
  isEnabled = false;
  constructor(config = {}) {
    this.config = {
      enabled: true,
      console: true,
      slowThreshold: 1e3,
      errorThreshold: 0.05,
      tags: { framework: "vafast" },
      ...config
    };
    this.isEnabled = this.config.enabled ?? true;
    if (this.isEnabled && this.config.console) {
      console.log("\u2705 \u539F\u751F\u76D1\u63A7\u5DF2\u542F\u7528");
      console.log(`\u{1F4CA} \u76D1\u63A7\u914D\u7F6E:`, {
        \u6162\u8BF7\u6C42\u9608\u503C: `${this.config.slowThreshold}ms`,
        \u9519\u8BEF\u7387\u9608\u503C: `${(this.config.errorThreshold * 100).toFixed(1)}%`,
        \u6807\u7B7E: this.config.tags
      });
    }
  }
  // 记录监控指标
  recordMetrics(metrics) {
    if (!this.isEnabled) return;
    this.metrics.push(metrics);
    if (this.metrics.length > 1e3) {
      this.metrics = this.metrics.slice(-1e3);
    }
    if (this.config.console) {
      const status = metrics.statusCode < 400 ? "\u2705" : "\u274C";
      const timeColor = metrics.totalTime > this.config.slowThreshold ? "\u{1F40C}" : "\u26A1";
      console.log(
        `${status} ${metrics.method} ${metrics.path} - ${metrics.statusCode} (${timeColor} ${metrics.totalTime.toFixed(2)}ms)`
      );
      if (metrics.totalTime > this.config.slowThreshold) {
        console.warn(
          `\u{1F40C} \u6162\u8BF7\u6C42\u8B66\u544A: ${metrics.path} \u8017\u65F6 ${metrics.totalTime.toFixed(
            2
          )}ms`
        );
      }
    }
  }
  // 获取监控状态
  getStatus() {
    if (!this.isEnabled) {
      return { enabled: false, message: "\u76D1\u63A7\u672A\u542F\u7528" };
    }
    const totalRequests = this.metrics.length;
    const successfulRequests = this.metrics.filter(
      (m) => m.statusCode < 400
    ).length;
    const failedRequests = totalRequests - successfulRequests;
    const avgResponseTime = totalRequests > 0 ? this.metrics.reduce((sum, m) => sum + m.totalTime, 0) / totalRequests : 0;
    return {
      enabled: true,
      totalRequests,
      successfulRequests,
      failedRequests,
      errorRate: totalRequests > 0 ? failedRequests / totalRequests : 0,
      avgResponseTime: avgResponseTime.toFixed(2) + "ms",
      memoryUsage: this.getMemoryUsage(),
      recentRequests: this.metrics.slice(-5)
    };
  }
  // 获取监控指标
  getMetrics() {
    return this.metrics;
  }
  // 重置监控数据
  reset() {
    this.metrics = [];
    console.log("\u{1F504} \u76D1\u63A7\u6570\u636E\u5DF2\u91CD\u7F6E");
  }
  // 获取内存使用情况
  getMemoryUsage() {
    if (typeof process !== "undefined" && process.memoryUsage) {
      const mem = process.memoryUsage();
      return {
        heapUsed: (mem.heapUsed / 1024 / 1024).toFixed(2) + "MB",
        heapTotal: (mem.heapTotal / 1024 / 1024).toFixed(2) + "MB",
        external: (mem.external / 1024 / 1024).toFixed(2) + "MB"
      };
    }
    return { message: "\u5185\u5B58\u4FE1\u606F\u4E0D\u53EF\u7528" };
  }
};
function withMonitoring(server, config = {}) {
  const monitor = new NativeMonitor(config);
  const originalFetch = server.fetch.bind(server);
  const monitoredFetch = async (req) => {
    const startTime = performance.now();
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const { pathname } = new URL(req.url);
    const method = req.method;
    try {
      const response = await originalFetch(req);
      const totalTime = performance.now() - startTime;
      monitor.recordMetrics({
        requestId,
        method,
        path: pathname,
        statusCode: response.status,
        totalTime,
        timestamp: Date.now(),
        memoryUsage: (() => {
          if (typeof process !== "undefined" && process.memoryUsage) {
            const mem = process.memoryUsage();
            return {
              heapUsed: mem.heapUsed,
              heapTotal: mem.heapTotal
            };
          }
          return { heapUsed: 0, heapTotal: 0 };
        })()
      });
      return response;
    } catch (error) {
      const totalTime = performance.now() - startTime;
      monitor.recordMetrics({
        requestId,
        method,
        path: pathname,
        statusCode: 500,
        totalTime,
        timestamp: Date.now(),
        memoryUsage: (() => {
          if (typeof process !== "undefined" && process.memoryUsage) {
            const mem = process.memoryUsage();
            return {
              heapUsed: mem.heapUsed,
              heapTotal: mem.heapTotal
            };
          }
          return { heapUsed: 0, heapTotal: 0 };
        })()
      });
      throw error;
    }
  };
  const monitoredServer = {
    ...server,
    fetch: monitoredFetch,
    // 监控方法
    getMonitoringStatus: () => monitor.getStatus(),
    getMonitoringMetrics: () => monitor.getMetrics(),
    resetMonitoring: () => monitor.reset()
  };
  return monitoredServer;
}
function createMonitoredServer(routes, config) {
  const { Server: Server2 } = (init_server2(), __toCommonJS(server_exports));
  const server = new Server2(routes);
  return withMonitoring(server, config);
}
export {
  createMonitoredServer,
  withMonitoring
};
/**
 * 原生监控装饰器
 *
 * 通过装饰器模式为 Server 添加监控能力，完全不入侵原类
 *
 * @author Framework Team
 * @version 2.0.0
 * @license MIT
 */
//# sourceMappingURL=native-monitor.js.map