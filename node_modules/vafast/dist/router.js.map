{"version":3,"sources":["../src/router.ts"],"sourcesContent":["/**\n * 路由工具函数\n *\n * 提供路由处理的基础工具\n */\n\nimport type { Route, NestedRoute, FlattenedRoute, Middleware } from \"./types\";\n\n/**\n * 扁平化嵌套路由\n *\n * 将嵌套路由结构转换为扁平数组，计算完整路径和中间件链\n *\n * @example\n * ```typescript\n * const routes = flattenNestedRoutes([\n *   {\n *     path: \"/api\",\n *     middleware: [authMiddleware],\n *     children: [\n *       { path: \"/users\", method: \"GET\", handler: getUsers },\n *       { path: \"/users/:id\", method: \"GET\", handler: getUser },\n *     ],\n *   },\n * ]);\n * // 结果:\n * // [\n * //   { fullPath: \"/api/users\", method: \"GET\", ... },\n * //   { fullPath: \"/api/users/:id\", method: \"GET\", ... },\n * // ]\n * ```\n */\nexport function flattenNestedRoutes(\n  routes: (Route | NestedRoute)[],\n): FlattenedRoute[] {\n  const flattened: FlattenedRoute[] = [];\n\n  function processRoute(\n    route: Route | NestedRoute,\n    parentPath = \"\",\n    parentMiddleware: Middleware[] = [],\n  ): void {\n    // 计算当前完整路径\n    const currentPath = normalizePath(parentPath + route.path);\n    // 合并中间件链\n    const currentMiddleware = [\n      ...parentMiddleware,\n      ...(route.middleware || []),\n    ];\n\n    if (\"method\" in route && \"handler\" in route) {\n      // 叶子路由（有处理函数）\n      const leafRoute = route as Route;\n      flattened.push({\n        ...leafRoute,\n        fullPath: currentPath,\n        middlewareChain: currentMiddleware,\n      });\n    } else if (\"children\" in route && route.children) {\n      // 分组路由，递归处理子路由\n      for (const child of route.children) {\n        processRoute(child, currentPath, currentMiddleware);\n      }\n    }\n  }\n\n  for (const route of routes) {\n    processRoute(route);\n  }\n\n  return flattened;\n}\n\n/**\n * 标准化路径\n *\n * - 解码 URL 编码字符\n * - 去除重复斜杠\n * - 处理结尾斜杠\n *\n * @example\n * ```typescript\n * normalizePath(\"//api//users/\")  // \"/api/users\"\n * normalizePath(\"/api/%20test\")   // \"/api/ test\"\n * ```\n */\nexport function normalizePath(path: string): string {\n  // 解码 URL 编码\n  let normalized = decodeURIComponent(path);\n\n  // 去除重复斜杠\n  normalized = normalized.replace(/\\/+/g, \"/\");\n\n  // 空路径转为根路径\n  if (normalized === \"\") return \"/\";\n\n  // 去除结尾斜杠（根路径除外）\n  if (normalized !== \"/\" && normalized.endsWith(\"/\")) {\n    normalized = normalized.slice(0, -1);\n  }\n\n  return normalized;\n}\n"],"mappings":";AAgCO,SAAS,oBACd,QACkB;AAClB,QAAM,YAA8B,CAAC;AAErC,WAAS,aACP,OACA,aAAa,IACb,mBAAiC,CAAC,GAC5B;AAEN,UAAM,cAAc,cAAc,aAAa,MAAM,IAAI;AAEzD,UAAM,oBAAoB;AAAA,MACxB,GAAG;AAAA,MACH,GAAI,MAAM,cAAc,CAAC;AAAA,IAC3B;AAEA,QAAI,YAAY,SAAS,aAAa,OAAO;AAE3C,YAAM,YAAY;AAClB,gBAAU,KAAK;AAAA,QACb,GAAG;AAAA,QACH,UAAU;AAAA,QACV,iBAAiB;AAAA,MACnB,CAAC;AAAA,IACH,WAAW,cAAc,SAAS,MAAM,UAAU;AAEhD,iBAAW,SAAS,MAAM,UAAU;AAClC,qBAAa,OAAO,aAAa,iBAAiB;AAAA,MACpD;AAAA,IACF;AAAA,EACF;AAEA,aAAW,SAAS,QAAQ;AAC1B,iBAAa,KAAK;AAAA,EACpB;AAEA,SAAO;AACT;AAeO,SAAS,cAAc,MAAsB;AAElD,MAAI,aAAa,mBAAmB,IAAI;AAGxC,eAAa,WAAW,QAAQ,QAAQ,GAAG;AAG3C,MAAI,eAAe,GAAI,QAAO;AAG9B,MAAI,eAAe,OAAO,WAAW,SAAS,GAAG,GAAG;AAClD,iBAAa,WAAW,MAAM,GAAG,EAAE;AAAA,EACrC;AAEA,SAAO;AACT;","names":[]}