// src/utils/response.ts
function json(data, status = 200, headers = {}) {
  const body = JSON.stringify(data);
  if (Object.keys(headers).length === 0) {
    return new Response(body, {
      status,
      headers: { "Content-Type": "application/json" }
    });
  }
  const h = new Headers({
    "Content-Type": "application/json",
    ...headers
  });
  return new Response(body, {
    status,
    headers: h
  });
}
var JSON_HEADERS = { "Content-Type": "application/json" };
var TEXT_HEADERS = { "Content-Type": "text/plain" };
function mapResponse(response) {
  if (response instanceof Response) return response;
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response, { headers: TEXT_HEADERS });
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: JSON_HEADERS });
    case "Number":
    case "Boolean":
      return new Response(String(response), { headers: TEXT_HEADERS });
    case void 0:
      return new Response(null, { status: 204 });
    case "ReadableStream":
      return new Response(response);
    case "Blob":
      return new Response(response);
    case "ArrayBuffer":
      return new Response(response);
    case "Uint8Array":
      return new Response(response);
    default:
      if (response instanceof Promise) {
        return response.then(mapResponse);
      }
      return new Response(JSON.stringify(response), { headers: JSON_HEADERS });
  }
}

// src/middleware.ts
var VafastError = class extends Error {
  status;
  type;
  expose;
  constructor(message, options = {}) {
    super(message);
    this.name = "VafastError";
    this.status = options.status ?? 500;
    this.type = options.type ?? "internal_error";
    this.expose = options.expose ?? false;
    if (options.cause) this.cause = options.cause;
  }
};
function composeMiddleware(middleware, finalHandler) {
  const all = [errorHandler, ...middleware];
  return function composedHandler(req) {
    let i = -1;
    const dispatch = (index) => {
      if (index <= i)
        return Promise.reject(new Error("next() called multiple times"));
      i = index;
      if (index < all.length) {
        const mw = all[index];
        return Promise.resolve(mw(req, () => dispatch(index + 1)));
      }
      return Promise.resolve(finalHandler(req)).then(mapResponse);
    };
    return dispatch(0);
  };
}
var errorHandler = async (req, next) => {
  try {
    return await next();
  } catch (err) {
    console.error("\u672A\u5904\u7406\u7684\u9519\u8BEF:", err);
    if (err instanceof VafastError) {
      return json(
        {
          error: err.type,
          message: err.expose ? err.message : "\u53D1\u751F\u4E86\u4E00\u4E2A\u9519\u8BEF"
        },
        err.status
      );
    }
    return json({ error: "internal_error", message: "\u51FA\u73B0\u4E86\u4E00\u4E9B\u95EE\u9898" }, 500);
  }
};
export {
  VafastError,
  composeMiddleware
};
//# sourceMappingURL=middleware.js.map