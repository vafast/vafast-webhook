// src/middleware.ts
var VafastError = class extends Error {
  status;
  type;
  expose;
  constructor(message, options = {}) {
    super(message);
    this.name = "VafastError";
    this.status = options.status ?? 500;
    this.type = options.type ?? "internal_error";
    this.expose = options.expose ?? false;
    if (options.cause) this.cause = options.cause;
  }
};

// src/utils/parsers.ts
import qs from "qs";
import cookie from "cookie";
function parseCookies(req) {
  const cookieHeader = req.headers.get("cookie");
  if (!cookieHeader) return {};
  try {
    const parsed = cookie.parse(cookieHeader);
    const result = {};
    for (const [key, value] of Object.entries(parsed)) {
      if (value !== void 0 && value !== null) {
        result[key] = value;
      }
    }
    return result;
  } catch {
    return {};
  }
}

// src/utils/handle.ts
function getCookie(req, key) {
  const cookies = parseCookies(req);
  return cookies[key] || null;
}

// src/utils/base64url.ts
function base64urlEncode(str) {
  return btoa(str).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64urlDecode(str) {
  const pad = str.length % 4 === 0 ? "" : "=".repeat(4 - str.length % 4);
  const base64 = str.replace(/-/g, "+").replace(/_/g, "/") + pad;
  return atob(base64);
}

// src/auth/token.ts
var TokenError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = "TokenError";
  }
};
var encoder = new TextEncoder();
async function sign(data, secret) {
  const key = await crypto.subtle.importKey(
    "raw",
    encoder.encode(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const signature = await crypto.subtle.sign("HMAC", key, encoder.encode(data));
  return btoa(
    String.fromCharCode.apply(null, Array.from(new Uint8Array(signature)))
  );
}
async function verifyToken(token, secret) {
  try {
    const [data, sig] = token.split(".");
    if (!data || !sig) {
      throw new TokenError("\u4EE4\u724C\u683C\u5F0F\u65E0\u6548", "MALFORMED_TOKEN");
    }
    const expectedSig = await sign(data, secret);
    const expected = base64urlEncode(expectedSig);
    if (sig !== expected) {
      throw new TokenError("\u4EE4\u724C\u7B7E\u540D\u65E0\u6548", "INVALID_SIGNATURE");
    }
    const payload = JSON.parse(base64urlDecode(data));
    if (payload.exp && Date.now() / 1e3 > payload.exp) {
      throw new TokenError("\u4EE4\u724C\u5DF2\u8FC7\u671F", "EXPIRED_TOKEN");
    }
    return payload;
  } catch (error) {
    if (error instanceof TokenError) {
      throw error;
    }
    throw new TokenError("\u4EE4\u724C\u9A8C\u8BC1\u5931\u8D25", "INVALID_TOKEN");
  }
}

// src/middleware/auth.ts
function createAuth(options) {
  const {
    secret,
    cookieName = "auth",
    headerName = "authorization",
    required = true,
    roles = [],
    permissions = []
  } = options;
  return async (req, next) => {
    const token = getCookie(req, cookieName) || req.headers.get(headerName)?.replace("Bearer ", "") || "";
    if (!token && required) {
      throw new VafastError("\u7F3A\u5C11\u8BA4\u8BC1\u4EE4\u724C", {
        status: 401,
        type: "unauthorized",
        expose: true
      });
    }
    if (!token && !required) {
      return next();
    }
    try {
      const user = await verifyToken(token, secret);
      if (!user) {
        throw new VafastError("\u4EE4\u724C\u9A8C\u8BC1\u5931\u8D25", {
          status: 401,
          type: "unauthorized",
          expose: true
        });
      }
      if (roles.length > 0 && user.role && !roles.includes(user.role)) {
        throw new VafastError("\u6743\u9650\u4E0D\u8DB3", {
          status: 403,
          type: "forbidden",
          expose: true
        });
      }
      if (permissions.length > 0 && user.permissions) {
        const userPermissions = Array.isArray(user.permissions) ? user.permissions : [user.permissions];
        const hasPermission = permissions.some(
          (permission) => userPermissions.includes(permission)
        );
        if (!hasPermission) {
          throw new VafastError("\u6743\u9650\u4E0D\u8DB3", {
            status: 403,
            type: "forbidden",
            expose: true
          });
        }
      }
      req.user = user;
      req.token = token;
      return next();
    } catch (error) {
      if (error instanceof TokenError) {
        let status = 401;
        let message = "\u8BA4\u8BC1\u5931\u8D25";
        switch (error.code) {
          case "EXPIRED_TOKEN":
            status = 401;
            message = "\u4EE4\u724C\u5DF2\u8FC7\u671F";
            break;
          case "INVALID_SIGNATURE":
            status = 401;
            message = "\u4EE4\u724C\u7B7E\u540D\u65E0\u6548";
            break;
          case "MALFORMED_TOKEN":
            status = 400;
            message = "\u4EE4\u724C\u683C\u5F0F\u9519\u8BEF";
            break;
          default:
            status = 401;
            message = "\u4EE4\u724C\u9A8C\u8BC1\u5931\u8D25";
        }
        throw new VafastError(message, {
          status,
          type: "unauthorized",
          expose: true
        });
      }
      if (error instanceof VafastError) {
        throw error;
      }
      throw new VafastError("\u8BA4\u8BC1\u8FC7\u7A0B\u4E2D\u53D1\u751F\u9519\u8BEF", {
        status: 500,
        type: "internal_error",
        expose: false
      });
    }
  };
}
function createOptionalAuth(options) {
  return createAuth({ ...options, required: false });
}
function createRoleAuth(roles, options) {
  return createAuth({ ...options, roles });
}
function createPermissionAuth(permissions, options) {
  return createAuth({ ...options, permissions });
}
export {
  createAuth,
  createOptionalAuth,
  createPermissionAuth,
  createRoleAuth
};
//# sourceMappingURL=auth.js.map