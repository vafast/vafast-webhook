{"version":3,"sources":["../../src/middleware.ts","../../src/utils/parsers.ts","../../src/utils/handle.ts","../../src/utils/base64url.ts","../../src/auth/token.ts","../../src/middleware/auth.ts"],"sourcesContent":["// src/middleware.ts\n\nimport { json, mapResponse } from \"./utils/response\";\n\nimport type { Handler, Middleware } from \"./types\";\n/** ä¸­é—´ä»¶ç±»å‹ï¼šä½¿ç”¨ next() ä¼ é€’ç»™ä¸‹ä¸€ä¸ªå¤„ç† */\n\n/** Vafast è‡ªå®šä¹‰é”™è¯¯ç±»å‹ */\nexport class VafastError extends Error {\n  status: number;\n  type: string;\n  expose: boolean;\n\n  constructor(\n    message: string,\n    options: {\n      status?: number;\n      type?: string;\n      expose?: boolean;\n      cause?: unknown;\n    } = {},\n  ) {\n    super(message);\n    this.name = \"VafastError\";\n    this.status = options.status ?? 500;\n    this.type = options.type ?? \"internal_error\";\n    this.expose = options.expose ?? false;\n    if (options.cause) (this as any).cause = options.cause;\n  }\n}\n\n/**\n * ç»„åˆç±»å‹: è‡ªåŠ¨æ³¨å…¥é”™è¯¯å¤„ç†å™¨è¿›è¡Œä¸­é—´ä»¶ç»„åˆ\n */\nexport function composeMiddleware(\n  middleware: Middleware[],\n  finalHandler: Handler,\n): (req: Request) => Promise<Response> {\n  const all = [errorHandler, ...middleware];\n\n  return function composedHandler(req: Request): Promise<Response> {\n    let i = -1;\n\n    const dispatch = (index: number): Promise<Response> => {\n      if (index <= i)\n        return Promise.reject(new Error(\"next() called multiple times\"));\n      i = index;\n\n      // ä¸­é—´ä»¶é˜¶æ®µ\n      if (index < all.length) {\n        const mw = all[index];\n        return Promise.resolve(mw(req, () => dispatch(index + 1)));\n      }\n\n      // æœ€ç»ˆ handler - ä½¿ç”¨ mapResponse è½¬æ¢è¿”å›å€¼\n      return Promise.resolve(finalHandler(req)).then(mapResponse);\n    };\n\n    return dispatch(0);\n  };\n}\n\n/** é»˜è®¤åŒ…å«çš„å…¨å±€é”™è¯¯å¤„ç†å™¨ */\nconst errorHandler: Middleware = async (req, next) => {\n  try {\n    return await next();\n  } catch (err) {\n    console.error(\"æœªå¤„ç†çš„é”™è¯¯:\", err);\n\n    if (err instanceof VafastError) {\n      return json(\n        {\n          error: err.type,\n          message: err.expose ? err.message : \"å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯\",\n        },\n        err.status,\n      );\n    }\n\n    return json({ error: \"internal_error\", message: \"å‡ºç°äº†ä¸€äº›é—®é¢˜\" }, 500);\n  }\n};\n","// src/parsers.ts\nimport qs from \"qs\";\nimport cookie from \"cookie\";\n\n// æ–‡ä»¶ä¿¡æ¯æ¥å£\nexport interface FileInfo {\n  name: string;\n  type: string;\n  size: number;\n  data: ArrayBuffer;\n}\n\n// è¡¨å•æ•°æ®æ¥å£\nexport interface FormData {\n  fields: Record<string, string>;\n  files: Record<string, FileInfo>;\n}\n\n/**\n * ç®€åŒ–çš„è¯·æ±‚ä½“è§£æå‡½æ•°\n * ä¼˜å…ˆç®€æ´æ€§ï¼Œå¤„ç†æœ€å¸¸è§çš„åœºæ™¯\n */\nexport async function parseBody(req: Request): Promise<unknown> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n  if (contentType.includes(\"application/json\")) {\n    return await req.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const text = await req.text();\n    return Object.fromEntries(new URLSearchParams(text));\n  }\n  return await req.text(); // fallback\n}\n\n/**\n * è§£æ multipart/form-data æ ¼å¼\n * æ”¯æŒæ–‡ä»¶ä¸Šä¼ å’Œæ™®é€šè¡¨å•å­—æ®µ\n */\nasync function parseMultipartFormData(req: Request): Promise<FormData> {\n  const formData = await req.formData();\n  const result: FormData = {\n    fields: {},\n    files: {},\n  };\n\n  for (const [key, value] of formData.entries()) {\n    if (\n      typeof value === \"object\" &&\n      value !== null &&\n      \"name\" in value &&\n      \"type\" in value &&\n      \"size\" in value\n    ) {\n      // å¤„ç†æ–‡ä»¶\n      const file = value as any;\n      const arrayBuffer = await file.arrayBuffer();\n      result.files[key] = {\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        data: arrayBuffer,\n      };\n    } else {\n      // å¤„ç†æ™®é€šå­—æ®µ\n      result.fields[key] = value as string;\n    }\n  }\n\n  return result;\n}\n\n/**\n * è§£æè¯·æ±‚ä½“ä¸ºç‰¹å®šç±»å‹\n * æä¾›ç±»å‹å®‰å…¨çš„è§£ææ–¹æ³•\n */\nexport async function parseBodyAs<T>(req: Request): Promise<T> {\n  const body = await parseBody(req);\n  return body as T;\n}\n\n/**\n * è§£æè¯·æ±‚ä½“ä¸ºè¡¨å•æ•°æ®\n * ä¸“é—¨ç”¨äºå¤„ç† multipart/form-data\n */\nexport async function parseFormData(req: Request): Promise<FormData> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n\n  if (!contentType.includes(\"multipart/form-data\")) {\n    throw new Error(\"è¯·æ±‚ä¸æ˜¯ multipart/form-data æ ¼å¼\");\n  }\n\n  return await parseMultipartFormData(req);\n}\n\n/**\n * è§£æè¯·æ±‚ä½“ä¸ºæ–‡ä»¶\n * ä¸“é—¨ç”¨äºå¤„ç†æ–‡ä»¶ä¸Šä¼ \n */\nexport async function parseFile(req: Request): Promise<FileInfo> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n\n  if (!contentType.includes(\"multipart/form-data\")) {\n    throw new Error(\"è¯·æ±‚ä¸æ˜¯ multipart/form-data æ ¼å¼\");\n  }\n\n  const formData = await parseMultipartFormData(req);\n  const fileKeys = Object.keys(formData.files);\n\n  if (fileKeys.length === 0) {\n    throw new Error(\"è¯·æ±‚ä¸­æ²¡æœ‰æ–‡ä»¶\");\n  }\n\n  if (fileKeys.length > 1) {\n    throw new Error(\"è¯·æ±‚ä¸­åŒ…å«å¤šä¸ªæ–‡ä»¶ï¼Œè¯·ä½¿ç”¨ parseFormData\");\n  }\n\n  return formData.files[fileKeys[0]];\n}\n\n/**\n * å¿«é€Ÿæå– query stringï¼ˆé¿å…åˆ›å»º URL å¯¹è±¡ï¼‰\n */\nfunction extractQueryString(url: string): string {\n  const qIndex = url.indexOf(\"?\");\n  if (qIndex === -1) return \"\";\n\n  const hashIndex = url.indexOf(\"#\", qIndex);\n  return hashIndex === -1\n    ? url.substring(qIndex + 1)\n    : url.substring(qIndex + 1, hashIndex);\n}\n\n/** è·å–æŸ¥è¯¢å­—ç¬¦ä¸²ï¼Œç›´æ¥è¿”å›å¯¹è±¡ */\nexport function parseQuery(req: Request): Record<string, unknown> {\n  const queryString = extractQueryString(req.url);\n  if (!queryString) return {};\n  return qs.parse(queryString);\n}\n\n/**\n * å¿«é€Ÿè§£æç®€å•æŸ¥è¯¢å­—ç¬¦ä¸²ï¼ˆä¸æ”¯æŒåµŒå¥—ï¼Œä½†æ›´å¿«ï¼‰\n * é€‚ç”¨äºç®€å•çš„ key=value&key2=value2 åœºæ™¯\n */\nexport function parseQueryFast(req: Request): Record<string, string> {\n  const queryString = extractQueryString(req.url);\n  if (!queryString) return {};\n\n  const result: Record<string, string> = Object.create(null);\n  const pairs = queryString.split(\"&\");\n\n  for (const pair of pairs) {\n    const eqIndex = pair.indexOf(\"=\");\n    if (eqIndex === -1) {\n      result[decodeURIComponent(pair)] = \"\";\n    } else {\n      const key = decodeURIComponent(pair.substring(0, eqIndex));\n      const value = decodeURIComponent(pair.substring(eqIndex + 1));\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\n/** è§£æè¯·æ±‚å¤´ï¼Œè¿”å›å¯¹è±¡ */\nexport function parseHeaders(req: Request): Record<string, string> {\n  const headers: Record<string, string> = Object.create(null);\n  req.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n/**\n * è·å–å•ä¸ªè¯·æ±‚å¤´ï¼ˆé¿å…è§£æå…¨éƒ¨ï¼‰\n */\nexport function getHeader(req: Request, name: string): string | null {\n  return req.headers.get(name);\n}\n\n/** ä½¿ç”¨cookieåº“è§£æCookieï¼Œä¿è¯å¯é æ€§ */\nexport function parseCookies(req: Request): Record<string, string> {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return {};\n\n  try {\n    const parsed = cookie.parse(cookieHeader);\n    // è¿‡æ»¤æ‰undefinedå’Œnullå€¼\n    const result: Record<string, string> = {};\n    for (const [key, value] of Object.entries(parsed)) {\n      if (value !== undefined && value !== null) {\n        result[key] = value;\n      }\n    }\n    return result;\n  } catch {\n    return {};\n  }\n}\n\n/**\n * å¿«é€Ÿè§£æ Cookieï¼ˆç®€åŒ–ç‰ˆï¼Œä¸ä½¿ç”¨å¤–éƒ¨åº“ï¼‰\n * é€‚ç”¨äºç®€å•çš„ cookie åœºæ™¯\n */\nexport function parseCookiesFast(req: Request): Record<string, string> {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return {};\n\n  const result: Record<string, string> = Object.create(null);\n  const pairs = cookieHeader.split(\";\");\n\n  for (const pair of pairs) {\n    const trimmed = pair.trim();\n    const eqIndex = trimmed.indexOf(\"=\");\n    if (eqIndex > 0) {\n      const key = trimmed.substring(0, eqIndex).trim();\n      const value = trimmed.substring(eqIndex + 1).trim();\n      // ç§»é™¤å¼•å·\n      result[key] =\n        value.startsWith('\"') && value.endsWith('\"')\n          ? value.slice(1, -1)\n          : value;\n    }\n  }\n\n  return result;\n}\n\n/**\n * è·å–å•ä¸ª Cookie å€¼ï¼ˆé¿å…è§£æå…¨éƒ¨ï¼‰\n */\nexport function getCookie(req: Request, name: string): string | null {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return null;\n\n  const prefix = `${name}=`;\n  const pairs = cookieHeader.split(\";\");\n\n  for (const pair of pairs) {\n    const trimmed = pair.trim();\n    if (trimmed.startsWith(prefix)) {\n      const value = trimmed.substring(prefix.length).trim();\n      return value.startsWith('\"') && value.endsWith('\"')\n        ? value.slice(1, -1)\n        : value;\n    }\n  }\n\n  return null;\n}\n","import { parseCookies } from \"./parsers\";\n\n/** è·å–å•ä¸ª Cookie å€¼ */\nexport function getCookie(req: Request, key: string): string | null {\n  const cookies = parseCookies(req);\n  return cookies[key] || null;\n}\n\n/** ç”Ÿæˆ Set-Cookie å¤´ */\nexport function setCookie(\n  key: string,\n  value: string,\n  options: {\n    path?: string;\n    httpOnly?: boolean;\n    maxAge?: number;\n    secure?: boolean;\n  } = {},\n): string {\n  let cookie = `${key}=${encodeURIComponent(value)}`;\n\n  if (options.path) cookie += `; Path=${options.path}`;\n  if (options.httpOnly) cookie += `; HttpOnly`;\n  if (options.secure) cookie += `; Secure`;\n  if (options.maxAge) cookie += `; Max-Age=${options.maxAge}`;\n\n  return cookie;\n}\n\n// æä¾›ç»™ä¸­é—´ä»¶å†™å…¥\"å±€éƒ¨ä¸Šä¸‹æ–‡\"çš„å·¥å…·å‡½æ•°\nexport function setLocals<T extends object>(req: Request, extras: T) {\n  const target = req as unknown as Record<string, unknown>;\n  target.__locals = { ...((target.__locals as object) ?? {}), ...extras };\n}\n\n// è·å–ä¸­é—´ä»¶æ³¨å…¥çš„å±€éƒ¨ä¸Šä¸‹æ–‡\nexport function getLocals<T extends object>(req: Request): T {\n  const target = req as unknown as Record<string, unknown>;\n  return (target.__locals ?? {}) as T;\n}\n","export function base64urlEncode(str: string): string {\n  return btoa(str)\n    .replace(/=/g, \"\") // âœ… åˆ é™¤å¡«å……\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\");\n}\n\nexport function base64urlDecode(str: string): string {\n  const pad = str.length % 4 === 0 ? \"\" : \"=\".repeat(4 - (str.length % 4));\n  const base64 = str.replace(/-/g, \"+\").replace(/_/g, \"/\") + pad;\n  return atob(base64);\n}\n","// src/auth/token.ts\nimport { base64urlEncode, base64urlDecode } from \"../utils/base64url\";\n\n// ç±»å‹å®šä¹‰\nexport interface TokenPayload {\n  [key: string]: any;\n  exp?: number; // è¿‡æœŸæ—¶é—´æˆ³\n  iat?: number; // ç­¾å‘æ—¶é—´æˆ³\n  sub?: string; // ä¸»é¢˜ï¼ˆé€šå¸¸æ˜¯ç”¨æˆ·IDï¼‰\n  aud?: string; // å—ä¼—\n  iss?: string; // ç­¾å‘è€…\n}\n\nexport interface TokenResult {\n  payload: TokenPayload;\n  token: string;\n  expiresAt: number;\n}\n\nexport interface TokenOptions {\n  expiresIn?: number; // è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰\n  issuer?: string; // ç­¾å‘è€…\n  audience?: string; // å—ä¼—\n  subject?: string; // ä¸»é¢˜\n}\n\nexport class TokenError extends Error {\n  constructor(\n    message: string,\n    public code:\n      | \"INVALID_TOKEN\"\n      | \"EXPIRED_TOKEN\"\n      | \"INVALID_SIGNATURE\"\n      | \"MALFORMED_TOKEN\"\n      | \"INVALID_PAYLOAD\",\n  ) {\n    super(message);\n    this.name = \"TokenError\";\n  }\n}\n\nconst encoder = new TextEncoder();\n\n/** ä½¿ç”¨ HMAC-SHA256 è¿›è¡Œç­¾å */\nasync function sign(data: string, secret: string): Promise<string> {\n  const key = await crypto.subtle.importKey(\n    \"raw\",\n    encoder.encode(secret),\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\"],\n  );\n\n  const signature = await crypto.subtle.sign(\"HMAC\", key, encoder.encode(data));\n  return btoa(\n    String.fromCharCode.apply(null, Array.from(new Uint8Array(signature))),\n  );\n}\n\n/** ç”Ÿæˆä»¤ç‰Œ */\nexport async function generateToken(\n  payload: TokenPayload,\n  secret: string,\n  options: TokenOptions = {},\n): Promise<TokenResult> {\n  const { expiresIn = 3600, issuer, audience, subject } = options;\n\n  // åˆ›å»ºä»¤ç‰Œè½½è·ï¼Œå¼ºåˆ¶ä½¿ç”¨å½“å‰æ—¶é—´\n  const now = Math.floor(Date.now() / 1000);\n  const tokenPayload: TokenPayload = {\n    ...payload,\n    iat: now,\n    exp: now + expiresIn,\n  };\n\n  // æ·»åŠ å¯é€‰å­—æ®µ\n  if (issuer) tokenPayload.iss = issuer;\n  if (audience) tokenPayload.aud = audience;\n  if (subject) tokenPayload.sub = subject;\n\n  const data = base64urlEncode(JSON.stringify(tokenPayload));\n  const sig = await sign(data, secret);\n  const token = `${data}.${base64urlEncode(sig)}`;\n\n  return {\n    payload: tokenPayload,\n    token,\n    expiresAt: tokenPayload.exp! * 1000, // è½¬æ¢ä¸ºæ¯«ç§’\n  };\n}\n\n/** éªŒè¯ä»¤ç‰Œ */\nexport async function verifyToken(\n  token: string,\n  secret: string,\n): Promise<TokenPayload | null> {\n  try {\n    const [data, sig] = token.split(\".\");\n    if (!data || !sig) {\n      throw new TokenError(\"ä»¤ç‰Œæ ¼å¼æ— æ•ˆ\", \"MALFORMED_TOKEN\");\n    }\n\n    const expectedSig = await sign(data, secret);\n    const expected = base64urlEncode(expectedSig);\n\n    if (sig !== expected) {\n      throw new TokenError(\"ä»¤ç‰Œç­¾åæ— æ•ˆ\", \"INVALID_SIGNATURE\");\n    }\n\n    const payload = JSON.parse(base64urlDecode(data)) as TokenPayload;\n\n    // æ£€æŸ¥è¿‡æœŸæ—¶é—´\n    if (payload.exp && Date.now() / 1000 > payload.exp) {\n      throw new TokenError(\"ä»¤ç‰Œå·²è¿‡æœŸ\", \"EXPIRED_TOKEN\");\n    }\n\n    return payload;\n  } catch (error) {\n    if (error instanceof TokenError) {\n      throw error;\n    }\n    throw new TokenError(\"ä»¤ç‰ŒéªŒè¯å¤±è´¥\", \"INVALID_TOKEN\");\n  }\n}\n\n/** è§£æä»¤ç‰Œï¼ˆä¸éªŒè¯ç­¾åï¼‰ */\nexport function parseToken(token: string): TokenPayload | null {\n  try {\n    const [data] = token.split(\".\");\n    if (!data) return null;\n\n    return JSON.parse(base64urlDecode(data));\n  } catch {\n    return null;\n  }\n}\n\n/** æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦è¿‡æœŸ */\nexport function isTokenExpired(token: string): boolean {\n  const payload = parseToken(token);\n  if (!payload || !payload.exp) return true;\n\n  return Date.now() / 1000 > payload.exp;\n}\n\n/** è·å–ä»¤ç‰Œå‰©ä½™æœ‰æ•ˆæ—¶é—´ï¼ˆç§’ï¼‰ */\nexport function getTokenTimeRemaining(token: string): number {\n  const payload = parseToken(token);\n  if (!payload || !payload.exp) return 0;\n\n  const remaining = payload.exp - Date.now() / 1000;\n  return Math.max(0, Math.floor(remaining));\n}\n\n/** åˆ·æ–°ä»¤ç‰Œ */\nexport async function refreshToken(\n  token: string,\n  secret: string,\n  options: TokenOptions = {},\n): Promise<TokenResult | null> {\n  try {\n    const payload = await verifyToken(token, secret);\n    if (!payload) return null;\n\n    // ç§»é™¤æ—¶é—´ç›¸å…³å­—æ®µï¼Œé‡æ–°ç”Ÿæˆ\n    const { exp, iat, ...cleanPayload } = payload;\n\n    // æ·»åŠ å»¶è¿Ÿç¡®ä¿æ—¶é—´æˆ³ä¸åŒ\n    await new Promise((resolve) => setTimeout(resolve, 10));\n\n    return await generateToken(cleanPayload, secret, options);\n  } catch {\n    return null;\n  }\n}\n\n/** åˆ›å»ºè®¿é—®ä»¤ç‰Œå’Œåˆ·æ–°ä»¤ç‰Œå¯¹ */\nexport async function createTokenPair(\n  payload: TokenPayload,\n  secret: string,\n  options: TokenOptions = {},\n): Promise<{\n  accessToken: TokenResult;\n  refreshToken: TokenResult;\n}> {\n  const accessToken = await generateToken(payload, secret, {\n    ...options,\n    expiresIn: options.expiresIn || 3600, // 1å°æ—¶\n  });\n\n  const refreshToken = await generateToken(payload, secret, {\n    ...options,\n    expiresIn: 7 * 24 * 3600, // 7å¤©\n  });\n\n  return { accessToken, refreshToken };\n}\n","// src/middleware/auth.ts\n\nimport type { Middleware } from \"../types\";\nimport { VafastError } from \"../middleware\";\nimport { getCookie } from \"../utils/handle\";\nimport { verifyToken, TokenError, type TokenPayload } from \"../auth/token\";\n\ninterface AuthOptions {\n  secret: string;\n  cookieName?: string;\n  headerName?: string;\n  required?: boolean; // æ˜¯å¦å¿…éœ€è®¤è¯\n  roles?: string[]; // å…è®¸çš„è§’è‰²\n  permissions?: string[]; // å…è®¸çš„æƒé™\n}\n\nexport function createAuth(options: AuthOptions): Middleware {\n  const {\n    secret,\n    cookieName = \"auth\",\n    headerName = \"authorization\",\n    required = true,\n    roles = [],\n    permissions = [],\n  } = options;\n\n  return async (req, next) => {\n    const token =\n      getCookie(req, cookieName) ||\n      req.headers.get(headerName)?.replace(\"Bearer \", \"\") ||\n      \"\";\n\n    if (!token && required) {\n      throw new VafastError(\"ç¼ºå°‘è®¤è¯ä»¤ç‰Œ\", {\n        status: 401,\n        type: \"unauthorized\",\n        expose: true,\n      });\n    }\n\n    if (!token && !required) {\n      return next();\n    }\n\n    try {\n      const user = (await verifyToken(token, secret)) as TokenPayload;\n\n      if (!user) {\n        throw new VafastError(\"ä»¤ç‰ŒéªŒè¯å¤±è´¥\", {\n          status: 401,\n          type: \"unauthorized\",\n          expose: true,\n        });\n      }\n\n      // æ£€æŸ¥è§’è‰²æƒé™\n      if (roles.length > 0 && user.role && !roles.includes(user.role)) {\n        throw new VafastError(\"æƒé™ä¸è¶³\", {\n          status: 403,\n          type: \"forbidden\",\n          expose: true,\n        });\n      }\n\n      // æ£€æŸ¥å…·ä½“æƒé™\n      if (permissions.length > 0 && user.permissions) {\n        const userPermissions = Array.isArray(user.permissions)\n          ? user.permissions\n          : [user.permissions];\n\n        const hasPermission = permissions.some((permission) =>\n          userPermissions.includes(permission),\n        );\n\n        if (!hasPermission) {\n          throw new VafastError(\"æƒé™ä¸è¶³\", {\n            status: 403,\n            type: \"forbidden\",\n            expose: true,\n          });\n        }\n      }\n\n      // ğŸª„ åœ¨è¿™é‡Œæ‰©å±• Request å¯¹è±¡\n      (req as any).user = user;\n      (req as any).token = token;\n\n      return next();\n    } catch (error) {\n      if (error instanceof TokenError) {\n        let status = 401;\n        let message = \"è®¤è¯å¤±è´¥\";\n\n        switch (error.code) {\n          case \"EXPIRED_TOKEN\":\n            status = 401;\n            message = \"ä»¤ç‰Œå·²è¿‡æœŸ\";\n            break;\n          case \"INVALID_SIGNATURE\":\n            status = 401;\n            message = \"ä»¤ç‰Œç­¾åæ— æ•ˆ\";\n            break;\n          case \"MALFORMED_TOKEN\":\n            status = 400;\n            message = \"ä»¤ç‰Œæ ¼å¼é”™è¯¯\";\n            break;\n          default:\n            status = 401;\n            message = \"ä»¤ç‰ŒéªŒè¯å¤±è´¥\";\n        }\n\n        throw new VafastError(message, {\n          status,\n          type: \"unauthorized\",\n          expose: true,\n        });\n      }\n\n      if (error instanceof VafastError) {\n        throw error;\n      }\n\n      throw new VafastError(\"è®¤è¯è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯\", {\n        status: 500,\n        type: \"internal_error\",\n        expose: false,\n      });\n    }\n  };\n}\n\n// å¯é€‰è®¤è¯ä¸­é—´ä»¶\nexport function createOptionalAuth(\n  options: Omit<AuthOptions, \"required\">,\n): Middleware {\n  return createAuth({ ...options, required: false });\n}\n\n// è§’è‰²éªŒè¯ä¸­é—´ä»¶\nexport function createRoleAuth(\n  roles: string[],\n  options: Omit<AuthOptions, \"roles\">,\n): Middleware {\n  return createAuth({ ...options, roles });\n}\n\n// æƒé™éªŒè¯ä¸­é—´ä»¶\nexport function createPermissionAuth(\n  permissions: string[],\n  options: Omit<AuthOptions, \"permissions\">,\n): Middleware {\n  return createAuth({ ...options, permissions });\n}\n"],"mappings":"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","names":[]}