// src/node-server/response.ts
function buildOutgoingHeaders(headers) {
  const result = {};
  const cookies = [];
  headers.forEach((value, key) => {
    if (key === "set-cookie") {
      cookies.push(value);
    } else {
      result[key] = value;
    }
  });
  if (cookies.length > 0) {
    result["set-cookie"] = cookies;
  }
  return result;
}
async function writeBodyStream(body, outgoing) {
  const reader = body.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      const canContinue = outgoing.write(value);
      if (!canContinue) {
        await new Promise((resolve) => {
          outgoing.once("drain", resolve);
        });
      }
    }
  } finally {
    reader.releaseLock();
  }
}
async function writeResponse(response, outgoing) {
  outgoing.statusCode = response.status;
  const headers = buildOutgoingHeaders(response.headers);
  for (const [key, value] of Object.entries(headers)) {
    outgoing.setHeader(key, value);
  }
  const body = response.body;
  if (!body) {
    outgoing.end();
    return;
  }
  try {
    await writeBodyStream(body, outgoing);
    outgoing.end();
  } catch (error) {
    if (!outgoing.destroyed) {
      outgoing.destroy(
        error instanceof Error ? error : new Error(String(error))
      );
    }
  }
}
async function writeResponseSimple(response, outgoing) {
  outgoing.statusCode = response.status;
  const headers = buildOutgoingHeaders(response.headers);
  for (const [key, value] of Object.entries(headers)) {
    outgoing.setHeader(key, value);
  }
  const body = response.body;
  if (!body) {
    outgoing.end();
    return;
  }
  const buffer = await response.arrayBuffer();
  outgoing.end(Buffer.from(buffer));
}
export {
  writeResponse,
  writeResponseSimple
};
//# sourceMappingURL=response.js.map