{"version":3,"sources":["../../src/node-server/response.ts"],"sourcesContent":["/**\n * 优化的 Response 写入\n * 流式写入，避免内存拷贝\n */\n\nimport type { ServerResponse } from \"node:http\";\n\n/**\n * 构建 Node.js 响应头\n * 处理 set-cookie 多值情况\n */\nfunction buildOutgoingHeaders(\n  headers: Headers,\n): Record<string, string | string[]> {\n  const result: Record<string, string | string[]> = {};\n  const cookies: string[] = [];\n\n  headers.forEach((value, key) => {\n    if (key === \"set-cookie\") {\n      cookies.push(value);\n    } else {\n      result[key] = value;\n    }\n  });\n\n  if (cookies.length > 0) {\n    result[\"set-cookie\"] = cookies;\n  }\n\n  return result;\n}\n\n/**\n * 流式写入 Response body 到 ServerResponse\n * 支持背压处理，避免内存溢出\n */\nasync function writeBodyStream(\n  body: ReadableStream<Uint8Array>,\n  outgoing: ServerResponse,\n): Promise<void> {\n  const reader = body.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) {\n        break;\n      }\n\n      // 背压处理：如果写入返回 false，等待 drain 事件\n      const canContinue = outgoing.write(value);\n      if (!canContinue) {\n        await new Promise<void>((resolve) => {\n          outgoing.once(\"drain\", resolve);\n        });\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n/**\n * 将 Web Response 写入 Node.js ServerResponse\n * 流式写入，零拷贝\n */\nexport async function writeResponse(\n  response: Response,\n  outgoing: ServerResponse,\n): Promise<void> {\n  // 设置状态码\n  outgoing.statusCode = response.status;\n\n  // 设置响应头\n  const headers = buildOutgoingHeaders(response.headers);\n  for (const [key, value] of Object.entries(headers)) {\n    outgoing.setHeader(key, value);\n  }\n\n  const body = response.body;\n\n  // 无 body 的情况\n  if (!body) {\n    outgoing.end();\n    return;\n  }\n\n  // 流式写入 body\n  try {\n    await writeBodyStream(body, outgoing);\n    outgoing.end();\n  } catch (error) {\n    // 处理客户端提前断开等情况\n    if (!outgoing.destroyed) {\n      outgoing.destroy(\n        error instanceof Error ? error : new Error(String(error)),\n      );\n    }\n  }\n}\n\n/**\n * 简化版写入（用于已知小体积响应）\n * 直接 arrayBuffer 转换，适用于确定的小响应\n */\nexport async function writeResponseSimple(\n  response: Response,\n  outgoing: ServerResponse,\n): Promise<void> {\n  outgoing.statusCode = response.status;\n\n  const headers = buildOutgoingHeaders(response.headers);\n  for (const [key, value] of Object.entries(headers)) {\n    outgoing.setHeader(key, value);\n  }\n\n  const body = response.body;\n  if (!body) {\n    outgoing.end();\n    return;\n  }\n\n  // 对于小响应，直接读取全部内容\n  const buffer = await response.arrayBuffer();\n  outgoing.end(Buffer.from(buffer));\n}\n"],"mappings":";AAWA,SAAS,qBACP,SACmC;AACnC,QAAM,SAA4C,CAAC;AACnD,QAAM,UAAoB,CAAC;AAE3B,UAAQ,QAAQ,CAAC,OAAO,QAAQ;AAC9B,QAAI,QAAQ,cAAc;AACxB,cAAQ,KAAK,KAAK;AAAA,IACpB,OAAO;AACL,aAAO,GAAG,IAAI;AAAA,IAChB;AAAA,EACF,CAAC;AAED,MAAI,QAAQ,SAAS,GAAG;AACtB,WAAO,YAAY,IAAI;AAAA,EACzB;AAEA,SAAO;AACT;AAMA,eAAe,gBACb,MACA,UACe;AACf,QAAM,SAAS,KAAK,UAAU;AAE9B,MAAI;AACF,WAAO,MAAM;AACX,YAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAE1C,UAAI,MAAM;AACR;AAAA,MACF;AAGA,YAAM,cAAc,SAAS,MAAM,KAAK;AACxC,UAAI,CAAC,aAAa;AAChB,cAAM,IAAI,QAAc,CAAC,YAAY;AACnC,mBAAS,KAAK,SAAS,OAAO;AAAA,QAChC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF,UAAE;AACA,WAAO,YAAY;AAAA,EACrB;AACF;AAMA,eAAsB,cACpB,UACA,UACe;AAEf,WAAS,aAAa,SAAS;AAG/B,QAAM,UAAU,qBAAqB,SAAS,OAAO;AACrD,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,OAAO,GAAG;AAClD,aAAS,UAAU,KAAK,KAAK;AAAA,EAC/B;AAEA,QAAM,OAAO,SAAS;AAGtB,MAAI,CAAC,MAAM;AACT,aAAS,IAAI;AACb;AAAA,EACF;AAGA,MAAI;AACF,UAAM,gBAAgB,MAAM,QAAQ;AACpC,aAAS,IAAI;AAAA,EACf,SAAS,OAAO;AAEd,QAAI,CAAC,SAAS,WAAW;AACvB,eAAS;AAAA,QACP,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC;AAAA,MAC1D;AAAA,IACF;AAAA,EACF;AACF;AAMA,eAAsB,oBACpB,UACA,UACe;AACf,WAAS,aAAa,SAAS;AAE/B,QAAM,UAAU,qBAAqB,SAAS,OAAO;AACrD,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,OAAO,GAAG;AAClD,aAAS,UAAU,KAAK,KAAK;AAAA,EAC/B;AAEA,QAAM,OAAO,SAAS;AACtB,MAAI,CAAC,MAAM;AACT,aAAS,IAAI;AACb;AAAA,EACF;AAGA,QAAM,SAAS,MAAM,SAAS,YAAY;AAC1C,WAAS,IAAI,OAAO,KAAK,MAAM,CAAC;AAClC;","names":[]}