// src/node-server/serve.ts
import {
  createServer
} from "http";

// src/node-server/request.ts
import { Readable } from "stream";
var requestCache = /* @__PURE__ */ Symbol("requestCache");
var incomingKey = /* @__PURE__ */ Symbol("incoming");
var urlKey = /* @__PURE__ */ Symbol("url");
var headersKey = /* @__PURE__ */ Symbol("headers");
function parseHeaders(rawHeaders) {
  const headers = new Headers();
  for (let i = 0; i < rawHeaders.length; i += 2) {
    const key = rawHeaders[i];
    const value = rawHeaders[i + 1];
    if (key.charCodeAt(0) !== 58) {
      headers.append(key, value);
    }
  }
  return headers;
}
function toWebStream(nodeStream) {
  return nodeStream;
}
function createRealRequest(proxy) {
  const incoming = proxy[incomingKey];
  const method = incoming.method || "GET";
  const init = {
    method,
    headers: proxy[headersKey] || parseHeaders(incoming.rawHeaders)
  };
  if (method !== "GET" && method !== "HEAD") {
    const nodeWebStream = Readable.toWeb(
      incoming
    );
    init.body = toWebStream(nodeWebStream);
    init.duplex = "half";
  }
  return new Request(proxy[urlKey], init);
}
var requestPrototype = {};
Object.defineProperty(requestPrototype, "method", {
  get() {
    const self = this;
    return self[incomingKey].method || "GET";
  },
  enumerable: true
});
Object.defineProperty(requestPrototype, "url", {
  get() {
    const self = this;
    return self[urlKey];
  },
  enumerable: true
});
Object.defineProperty(requestPrototype, "headers", {
  get() {
    const self = this;
    if (!self[headersKey]) {
      self[headersKey] = parseHeaders(self[incomingKey].rawHeaders);
    }
    return self[headersKey];
  },
  enumerable: true
});
Object.defineProperty(requestPrototype, "_getRequest", {
  value: function() {
    const self = this;
    if (!self[requestCache]) {
      self[requestCache] = createRealRequest(self);
    }
    return self[requestCache];
  },
  enumerable: false
});
var proxyGetters = [
  "body",
  "bodyUsed",
  "signal",
  "cache",
  "credentials",
  "destination",
  "integrity",
  "mode",
  "redirect",
  "referrer",
  "referrerPolicy",
  "keepalive"
];
proxyGetters.forEach((key) => {
  Object.defineProperty(requestPrototype, key, {
    get() {
      const self = this;
      return self._getRequest()[key];
    },
    enumerable: true
  });
});
var proxyMethods = [
  "arrayBuffer",
  "blob",
  "clone",
  "formData",
  "json",
  "text"
];
proxyMethods.forEach((key) => {
  Object.defineProperty(requestPrototype, key, {
    value: function() {
      const self = this;
      const req = self._getRequest();
      return req[key].call(req);
    },
    enumerable: true
  });
});
Object.setPrototypeOf(requestPrototype, Request.prototype);
function createProxyRequest(incoming, defaultHost) {
  const req = Object.create(requestPrototype);
  req[incomingKey] = incoming;
  const host = incoming.headers.host || defaultHost;
  const protocol = incoming.socket.encrypted ? "https" : "http";
  req[urlKey] = `${protocol}://${host}${incoming.url || "/"}`;
  return req;
}

// src/node-server/response.ts
function buildOutgoingHeaders(headers) {
  const result = {};
  const cookies = [];
  headers.forEach((value, key) => {
    if (key === "set-cookie") {
      cookies.push(value);
    } else {
      result[key] = value;
    }
  });
  if (cookies.length > 0) {
    result["set-cookie"] = cookies;
  }
  return result;
}
async function writeBodyStream(body, outgoing) {
  const reader = body.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      const canContinue = outgoing.write(value);
      if (!canContinue) {
        await new Promise((resolve) => {
          outgoing.once("drain", resolve);
        });
      }
    }
  } finally {
    reader.releaseLock();
  }
}
async function writeResponse(response, outgoing) {
  outgoing.statusCode = response.status;
  const headers = buildOutgoingHeaders(response.headers);
  for (const [key, value] of Object.entries(headers)) {
    outgoing.setHeader(key, value);
  }
  const body = response.body;
  if (!body) {
    outgoing.end();
    return;
  }
  try {
    await writeBodyStream(body, outgoing);
    outgoing.end();
  } catch (error) {
    if (!outgoing.destroyed) {
      outgoing.destroy(
        error instanceof Error ? error : new Error(String(error))
      );
    }
  }
}
async function writeResponseSimple(response, outgoing) {
  outgoing.statusCode = response.status;
  const headers = buildOutgoingHeaders(response.headers);
  for (const [key, value] of Object.entries(headers)) {
    outgoing.setHeader(key, value);
  }
  const body = response.body;
  if (!body) {
    outgoing.end();
    return;
  }
  const buffer = await response.arrayBuffer();
  outgoing.end(Buffer.from(buffer));
}

// src/node-server/serve.ts
function createRequestHandler(fetch, defaultHost, onError) {
  return async (incoming, outgoing) => {
    try {
      const request = createProxyRequest(incoming, defaultHost);
      const response = await fetch(request);
      await writeResponse(response, outgoing);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      if (onError) {
        try {
          const errorResponse = await onError(err);
          await writeResponse(errorResponse, outgoing);
          return;
        } catch {
        }
      }
      if (!outgoing.headersSent) {
        outgoing.statusCode = 500;
        outgoing.setHeader("Content-Type", "text/plain");
        outgoing.end("Internal Server Error");
      }
    }
  };
}
function serve(options, callback) {
  const { fetch, port = 3e3, hostname = "0.0.0.0", onError, gracefulShutdown } = options;
  const defaultHost = `${hostname === "0.0.0.0" ? "localhost" : hostname}:${port}`;
  const handler = createRequestHandler(fetch, defaultHost, onError);
  const server = createServer(handler);
  const connections = /* @__PURE__ */ new Set();
  server.on("connection", (socket) => {
    connections.add(socket);
    socket.on("close", () => connections.delete(socket));
  });
  let isShuttingDown = false;
  const shutdown = async () => {
    if (isShuttingDown) return;
    isShuttingDown = true;
    const shutdownOptions = typeof gracefulShutdown === "object" ? gracefulShutdown : {};
    const timeout = shutdownOptions.timeout ?? 3e4;
    if (shutdownOptions.onShutdown) {
      await shutdownOptions.onShutdown();
    }
    return new Promise((resolve) => {
      const forceCloseTimer = setTimeout(() => {
        for (const socket of connections) {
          socket.destroy();
        }
        connections.clear();
        resolve();
      }, timeout);
      server.close(() => {
        clearTimeout(forceCloseTimer);
        shutdownOptions.onShutdownComplete?.();
        resolve();
      });
      for (const socket of connections) {
        if (!socket.writableLength) {
          socket.end();
        }
      }
    });
  };
  if (gracefulShutdown) {
    const shutdownOptions = typeof gracefulShutdown === "object" ? gracefulShutdown : {};
    const signals = shutdownOptions.signals ?? ["SIGINT", "SIGTERM"];
    for (const signal of signals) {
      process.on(signal, () => {
        shutdown().then(() => process.exit(0));
      });
    }
  }
  server.listen(port, hostname, callback);
  return {
    server,
    port,
    hostname,
    stop: () => new Promise((resolve, reject) => {
      server.close((err) => {
        if (err) reject(err);
        else resolve();
      });
    }),
    shutdown
  };
}
function createAdaptorServer(fetch, onError) {
  const handler = createRequestHandler(fetch, "localhost", onError);
  return createServer(handler);
}
export {
  createAdaptorServer,
  createProxyRequest,
  serve,
  writeResponse,
  writeResponseSimple
};
//# sourceMappingURL=index.js.map