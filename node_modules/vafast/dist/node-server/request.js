// src/node-server/request.ts
import { Readable } from "stream";
var requestCache = /* @__PURE__ */ Symbol("requestCache");
var incomingKey = /* @__PURE__ */ Symbol("incoming");
var urlKey = /* @__PURE__ */ Symbol("url");
var headersKey = /* @__PURE__ */ Symbol("headers");
function parseHeaders(rawHeaders) {
  const headers = new Headers();
  for (let i = 0; i < rawHeaders.length; i += 2) {
    const key = rawHeaders[i];
    const value = rawHeaders[i + 1];
    if (key.charCodeAt(0) !== 58) {
      headers.append(key, value);
    }
  }
  return headers;
}
function toWebStream(nodeStream) {
  return nodeStream;
}
function createRealRequest(proxy) {
  const incoming = proxy[incomingKey];
  const method = incoming.method || "GET";
  const init = {
    method,
    headers: proxy[headersKey] || parseHeaders(incoming.rawHeaders)
  };
  if (method !== "GET" && method !== "HEAD") {
    const nodeWebStream = Readable.toWeb(
      incoming
    );
    init.body = toWebStream(nodeWebStream);
    init.duplex = "half";
  }
  return new Request(proxy[urlKey], init);
}
var requestPrototype = {};
Object.defineProperty(requestPrototype, "method", {
  get() {
    const self = this;
    return self[incomingKey].method || "GET";
  },
  enumerable: true
});
Object.defineProperty(requestPrototype, "url", {
  get() {
    const self = this;
    return self[urlKey];
  },
  enumerable: true
});
Object.defineProperty(requestPrototype, "headers", {
  get() {
    const self = this;
    if (!self[headersKey]) {
      self[headersKey] = parseHeaders(self[incomingKey].rawHeaders);
    }
    return self[headersKey];
  },
  enumerable: true
});
Object.defineProperty(requestPrototype, "_getRequest", {
  value: function() {
    const self = this;
    if (!self[requestCache]) {
      self[requestCache] = createRealRequest(self);
    }
    return self[requestCache];
  },
  enumerable: false
});
var proxyGetters = [
  "body",
  "bodyUsed",
  "signal",
  "cache",
  "credentials",
  "destination",
  "integrity",
  "mode",
  "redirect",
  "referrer",
  "referrerPolicy",
  "keepalive"
];
proxyGetters.forEach((key) => {
  Object.defineProperty(requestPrototype, key, {
    get() {
      const self = this;
      return self._getRequest()[key];
    },
    enumerable: true
  });
});
var proxyMethods = [
  "arrayBuffer",
  "blob",
  "clone",
  "formData",
  "json",
  "text"
];
proxyMethods.forEach((key) => {
  Object.defineProperty(requestPrototype, key, {
    value: function() {
      const self = this;
      const req = self._getRequest();
      return req[key].call(req);
    },
    enumerable: true
  });
});
Object.setPrototypeOf(requestPrototype, Request.prototype);
function createProxyRequest(incoming, defaultHost) {
  const req = Object.create(requestPrototype);
  req[incomingKey] = incoming;
  const host = incoming.headers.host || defaultHost;
  const protocol = incoming.socket.encrypted ? "https" : "http";
  req[urlKey] = `${protocol}://${host}${incoming.url || "/"}`;
  return req;
}
export {
  createProxyRequest
};
//# sourceMappingURL=request.js.map