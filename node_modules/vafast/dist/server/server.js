// src/router.ts
function flattenNestedRoutes(routes) {
  const flattened = [];
  function processRoute(route, parentPath = "", parentMiddleware = []) {
    const currentPath = normalizePath(parentPath + route.path);
    const currentMiddleware = [
      ...parentMiddleware,
      ...route.middleware || []
    ];
    if ("method" in route && "handler" in route) {
      const leafRoute = route;
      flattened.push({
        ...leafRoute,
        fullPath: currentPath,
        middlewareChain: currentMiddleware
      });
    } else if ("children" in route && route.children) {
      for (const child of route.children) {
        processRoute(child, currentPath, currentMiddleware);
      }
    }
  }
  for (const route of routes) {
    processRoute(route);
  }
  return flattened;
}
function normalizePath(path) {
  let normalized = decodeURIComponent(path);
  normalized = normalized.replace(/\/+/g, "/");
  if (normalized === "") return "/";
  if (normalized !== "/" && normalized.endsWith("/")) {
    normalized = normalized.slice(0, -1);
  }
  return normalized;
}

// src/utils/response.ts
function json(data, status = 200, headers = {}) {
  const body = JSON.stringify(data);
  if (Object.keys(headers).length === 0) {
    return new Response(body, {
      status,
      headers: { "Content-Type": "application/json" }
    });
  }
  const h = new Headers({
    "Content-Type": "application/json",
    ...headers
  });
  return new Response(body, {
    status,
    headers: h
  });
}
var JSON_HEADERS = { "Content-Type": "application/json" };
var TEXT_HEADERS = { "Content-Type": "text/plain" };
function mapResponse(response) {
  if (response instanceof Response) return response;
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response, { headers: TEXT_HEADERS });
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: JSON_HEADERS });
    case "Number":
    case "Boolean":
      return new Response(String(response), { headers: TEXT_HEADERS });
    case void 0:
      return new Response(null, { status: 204 });
    case "ReadableStream":
      return new Response(response);
    case "Blob":
      return new Response(response);
    case "ArrayBuffer":
      return new Response(response);
    case "Uint8Array":
      return new Response(response);
    default:
      if (response instanceof Promise) {
        return response.then(mapResponse);
      }
      return new Response(JSON.stringify(response), { headers: JSON_HEADERS });
  }
}

// src/middleware.ts
var VafastError = class extends Error {
  status;
  type;
  expose;
  constructor(message, options = {}) {
    super(message);
    this.name = "VafastError";
    this.status = options.status ?? 500;
    this.type = options.type ?? "internal_error";
    this.expose = options.expose ?? false;
    if (options.cause) this.cause = options.cause;
  }
};
function composeMiddleware(middleware, finalHandler) {
  const all = [errorHandler, ...middleware];
  return function composedHandler(req) {
    let i = -1;
    const dispatch = (index) => {
      if (index <= i)
        return Promise.reject(new Error("next() called multiple times"));
      i = index;
      if (index < all.length) {
        const mw = all[index];
        return Promise.resolve(mw(req, () => dispatch(index + 1)));
      }
      return Promise.resolve(finalHandler(req)).then(mapResponse);
    };
    return dispatch(0);
  };
}
var errorHandler = async (req, next) => {
  try {
    return await next();
  } catch (err) {
    console.error("\u672A\u5904\u7406\u7684\u9519\u8BEF:", err);
    if (err instanceof VafastError) {
      return json(
        {
          error: err.type,
          message: err.expose ? err.message : "\u53D1\u751F\u4E86\u4E00\u4E2A\u9519\u8BEF"
        },
        err.status
      );
    }
    return json({ error: "internal_error", message: "\u51FA\u73B0\u4E86\u4E00\u4E9B\u95EE\u9898" }, 500);
  }
};

// src/server/base-server.ts
var BaseServer = class {
  globalMiddleware = [];
  use(mw) {
    this.globalMiddleware.push(mw);
  }
  /**
   * 打印扁平化后的路由信息，用于调试
   */
  logFlattenedRoutes(routes, type = "\u8DEF\u7531") {
    console.log(`\u{1F680} \u6241\u5E73\u5316\u540E\u7684${type}:`);
    for (const route of routes) {
      const method = route.method || "GET";
      const path = route.fullPath || route.path;
      console.log(`  ${method} ${path}`);
      if (route.middlewareChain && route.middlewareChain.length > 0) {
        console.log(`    \u4E2D\u95F4\u4EF6\u94FE: ${route.middlewareChain.length} \u4E2A`);
      }
    }
    console.log("");
  }
  /**
   * 检测路由冲突
   * 检查是否有路径相同但方法不同的路由，以及潜在的路径冲突
   */
  detectRouteConflicts(routes) {
    const pathGroups = /* @__PURE__ */ new Map();
    for (const route of routes) {
      const path = route.fullPath || route.path;
      const method = route.method || "GET";
      if (!pathGroups.has(path)) {
        pathGroups.set(path, []);
      }
      pathGroups.get(path).push({ ...route, method });
    }
    for (const [path, routeList] of pathGroups) {
      if (routeList.length > 1) {
        const methods = routeList.map((r) => r.method);
        const uniqueMethods = [...new Set(methods)];
        if (uniqueMethods.length === 1) {
          console.warn(
            `\u26A0\uFE0F  \u8DEF\u7531\u51B2\u7A81: ${uniqueMethods[0]} ${path} \u5B9A\u4E49\u4E86 ${routeList.length} \u6B21`
          );
          routeList.forEach((route, index) => {
            console.warn(`   ${index + 1}. ${route.method} ${path}`);
          });
        } else {
          console.log(`\u2139\uFE0F  \u8DEF\u5F84 ${path} \u652F\u6301\u65B9\u6CD5: ${uniqueMethods.join(", ")}`);
        }
      }
    }
    this.detectDynamicRouteConflicts(routes);
  }
  /**
   * 检测动态路由的潜在冲突
   */
  detectDynamicRouteConflicts(routes) {
    const dynamicRoutes = routes.filter((r) => {
      const path = r.fullPath || r.path;
      return path.includes(":") || path.includes("*");
    });
    for (let i = 0; i < dynamicRoutes.length; i++) {
      for (let j = i + 1; j < dynamicRoutes.length; j++) {
        const route1 = dynamicRoutes[i];
        const route2 = dynamicRoutes[j];
        const method1 = route1.method || "GET";
        const method2 = route2.method || "GET";
        if (method1 === method2) {
          const path1 = route1.fullPath || route1.path;
          const path2 = route2.fullPath || route2.path;
          if (this.pathsMayConflict(path1, path2)) {
            console.warn(
              `\u26A0\uFE0F  \u6F5C\u5728\u8DEF\u7531\u51B2\u7A81: ${method1} ${path1} \u53EF\u80FD\u4E0E ${path2} \u51B2\u7A81`
            );
          }
        }
      }
    }
  }
  /**
   * 判断两个路径是否可能冲突
   */
  pathsMayConflict(path1, path2) {
    const parts1 = path1.split("/").filter(Boolean);
    const parts2 = path2.split("/").filter(Boolean);
    if (parts1.length !== parts2.length) return false;
    for (let i = 0; i < parts1.length; i++) {
      const p1 = parts1[i];
      const p2 = parts2[i];
      if (!p1.startsWith(":") && !p1.startsWith("*") && !p2.startsWith(":") && !p2.startsWith("*") && p1 !== p2) {
        return false;
      }
      if (p1 === "*" && p2.startsWith(":") || p2 === "*" && p1.startsWith(":")) {
        return true;
      }
    }
    return false;
  }
  /**
   * 路径匹配
   */
  matchPath(pattern, path) {
    const patternParts = pattern.split("/").filter(Boolean);
    const pathParts = path.split("/").filter(Boolean);
    if (patternParts.length !== pathParts.length) {
      return false;
    }
    for (let i = 0; i < patternParts.length; i++) {
      if (patternParts[i] !== pathParts[i] && !patternParts[i].startsWith(":")) {
        return false;
      }
    }
    return true;
  }
  /**
   * 提取路径参数
   */
  extractParams(pattern, path) {
    const params = {};
    const patternParts = pattern.split("/").filter(Boolean);
    const pathParts = path.split("/").filter(Boolean);
    for (let i = 0; i < patternParts.length; i++) {
      if (patternParts[i].startsWith(":")) {
        const paramName = patternParts[i].slice(1);
        params[paramName] = pathParts[i];
      }
    }
    return params;
  }
};

// src/router/radix-tree.ts
var RadixRouter = class {
  root;
  constructor() {
    this.root = this.createNode("");
  }
  createNode(path) {
    return {
      path,
      children: /* @__PURE__ */ Object.create(null),
      handlers: /* @__PURE__ */ Object.create(null)
    };
  }
  /** 分割路径 */
  splitPath(path) {
    return path.split("/").filter(Boolean);
  }
  /** 编译器函数 - 用于预编译中间件链 */
  compiler;
  /** 设置中间件编译器 */
  setCompiler(compiler) {
    this.compiler = compiler;
  }
  /** 注册路由 */
  register(method, pattern, handler, middleware = []) {
    const segments = this.splitPath(pattern);
    let node = this.root;
    for (const segment of segments) {
      const firstChar = segment[0];
      if (firstChar === ":") {
        if (!node.paramChild) {
          node.paramChild = this.createNode(segment);
          node.paramChild.paramName = segment.substring(1);
        }
        node = node.paramChild;
      } else if (firstChar === "*") {
        if (!node.wildcardChild) {
          node.wildcardChild = this.createNode(segment);
          node.wildcardChild.paramName = segment.length > 1 ? segment.substring(1) : "*";
        }
        node = node.wildcardChild;
        break;
      } else {
        if (!node.children[segment]) {
          node.children[segment] = this.createNode(segment);
        }
        node = node.children[segment];
      }
    }
    const routeHandler = { handler, middleware };
    if (this.compiler && middleware.length === 0) {
      routeHandler.compiled = this.compiler([], handler);
    }
    node.handlers[method] = routeHandler;
  }
  /** 预编译所有路由（在添加全局中间件后调用） */
  precompileAll(globalMiddleware) {
    if (!this.compiler) return;
    this.precompileNode(this.root, globalMiddleware);
  }
  precompileNode(node, globalMiddleware) {
    for (const method in node.handlers) {
      const routeHandler = node.handlers[method];
      if (routeHandler) {
        const allMiddleware = [...globalMiddleware, ...routeHandler.middleware];
        routeHandler.compiled = this.compiler(
          allMiddleware,
          routeHandler.handler
        );
      }
    }
    for (const key in node.children) {
      this.precompileNode(node.children[key], globalMiddleware);
    }
    if (node.paramChild) {
      this.precompileNode(node.paramChild, globalMiddleware);
    }
    if (node.wildcardChild) {
      this.precompileNode(node.wildcardChild, globalMiddleware);
    }
  }
  /** 匹配路由 */
  match(method, path) {
    const segments = this.splitPath(path);
    const params = /* @__PURE__ */ Object.create(null);
    const node = this.matchNode(this.root, segments, 0, params);
    if (!node) return null;
    const routeHandler = node.handlers[method];
    if (!routeHandler) return null;
    return {
      handler: routeHandler.handler,
      middleware: routeHandler.middleware,
      params,
      compiled: routeHandler.compiled
    };
  }
  /** 递归匹配节点 (优先级: 静态 > 动态参数 > 通配符) */
  matchNode(node, segments, index, params) {
    if (index === segments.length) {
      for (const method in node.handlers) {
        if (node.handlers[method]) return node;
      }
      return null;
    }
    const segment = segments[index];
    const staticChild = node.children[segment];
    if (staticChild) {
      const result = this.matchNode(staticChild, segments, index + 1, params);
      if (result) return result;
    }
    if (node.paramChild) {
      const paramName = node.paramChild.paramName;
      const oldValue = params[paramName];
      params[paramName] = segment;
      const result = this.matchNode(
        node.paramChild,
        segments,
        index + 1,
        params
      );
      if (result) return result;
      if (oldValue === void 0) {
        delete params[paramName];
      } else {
        params[paramName] = oldValue;
      }
    }
    if (node.wildcardChild) {
      params[node.wildcardChild.paramName || "*"] = segments.slice(index).join("/");
      return node.wildcardChild;
    }
    return null;
  }
  /** 获取路径允许的 HTTP 方法 */
  getAllowedMethods(path) {
    const segments = this.splitPath(path);
    const node = this.findNode(segments);
    if (!node) return [];
    const methods = [];
    for (const method in node.handlers) {
      if (node.handlers[method]) {
        methods.push(method);
      }
    }
    return methods;
  }
  /** 查找节点（不提取参数） */
  findNode(segments) {
    let node = this.root;
    for (const segment of segments) {
      if (node.children[segment]) {
        node = node.children[segment];
      } else if (node.paramChild) {
        node = node.paramChild;
      } else if (node.wildcardChild) {
        return node.wildcardChild;
      } else {
        return null;
      }
    }
    return node;
  }
  /** 获取所有已注册的路由 */
  getRoutes() {
    const routes = [];
    this.collectRoutes(this.root, "", routes);
    return routes;
  }
  collectRoutes(node, prefix, routes) {
    const currentPath = prefix + (node.path ? "/" + node.path : "");
    for (const method in node.handlers) {
      if (node.handlers[method]) {
        routes.push({ method, path: currentPath || "/" });
      }
    }
    for (const key in node.children) {
      this.collectRoutes(node.children[key], currentPath, routes);
    }
    if (node.paramChild) {
      this.collectRoutes(node.paramChild, currentPath, routes);
    }
    if (node.wildcardChild) {
      this.collectRoutes(node.wildcardChild, currentPath, routes);
    }
  }
};

// src/utils/route-registry.ts
var RouteRegistry = class {
  /** 所有路由元信息 */
  routes = [];
  /** 路由映射表：METHOD:fullPath -> RouteMeta */
  routeMap = /* @__PURE__ */ new Map();
  /** 分类映射表：category -> RouteMeta[] */
  categoryMap = /* @__PURE__ */ new Map();
  constructor(routes) {
    this.buildRegistry(routes);
  }
  /**
   * 构建注册表
   */
  buildRegistry(routes) {
    for (const route of routes) {
      const meta = {
        method: route.method,
        path: route.path,
        fullPath: route.fullPath,
        name: route.name,
        description: route.description
      };
      for (const key of Object.keys(route)) {
        if (!["method", "path", "fullPath", "name", "description", "handler", "middleware", "middlewareChain"].includes(key)) {
          meta[key] = route[key];
        }
      }
      this.routes.push(meta);
      this.routeMap.set(`${route.method}:${route.fullPath}`, meta);
      const category = this.extractCategory(route.fullPath);
      if (!this.categoryMap.has(category)) {
        this.categoryMap.set(category, []);
      }
      this.categoryMap.get(category).push(meta);
    }
  }
  /**
   * 提取分类（第一段路径）
   */
  extractCategory(path) {
    const segments = path.split("/").filter(Boolean);
    return segments[0] || "root";
  }
  // ============================================
  // 查询接口
  // ============================================
  /**
   * 获取所有路由元信息
   */
  getAll() {
    return [...this.routes];
  }
  /**
   * 按 method + path 查询路由
   */
  get(method, path) {
    return this.routeMap.get(`${method}:${path}`);
  }
  /**
   * 检查路由是否存在
   */
  has(method, path) {
    return this.routeMap.has(`${method}:${path}`);
  }
  /**
   * 按分类获取路由
   */
  getByCategory(category) {
    return this.categoryMap.get(category) || [];
  }
  /**
   * 获取所有分类
   */
  getCategories() {
    return Array.from(this.categoryMap.keys()).sort();
  }
  /**
   * 筛选有特定字段的路由
   *
   * @example
   * ```typescript
   * // 获取所有配置了 webhook 的路由
   * const webhookRoutes = registry.filter('webhook')
   * ```
   */
  filter(field) {
    return this.routes.filter((r) => field in r && r[field] !== void 0);
  }
  /**
   * 按条件筛选路由
   *
   * @example
   * ```typescript
   * // 获取所有 POST 请求
   * const postRoutes = registry.filterBy(r => r.method === 'POST')
   * ```
   */
  filterBy(predicate) {
    return this.routes.filter(predicate);
  }
  /**
   * 获取路由数量
   */
  get size() {
    return this.routes.length;
  }
  /**
   * 遍历所有路由
   */
  forEach(callback) {
    this.routes.forEach(callback);
  }
  /**
   * 映射所有路由
   */
  map(callback) {
    return this.routes.map(callback);
  }
};
var globalRegistry = null;
function setGlobalRegistry(registry) {
  globalRegistry = registry;
}

// src/server/server.ts
var Server = class extends BaseServer {
  router;
  routes;
  /** 是否已预编译 */
  isCompiled = false;
  /** 预编译时的全局中间件数量 */
  compiledWithMiddlewareCount = 0;
  constructor(routes = []) {
    super();
    this.router = new RadixRouter();
    this.routes = [];
    this.router.setCompiler(
      (middleware, handler) => composeMiddleware(middleware, handler)
    );
    if (routes.length > 0) {
      this.registerRoutes(routes);
    }
  }
  /**
   * 预编译所有路由处理链
   * 在添加所有路由和全局中间件后调用，可提升运行时性能
   */
  compile() {
    this.router.precompileAll(this.globalMiddleware);
    this.isCompiled = true;
    this.compiledWithMiddlewareCount = this.globalMiddleware.length;
    return this;
  }
  registerRoutes(routes) {
    const flattened = flattenNestedRoutes(routes);
    this.routes.push(...flattened);
    for (const route of flattened) {
      this.router.register(
        route.method,
        route.fullPath,
        route.handler,
        route.middlewareChain || []
      );
    }
    this.detectRouteConflicts(flattened);
    this.logFlattenedRoutes(flattened);
    if (this.globalMiddleware.length === 0 && !this.isCompiled) {
      this.compile();
    }
    setGlobalRegistry(new RouteRegistry(this.routes));
  }
  /** 快速提取 pathname */
  extractPathname(url) {
    let start = url.indexOf("://");
    start = start === -1 ? 0 : start + 3;
    const pathStart = url.indexOf("/", start);
    if (pathStart === -1) return "/";
    let end = url.indexOf("?", pathStart);
    if (end === -1) end = url.indexOf("#", pathStart);
    if (end === -1) end = url.length;
    return url.substring(pathStart, end) || "/";
  }
  /** 生成 404/405 响应 */
  createErrorResponse(method, pathname) {
    const allowedMethods = this.router.getAllowedMethods(pathname);
    if (allowedMethods.length > 0) {
      return json(
        {
          success: false,
          error: "Method Not Allowed",
          message: `Method ${method} not allowed for this endpoint`,
          allowedMethods
        },
        405,
        { Allow: allowedMethods.join(", ") }
      );
    }
    return json({ success: false, error: "Not Found" }, 404);
  }
  /** 处理请求 */
  fetch = async (req) => {
    const pathname = this.extractPathname(req.url);
    const method = req.method;
    const match = this.router.match(method, pathname);
    if (match) {
      req.params = match.params;
      if (match.compiled && this.globalMiddleware.length === this.compiledWithMiddlewareCount) {
        return match.compiled(req);
      }
      const allMiddleware = [...this.globalMiddleware, ...match.middleware];
      const handler = composeMiddleware(allMiddleware, match.handler);
      return handler(req);
    }
    if (method === "OPTIONS") {
      const allowedMethods = this.router.getAllowedMethods(pathname);
      if (allowedMethods.length > 0) {
        const anyMatch = this.router.match(
          allowedMethods[0],
          pathname
        );
        const routeMiddleware = anyMatch?.middleware || [];
        const allMiddleware = [...this.globalMiddleware, ...routeMiddleware];
        const optionsHandler = () => new Response(null, {
          status: 204,
          headers: { Allow: allowedMethods.join(", ") }
        });
        const handler = composeMiddleware(allMiddleware, optionsHandler);
        return handler(req);
      }
    }
    if (this.globalMiddleware.length > 0) {
      const handler = composeMiddleware(
        this.globalMiddleware,
        () => this.createErrorResponse(method, pathname)
      );
      return handler(req);
    }
    return this.createErrorResponse(method, pathname);
  };
  addRoute(route) {
    const flattenedRoute = {
      ...route,
      fullPath: route.path,
      middlewareChain: route.middleware || []
    };
    this.routes.push(flattenedRoute);
    this.router.register(
      route.method,
      route.path,
      route.handler,
      route.middleware || []
    );
  }
  addRoutes(routes) {
    this.registerRoutes(routes);
  }
  getRoutes() {
    return this.router.getRoutes();
  }
  /**
   * 获取完整的路由元信息（不含 handler 和 middleware）
   *
   * 用于 API 文档生成、Webhook 事件注册、权限检查等场景
   *
   * @example
   * ```typescript
   * const routes = server.getRoutesWithMeta()
   * for (const route of routes) {
   *   console.log(route.fullPath, route.name, route.description)
   * }
   * ```
   */
  getRoutesWithMeta() {
    return this.routes;
  }
};
export {
  Server
};
//# sourceMappingURL=server.js.map