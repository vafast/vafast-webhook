// src/server/base-server.ts
var BaseServer = class {
  globalMiddleware = [];
  use(mw) {
    this.globalMiddleware.push(mw);
  }
  /**
   * 打印扁平化后的路由信息，用于调试
   */
  logFlattenedRoutes(routes, type = "\u8DEF\u7531") {
    console.log(`\u{1F680} \u6241\u5E73\u5316\u540E\u7684${type}:`);
    for (const route of routes) {
      const method = route.method || "GET";
      const path = route.fullPath || route.path;
      console.log(`  ${method} ${path}`);
      if (route.middlewareChain && route.middlewareChain.length > 0) {
        console.log(`    \u4E2D\u95F4\u4EF6\u94FE: ${route.middlewareChain.length} \u4E2A`);
      }
    }
    console.log("");
  }
  /**
   * 检测路由冲突
   * 检查是否有路径相同但方法不同的路由，以及潜在的路径冲突
   */
  detectRouteConflicts(routes) {
    const pathGroups = /* @__PURE__ */ new Map();
    for (const route of routes) {
      const path = route.fullPath || route.path;
      const method = route.method || "GET";
      if (!pathGroups.has(path)) {
        pathGroups.set(path, []);
      }
      pathGroups.get(path).push({ ...route, method });
    }
    for (const [path, routeList] of pathGroups) {
      if (routeList.length > 1) {
        const methods = routeList.map((r) => r.method);
        const uniqueMethods = [...new Set(methods)];
        if (uniqueMethods.length === 1) {
          console.warn(
            `\u26A0\uFE0F  \u8DEF\u7531\u51B2\u7A81: ${uniqueMethods[0]} ${path} \u5B9A\u4E49\u4E86 ${routeList.length} \u6B21`
          );
          routeList.forEach((route, index) => {
            console.warn(`   ${index + 1}. ${route.method} ${path}`);
          });
        } else {
          console.log(`\u2139\uFE0F  \u8DEF\u5F84 ${path} \u652F\u6301\u65B9\u6CD5: ${uniqueMethods.join(", ")}`);
        }
      }
    }
    this.detectDynamicRouteConflicts(routes);
  }
  /**
   * 检测动态路由的潜在冲突
   */
  detectDynamicRouteConflicts(routes) {
    const dynamicRoutes = routes.filter((r) => {
      const path = r.fullPath || r.path;
      return path.includes(":") || path.includes("*");
    });
    for (let i = 0; i < dynamicRoutes.length; i++) {
      for (let j = i + 1; j < dynamicRoutes.length; j++) {
        const route1 = dynamicRoutes[i];
        const route2 = dynamicRoutes[j];
        const method1 = route1.method || "GET";
        const method2 = route2.method || "GET";
        if (method1 === method2) {
          const path1 = route1.fullPath || route1.path;
          const path2 = route2.fullPath || route2.path;
          if (this.pathsMayConflict(path1, path2)) {
            console.warn(
              `\u26A0\uFE0F  \u6F5C\u5728\u8DEF\u7531\u51B2\u7A81: ${method1} ${path1} \u53EF\u80FD\u4E0E ${path2} \u51B2\u7A81`
            );
          }
        }
      }
    }
  }
  /**
   * 判断两个路径是否可能冲突
   */
  pathsMayConflict(path1, path2) {
    const parts1 = path1.split("/").filter(Boolean);
    const parts2 = path2.split("/").filter(Boolean);
    if (parts1.length !== parts2.length) return false;
    for (let i = 0; i < parts1.length; i++) {
      const p1 = parts1[i];
      const p2 = parts2[i];
      if (!p1.startsWith(":") && !p1.startsWith("*") && !p2.startsWith(":") && !p2.startsWith("*") && p1 !== p2) {
        return false;
      }
      if (p1 === "*" && p2.startsWith(":") || p2 === "*" && p1.startsWith(":")) {
        return true;
      }
    }
    return false;
  }
  /**
   * 路径匹配
   */
  matchPath(pattern, path) {
    const patternParts = pattern.split("/").filter(Boolean);
    const pathParts = path.split("/").filter(Boolean);
    if (patternParts.length !== pathParts.length) {
      return false;
    }
    for (let i = 0; i < patternParts.length; i++) {
      if (patternParts[i] !== pathParts[i] && !patternParts[i].startsWith(":")) {
        return false;
      }
    }
    return true;
  }
  /**
   * 提取路径参数
   */
  extractParams(pattern, path) {
    const params = {};
    const patternParts = pattern.split("/").filter(Boolean);
    const pathParts = path.split("/").filter(Boolean);
    for (let i = 0; i < patternParts.length; i++) {
      if (patternParts[i].startsWith(":")) {
        const paramName = patternParts[i].slice(1);
        params[paramName] = pathParts[i];
      }
    }
    return params;
  }
};
export {
  BaseServer
};
//# sourceMappingURL=base-server.js.map