{"version":3,"sources":["../../src/utils/validators/validators.ts","../../src/utils/parsers.ts","../../src/utils/request-validator.ts"],"sourcesContent":["/**\n * Schema 验证器 - 简洁版\n *\n * 特点：\n * - WeakMap 缓存避免内存泄漏\n * - TypeCompiler JIT 编译，性能最佳\n * - 支持 FormatRegistry（需确保同一实例）\n *\n * @version 7.0.0\n */\n\nimport { Type } from \"@sinclair/typebox\";\nimport type { Static, TSchema } from \"@sinclair/typebox\";\nimport { TypeCompiler, type TypeCheck } from \"@sinclair/typebox/compiler\";\nimport { Value } from \"@sinclair/typebox/value\";\n\n// ============== 类型定义 ==============\n\n/** Schema 配置接口 */\nexport interface SchemaConfig {\n  body?: TSchema;\n  query?: TSchema;\n  params?: TSchema;\n  headers?: TSchema;\n  cookies?: TSchema;\n}\n\n/** 验证错误接口 */\nexport interface ValidationError {\n  path: string;\n  message: string;\n  code: string;\n  value?: unknown;\n}\n\n/** 验证结果 */\nexport type ValidationResult<T = unknown> =\n  | { success: true; data: T }\n  | { success: false; errors: ValidationError[] };\n\n// ============== 缓存 ==============\n\n/** 编译器缓存 - WeakMap 避免内存泄漏 */\nconst compilerCache = new WeakMap<TSchema, TypeCheck<TSchema>>();\n\n// ============== 核心函数 ==============\n\n/**\n * 获取或创建编译后的验证器\n */\nfunction getCompiledValidator<T extends TSchema>(schema: T): TypeCheck<T> {\n  let compiler = compilerCache.get(schema);\n  if (!compiler) {\n    compiler = TypeCompiler.Compile(schema);\n    compilerCache.set(schema, compiler);\n  }\n  return compiler as TypeCheck<T>;\n}\n\n/**\n * 验证单个 Schema（返回结果对象）\n */\nexport function validateSchema<T extends TSchema>(\n  schema: T,\n  data: unknown,\n): ValidationResult<Static<T>> {\n  try {\n    const compiler = getCompiledValidator(schema);\n\n    if (compiler.Check(data)) {\n      return { success: true, data: data as Static<T> };\n    }\n\n    // 收集错误\n    const errors: ValidationError[] = [];\n    for (const error of compiler.Errors(data)) {\n      errors.push({\n        path: error.path,\n        message: error.message,\n        code: \"VALIDATION_FAILED\",\n        value: error.value,\n      });\n    }\n    return { success: false, errors };\n  } catch (error) {\n    return {\n      success: false,\n      errors: [\n        {\n          path: \"\",\n          message: error instanceof Error ? error.message : \"验证异常\",\n          code: \"VALIDATION_EXCEPTION\",\n        },\n      ],\n    };\n  }\n}\n\n/**\n * 验证 Schema（抛出异常版本，用于框架内部）\n */\nexport function validateSchemaOrThrow<T extends TSchema>(\n  schema: T,\n  data: unknown,\n  context: string,\n): Static<T> {\n  const compiler = getCompiledValidator(schema);\n\n  if (!compiler.Check(data)) {\n    throw new Error(`${context}验证失败`);\n  }\n\n  return data as Static<T>;\n}\n\n/**\n * 快速验证（只返回布尔值）\n */\nexport function validateFast<T extends TSchema>(\n  schema: T,\n  data: unknown,\n): data is Static<T> {\n  const compiler = getCompiledValidator(schema);\n  return compiler.Check(data);\n}\n\n/**\n * 批量验证所有 Schema（用于请求验证）\n */\nexport function validateAllSchemas(\n  config: SchemaConfig,\n  data: {\n    body: unknown;\n    query: unknown;\n    params: unknown;\n    headers: unknown;\n    cookies: unknown;\n  },\n): typeof data {\n  if (config.body) {\n    validateSchemaOrThrow(config.body, data.body, \"请求体\");\n  }\n  if (config.query) {\n    validateSchemaOrThrow(config.query, data.query, \"Query参数\");\n  }\n  if (config.params) {\n    validateSchemaOrThrow(config.params, data.params, \"路径参数\");\n  }\n  if (config.headers) {\n    validateSchemaOrThrow(config.headers, data.headers, \"请求头\");\n  }\n  if (config.cookies) {\n    validateSchemaOrThrow(config.cookies, data.cookies, \"Cookie\");\n  }\n  return data;\n}\n\n/**\n * 预编译 Schema（启动时调用，避免首次请求开销）\n */\nexport function precompileSchemas(config: SchemaConfig): void {\n  if (config.body) getCompiledValidator(config.body);\n  if (config.query) getCompiledValidator(config.query);\n  if (config.params) getCompiledValidator(config.params);\n  if (config.headers) getCompiledValidator(config.headers);\n  if (config.cookies) getCompiledValidator(config.cookies);\n}\n\n/**\n * 创建类型特化的验证器（高频使用场景）\n */\nexport function createValidator<T extends TSchema>(\n  schema: T,\n): (data: unknown) => ValidationResult<Static<T>> {\n  return (data: unknown) => validateSchema(schema, data);\n}\n\n/**\n * 获取缓存统计（调试用）\n */\nexport function getValidatorCacheStats(): { cacheType: string; note: string } {\n  return {\n    cacheType: \"WeakMap\",\n    note: \"WeakMap 缓存会随 Schema 对象自动清理，无内存泄漏风险\",\n  };\n}\n\n// 导出 TypeBox 类型\nexport { Type, Static, TSchema };\n","// src/parsers.ts\nimport qs from \"qs\";\nimport cookie from \"cookie\";\n\n// 文件信息接口\nexport interface FileInfo {\n  name: string;\n  type: string;\n  size: number;\n  data: ArrayBuffer;\n}\n\n// 表单数据接口\nexport interface FormData {\n  fields: Record<string, string>;\n  files: Record<string, FileInfo>;\n}\n\n/**\n * 简化的请求体解析函数\n * 优先简洁性，处理最常见的场景\n */\nexport async function parseBody(req: Request): Promise<unknown> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n  if (contentType.includes(\"application/json\")) {\n    return await req.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const text = await req.text();\n    return Object.fromEntries(new URLSearchParams(text));\n  }\n  return await req.text(); // fallback\n}\n\n/**\n * 解析 multipart/form-data 格式\n * 支持文件上传和普通表单字段\n */\nasync function parseMultipartFormData(req: Request): Promise<FormData> {\n  const formData = await req.formData();\n  const result: FormData = {\n    fields: {},\n    files: {},\n  };\n\n  for (const [key, value] of formData.entries()) {\n    if (\n      typeof value === \"object\" &&\n      value !== null &&\n      \"name\" in value &&\n      \"type\" in value &&\n      \"size\" in value\n    ) {\n      // 处理文件\n      const file = value as any;\n      const arrayBuffer = await file.arrayBuffer();\n      result.files[key] = {\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        data: arrayBuffer,\n      };\n    } else {\n      // 处理普通字段\n      result.fields[key] = value as string;\n    }\n  }\n\n  return result;\n}\n\n/**\n * 解析请求体为特定类型\n * 提供类型安全的解析方法\n */\nexport async function parseBodyAs<T>(req: Request): Promise<T> {\n  const body = await parseBody(req);\n  return body as T;\n}\n\n/**\n * 解析请求体为表单数据\n * 专门用于处理 multipart/form-data\n */\nexport async function parseFormData(req: Request): Promise<FormData> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n\n  if (!contentType.includes(\"multipart/form-data\")) {\n    throw new Error(\"请求不是 multipart/form-data 格式\");\n  }\n\n  return await parseMultipartFormData(req);\n}\n\n/**\n * 解析请求体为文件\n * 专门用于处理文件上传\n */\nexport async function parseFile(req: Request): Promise<FileInfo> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n\n  if (!contentType.includes(\"multipart/form-data\")) {\n    throw new Error(\"请求不是 multipart/form-data 格式\");\n  }\n\n  const formData = await parseMultipartFormData(req);\n  const fileKeys = Object.keys(formData.files);\n\n  if (fileKeys.length === 0) {\n    throw new Error(\"请求中没有文件\");\n  }\n\n  if (fileKeys.length > 1) {\n    throw new Error(\"请求中包含多个文件，请使用 parseFormData\");\n  }\n\n  return formData.files[fileKeys[0]];\n}\n\n/**\n * 快速提取 query string（避免创建 URL 对象）\n */\nfunction extractQueryString(url: string): string {\n  const qIndex = url.indexOf(\"?\");\n  if (qIndex === -1) return \"\";\n\n  const hashIndex = url.indexOf(\"#\", qIndex);\n  return hashIndex === -1\n    ? url.substring(qIndex + 1)\n    : url.substring(qIndex + 1, hashIndex);\n}\n\n/** 获取查询字符串，直接返回对象 */\nexport function parseQuery(req: Request): Record<string, unknown> {\n  const queryString = extractQueryString(req.url);\n  if (!queryString) return {};\n  return qs.parse(queryString);\n}\n\n/**\n * 快速解析简单查询字符串（不支持嵌套，但更快）\n * 适用于简单的 key=value&key2=value2 场景\n */\nexport function parseQueryFast(req: Request): Record<string, string> {\n  const queryString = extractQueryString(req.url);\n  if (!queryString) return {};\n\n  const result: Record<string, string> = Object.create(null);\n  const pairs = queryString.split(\"&\");\n\n  for (const pair of pairs) {\n    const eqIndex = pair.indexOf(\"=\");\n    if (eqIndex === -1) {\n      result[decodeURIComponent(pair)] = \"\";\n    } else {\n      const key = decodeURIComponent(pair.substring(0, eqIndex));\n      const value = decodeURIComponent(pair.substring(eqIndex + 1));\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\n/** 解析请求头，返回对象 */\nexport function parseHeaders(req: Request): Record<string, string> {\n  const headers: Record<string, string> = Object.create(null);\n  req.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n/**\n * 获取单个请求头（避免解析全部）\n */\nexport function getHeader(req: Request, name: string): string | null {\n  return req.headers.get(name);\n}\n\n/** 使用cookie库解析Cookie，保证可靠性 */\nexport function parseCookies(req: Request): Record<string, string> {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return {};\n\n  try {\n    const parsed = cookie.parse(cookieHeader);\n    // 过滤掉undefined和null值\n    const result: Record<string, string> = {};\n    for (const [key, value] of Object.entries(parsed)) {\n      if (value !== undefined && value !== null) {\n        result[key] = value;\n      }\n    }\n    return result;\n  } catch {\n    return {};\n  }\n}\n\n/**\n * 快速解析 Cookie（简化版，不使用外部库）\n * 适用于简单的 cookie 场景\n */\nexport function parseCookiesFast(req: Request): Record<string, string> {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return {};\n\n  const result: Record<string, string> = Object.create(null);\n  const pairs = cookieHeader.split(\";\");\n\n  for (const pair of pairs) {\n    const trimmed = pair.trim();\n    const eqIndex = trimmed.indexOf(\"=\");\n    if (eqIndex > 0) {\n      const key = trimmed.substring(0, eqIndex).trim();\n      const value = trimmed.substring(eqIndex + 1).trim();\n      // 移除引号\n      result[key] =\n        value.startsWith('\"') && value.endsWith('\"')\n          ? value.slice(1, -1)\n          : value;\n    }\n  }\n\n  return result;\n}\n\n/**\n * 获取单个 Cookie 值（避免解析全部）\n */\nexport function getCookie(req: Request, name: string): string | null {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return null;\n\n  const prefix = `${name}=`;\n  const pairs = cookieHeader.split(\";\");\n\n  for (const pair of pairs) {\n    const trimmed = pair.trim();\n    if (trimmed.startsWith(prefix)) {\n      const value = trimmed.substring(prefix.length).trim();\n      return value.startsWith('\"') && value.endsWith('\"')\n        ? value.slice(1, -1)\n        : value;\n    }\n  }\n\n  return null;\n}\n","/**\n * 请求解析和验证器\n *\n * 解析handler的req参数，使用Ultra验证器进行验证，\n * 并类型安全地返回解析出来的值\n *\n * @author Framework Team\n * @version 1.0.0\n * @license MIT\n */\n\nimport type { TSchema } from \"@sinclair/typebox\";\nimport type { Static } from \"@sinclair/typebox\";\nimport {\n  validateAllSchemas,\n  type SchemaConfig,\n} from \"./validators/validators\";\nimport { parseBody, parseQuery, parseHeaders, parseCookies } from \"./parsers\";\n\n// 请求数据结构\nexport interface RequestData {\n  body: unknown;\n  query: unknown;\n  params: Record<string, string>;\n  headers: Record<string, string>;\n  cookies: Record<string, string>;\n}\n\n// 验证后的请求数据类型\nexport interface ValidatedRequestData<T extends SchemaConfig> {\n  body: T[\"body\"] extends TSchema ? Static<T[\"body\"]> : unknown;\n  query: T[\"query\"] extends TSchema ? Static<T[\"query\"]> : unknown;\n  params: T[\"params\"] extends TSchema\n    ? Static<T[\"params\"]>\n    : Record<string, string>;\n  headers: T[\"headers\"] extends TSchema\n    ? Static<T[\"headers\"]>\n    : Record<string, string>;\n  cookies: T[\"cookies\"] extends TSchema\n    ? Static<T[\"cookies\"]>\n    : Record<string, string>;\n}\n\n// 验证结果\nexport interface ValidationResult<T extends SchemaConfig> {\n  success: boolean;\n  data?: ValidatedRequestData<T>;\n  errors?: Array<{ field: keyof SchemaConfig; message: string }>;\n}\n\n/**\n * 解析Request对象，提取所有相关数据\n * @param request Request对象\n * @param params 路径参数（可选）\n * @returns 解析后的请求数据\n */\nexport async function parseRequest(\n  request: Request,\n  params?: Record<string, string>,\n): Promise<RequestData> {\n  const requestData: RequestData = {\n    body: undefined,\n    query: parseQuery(request),\n    params: params || {},\n    headers: parseHeaders(request),\n    cookies: parseCookies(request),\n  };\n\n  // 对于非GET请求，尝试解析请求体\n  if (request.method !== \"GET\" && request.method !== \"HEAD\") {\n    requestData.body = await parseBody(request);\n  }\n\n  return requestData;\n}\n\n/**\n * 验证请求数据\n * @param config Schema配置\n * @param requestData 请求数据\n * @returns 验证结果\n */\nexport function validateRequest<T extends SchemaConfig>(\n  config: T,\n  requestData: RequestData,\n): ValidationResult<T> {\n  try {\n    const validatedData = validateAllSchemas(config, requestData);\n\n    return {\n      success: true,\n      data: validatedData as ValidatedRequestData<T>,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      errors: [\n        {\n          field: \"unknown\" as keyof SchemaConfig,\n          message: error instanceof Error ? error.message : \"验证失败\",\n        },\n      ],\n    };\n  }\n}\n\n/**\n * 完整的请求解析和验证流程\n * @param request Request对象\n * @param config Schema配置\n * @param params 路径参数（可选）\n * @returns 验证结果\n */\nexport async function parseAndValidateRequest<T extends SchemaConfig>(\n  request: Request,\n  config: T,\n  params?: Record<string, string>,\n): Promise<ValidationResult<T>> {\n  try {\n    // 1. 解析请求\n    const requestData = await parseRequest(request, params);\n\n    // 2. 验证数据\n    return validateRequest(config, requestData);\n  } catch (error) {\n    return {\n      success: false,\n      errors: [\n        {\n          field: \"unknown\" as keyof SchemaConfig,\n          message: error instanceof Error ? error.message : \"请求解析失败\",\n        },\n      ],\n    };\n  }\n}\n\n/**\n * 创建类型安全的请求验证器工厂\n * @param config Schema配置\n * @returns 验证器函数\n */\nexport function createRequestValidator<T extends SchemaConfig>(config: T) {\n  return async (request: Request, params?: Record<string, string>) => {\n    return parseAndValidateRequest(request, config, params);\n  };\n}\n"],"mappings":"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","names":[]}