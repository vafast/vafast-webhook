// src/utils/parsers.ts
import qs from "qs";
import cookie from "cookie";
async function parseBody(req) {
  const contentType = req.headers.get("content-type") || "";
  if (contentType.includes("application/json")) {
    return await req.json();
  }
  if (contentType.includes("application/x-www-form-urlencoded")) {
    const text = await req.text();
    return Object.fromEntries(new URLSearchParams(text));
  }
  return await req.text();
}
function extractQueryString(url) {
  const qIndex = url.indexOf("?");
  if (qIndex === -1) return "";
  const hashIndex = url.indexOf("#", qIndex);
  return hashIndex === -1 ? url.substring(qIndex + 1) : url.substring(qIndex + 1, hashIndex);
}
function parseQuery(req) {
  const queryString = extractQueryString(req.url);
  if (!queryString) return {};
  return qs.parse(queryString);
}
function parseHeaders(req) {
  const headers = /* @__PURE__ */ Object.create(null);
  req.headers.forEach((value, key) => {
    headers[key] = value;
  });
  return headers;
}
function parseCookies(req) {
  const cookieHeader = req.headers.get("cookie");
  if (!cookieHeader) return {};
  try {
    const parsed = cookie.parse(cookieHeader);
    const result = {};
    for (const [key, value] of Object.entries(parsed)) {
      if (value !== void 0 && value !== null) {
        result[key] = value;
      }
    }
    return result;
  } catch {
    return {};
  }
}

// src/utils/go-await.ts
function goAwait(promise) {
  return promise.then((data) => [null, data]).catch((err) => [err instanceof Error ? err : new Error(String(err)), void 0]);
}

// src/utils/response.ts
function json(data, status = 200, headers = {}) {
  const body = JSON.stringify(data);
  if (Object.keys(headers).length === 0) {
    return new Response(body, {
      status,
      headers: { "Content-Type": "application/json" }
    });
  }
  const h = new Headers({
    "Content-Type": "application/json",
    ...headers
  });
  return new Response(body, {
    status,
    headers: h
  });
}

// src/utils/validators/validators.ts
import { Type } from "@sinclair/typebox";
import { TypeCompiler } from "@sinclair/typebox/compiler";
var compilerCache = /* @__PURE__ */ new WeakMap();
function getCompiledValidator(schema) {
  let compiler = compilerCache.get(schema);
  if (!compiler) {
    compiler = TypeCompiler.Compile(schema);
    compilerCache.set(schema, compiler);
  }
  return compiler;
}
function validateSchemaOrThrow(schema, data, context) {
  const compiler = getCompiledValidator(schema);
  if (!compiler.Check(data)) {
    throw new Error(`${context}\u9A8C\u8BC1\u5931\u8D25`);
  }
  return data;
}
function validateAllSchemas(config, data) {
  if (config.body) {
    validateSchemaOrThrow(config.body, data.body, "\u8BF7\u6C42\u4F53");
  }
  if (config.query) {
    validateSchemaOrThrow(config.query, data.query, "Query\u53C2\u6570");
  }
  if (config.params) {
    validateSchemaOrThrow(config.params, data.params, "\u8DEF\u5F84\u53C2\u6570");
  }
  if (config.headers) {
    validateSchemaOrThrow(config.headers, data.headers, "\u8BF7\u6C42\u5934");
  }
  if (config.cookies) {
    validateSchemaOrThrow(config.cookies, data.cookies, "Cookie");
  }
  return data;
}
function precompileSchemas(config) {
  if (config.body) getCompiledValidator(config.body);
  if (config.query) getCompiledValidator(config.query);
  if (config.params) getCompiledValidator(config.params);
  if (config.headers) getCompiledValidator(config.headers);
  if (config.cookies) getCompiledValidator(config.cookies);
}

// src/utils/create-handler.ts
function autoResponse(result) {
  if (result instanceof Response) {
    return result;
  }
  if (result === null || result === void 0) {
    return new Response(null, { status: 204 });
  }
  if (typeof result === "string") {
    return new Response(result, {
      headers: { "Content-Type": "text/plain; charset=utf-8" }
    });
  }
  if (typeof result === "number" || typeof result === "boolean") {
    return new Response(String(result), {
      headers: { "Content-Type": "text/plain; charset=utf-8" }
    });
  }
  if (typeof result === "object") {
    const obj = result;
    if ("data" in obj && ("status" in obj || "headers" in obj)) {
      const { data, status = 200, headers = {} } = obj;
      if (data === null || data === void 0) {
        return new Response(null, {
          status: status === 200 ? 204 : status,
          headers
        });
      }
      if (typeof data === "string" || typeof data === "number" || typeof data === "boolean") {
        return new Response(String(data), {
          status,
          headers: {
            "Content-Type": "text/plain; charset=utf-8",
            ...headers
          }
        });
      }
      return json(data, status, headers);
    }
    return json(result);
  }
  return new Response(null, { status: 204 });
}
function handleValidationError(error) {
  return json(
    {
      success: false,
      error: "Validation Error",
      message: error.message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    },
    400
  );
}
function handleInternalError(error) {
  return json(
    {
      success: false,
      error: "Internal Error",
      message: error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF"
    },
    500
  );
}
function isHandler(value) {
  return typeof value === "function";
}
function createHandler(schemaOrHandler, maybeHandler) {
  const hasSchema = !isHandler(schemaOrHandler);
  const schema = hasSchema ? schemaOrHandler : {};
  const handler = hasSchema ? maybeHandler : schemaOrHandler;
  if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
    precompileSchemas(schema);
  }
  const handlerFn = async (req) => {
    try {
      const query = parseQuery(req);
      const headers = parseHeaders(req);
      const cookies = parseCookies(req);
      const params = req.params || {};
      let body = void 0;
      if (req.method !== "GET" && req.method !== "HEAD") {
        const [, parsedBody] = await goAwait(parseBody(req));
        body = parsedBody;
      }
      const data = { body, query, params, headers, cookies };
      if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
        validateAllSchemas(schema, data);
      }
      const result = await handler({
        req,
        body,
        query,
        params,
        headers,
        cookies
      });
      return autoResponse(result);
    } catch (error) {
      if (error instanceof Error && error.message.includes("\u9A8C\u8BC1\u5931\u8D25")) {
        return handleValidationError(error);
      }
      return handleInternalError(error);
    }
  };
  return handlerFn;
}
function createHandlerWithExtra(schemaOrHandler, maybeHandler) {
  const hasSchema = !isHandler(schemaOrHandler);
  const schema = hasSchema ? schemaOrHandler : {};
  const handler = hasSchema ? maybeHandler : schemaOrHandler;
  if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
    precompileSchemas(schema);
  }
  return async (req) => {
    try {
      const query = parseQuery(req);
      const headers = parseHeaders(req);
      const cookies = parseCookies(req);
      const params = req.params || {};
      let body = void 0;
      if (req.method !== "GET" && req.method !== "HEAD") {
        const [, parsedBody] = await goAwait(parseBody(req));
        body = parsedBody;
      }
      const data = { body, query, params, headers, cookies };
      if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
        validateAllSchemas(schema, data);
      }
      const extras = req.__locals ?? {};
      const result = await handler({
        req,
        body,
        query,
        params,
        headers,
        cookies,
        ...extras
      });
      return autoResponse(result);
    } catch (error) {
      if (error instanceof Error && error.message.includes("\u9A8C\u8BC1\u5931\u8D25")) {
        return handleValidationError(error);
      }
      return handleInternalError(error);
    }
  };
}
function simpleHandler(handler) {
  return async (req) => {
    try {
      const result = await handler({ req });
      return autoResponse(result);
    } catch (error) {
      return handleInternalError(error);
    }
  };
}
export {
  createHandler,
  createHandlerWithExtra,
  simpleHandler
};
/**
 * Go 风格的错误处理工具
 * 将 Promise 转换为 [Error | null, T | undefined] 格式
 *
 * @author Framework Team
 * @version 1.0.0
 * @license MIT
 */
/**
 * 类型安全的路由处理器工厂
 *
 * 非柯里化设计，API 更简洁
 *
 * @author Framework Team
 * @version 3.0.0
 * @license MIT
 */
//# sourceMappingURL=create-handler.js.map