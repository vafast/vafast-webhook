{"version":3,"sources":["../../src/utils/parsers.ts","../../src/utils/validators/validators.ts","../../src/utils/sse.ts"],"sourcesContent":["// src/parsers.ts\nimport qs from \"qs\";\nimport cookie from \"cookie\";\n\n// 文件信息接口\nexport interface FileInfo {\n  name: string;\n  type: string;\n  size: number;\n  data: ArrayBuffer;\n}\n\n// 表单数据接口\nexport interface FormData {\n  fields: Record<string, string>;\n  files: Record<string, FileInfo>;\n}\n\n/**\n * 简化的请求体解析函数\n * 优先简洁性，处理最常见的场景\n */\nexport async function parseBody(req: Request): Promise<unknown> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n  if (contentType.includes(\"application/json\")) {\n    return await req.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const text = await req.text();\n    return Object.fromEntries(new URLSearchParams(text));\n  }\n  return await req.text(); // fallback\n}\n\n/**\n * 解析 multipart/form-data 格式\n * 支持文件上传和普通表单字段\n */\nasync function parseMultipartFormData(req: Request): Promise<FormData> {\n  const formData = await req.formData();\n  const result: FormData = {\n    fields: {},\n    files: {},\n  };\n\n  for (const [key, value] of formData.entries()) {\n    if (\n      typeof value === \"object\" &&\n      value !== null &&\n      \"name\" in value &&\n      \"type\" in value &&\n      \"size\" in value\n    ) {\n      // 处理文件\n      const file = value as any;\n      const arrayBuffer = await file.arrayBuffer();\n      result.files[key] = {\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        data: arrayBuffer,\n      };\n    } else {\n      // 处理普通字段\n      result.fields[key] = value as string;\n    }\n  }\n\n  return result;\n}\n\n/**\n * 解析请求体为特定类型\n * 提供类型安全的解析方法\n */\nexport async function parseBodyAs<T>(req: Request): Promise<T> {\n  const body = await parseBody(req);\n  return body as T;\n}\n\n/**\n * 解析请求体为表单数据\n * 专门用于处理 multipart/form-data\n */\nexport async function parseFormData(req: Request): Promise<FormData> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n\n  if (!contentType.includes(\"multipart/form-data\")) {\n    throw new Error(\"请求不是 multipart/form-data 格式\");\n  }\n\n  return await parseMultipartFormData(req);\n}\n\n/**\n * 解析请求体为文件\n * 专门用于处理文件上传\n */\nexport async function parseFile(req: Request): Promise<FileInfo> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n\n  if (!contentType.includes(\"multipart/form-data\")) {\n    throw new Error(\"请求不是 multipart/form-data 格式\");\n  }\n\n  const formData = await parseMultipartFormData(req);\n  const fileKeys = Object.keys(formData.files);\n\n  if (fileKeys.length === 0) {\n    throw new Error(\"请求中没有文件\");\n  }\n\n  if (fileKeys.length > 1) {\n    throw new Error(\"请求中包含多个文件，请使用 parseFormData\");\n  }\n\n  return formData.files[fileKeys[0]];\n}\n\n/**\n * 快速提取 query string（避免创建 URL 对象）\n */\nfunction extractQueryString(url: string): string {\n  const qIndex = url.indexOf(\"?\");\n  if (qIndex === -1) return \"\";\n\n  const hashIndex = url.indexOf(\"#\", qIndex);\n  return hashIndex === -1\n    ? url.substring(qIndex + 1)\n    : url.substring(qIndex + 1, hashIndex);\n}\n\n/** 获取查询字符串，直接返回对象 */\nexport function parseQuery(req: Request): Record<string, unknown> {\n  const queryString = extractQueryString(req.url);\n  if (!queryString) return {};\n  return qs.parse(queryString);\n}\n\n/**\n * 快速解析简单查询字符串（不支持嵌套，但更快）\n * 适用于简单的 key=value&key2=value2 场景\n */\nexport function parseQueryFast(req: Request): Record<string, string> {\n  const queryString = extractQueryString(req.url);\n  if (!queryString) return {};\n\n  const result: Record<string, string> = Object.create(null);\n  const pairs = queryString.split(\"&\");\n\n  for (const pair of pairs) {\n    const eqIndex = pair.indexOf(\"=\");\n    if (eqIndex === -1) {\n      result[decodeURIComponent(pair)] = \"\";\n    } else {\n      const key = decodeURIComponent(pair.substring(0, eqIndex));\n      const value = decodeURIComponent(pair.substring(eqIndex + 1));\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\n/** 解析请求头，返回对象 */\nexport function parseHeaders(req: Request): Record<string, string> {\n  const headers: Record<string, string> = Object.create(null);\n  req.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n/**\n * 获取单个请求头（避免解析全部）\n */\nexport function getHeader(req: Request, name: string): string | null {\n  return req.headers.get(name);\n}\n\n/** 使用cookie库解析Cookie，保证可靠性 */\nexport function parseCookies(req: Request): Record<string, string> {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return {};\n\n  try {\n    const parsed = cookie.parse(cookieHeader);\n    // 过滤掉undefined和null值\n    const result: Record<string, string> = {};\n    for (const [key, value] of Object.entries(parsed)) {\n      if (value !== undefined && value !== null) {\n        result[key] = value;\n      }\n    }\n    return result;\n  } catch {\n    return {};\n  }\n}\n\n/**\n * 快速解析 Cookie（简化版，不使用外部库）\n * 适用于简单的 cookie 场景\n */\nexport function parseCookiesFast(req: Request): Record<string, string> {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return {};\n\n  const result: Record<string, string> = Object.create(null);\n  const pairs = cookieHeader.split(\";\");\n\n  for (const pair of pairs) {\n    const trimmed = pair.trim();\n    const eqIndex = trimmed.indexOf(\"=\");\n    if (eqIndex > 0) {\n      const key = trimmed.substring(0, eqIndex).trim();\n      const value = trimmed.substring(eqIndex + 1).trim();\n      // 移除引号\n      result[key] =\n        value.startsWith('\"') && value.endsWith('\"')\n          ? value.slice(1, -1)\n          : value;\n    }\n  }\n\n  return result;\n}\n\n/**\n * 获取单个 Cookie 值（避免解析全部）\n */\nexport function getCookie(req: Request, name: string): string | null {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return null;\n\n  const prefix = `${name}=`;\n  const pairs = cookieHeader.split(\";\");\n\n  for (const pair of pairs) {\n    const trimmed = pair.trim();\n    if (trimmed.startsWith(prefix)) {\n      const value = trimmed.substring(prefix.length).trim();\n      return value.startsWith('\"') && value.endsWith('\"')\n        ? value.slice(1, -1)\n        : value;\n    }\n  }\n\n  return null;\n}\n","/**\n * Schema 验证器 - 简洁版\n *\n * 特点：\n * - WeakMap 缓存避免内存泄漏\n * - TypeCompiler JIT 编译，性能最佳\n * - 支持 FormatRegistry（需确保同一实例）\n *\n * @version 7.0.0\n */\n\nimport { Type } from \"@sinclair/typebox\";\nimport type { Static, TSchema } from \"@sinclair/typebox\";\nimport { TypeCompiler, type TypeCheck } from \"@sinclair/typebox/compiler\";\nimport { Value } from \"@sinclair/typebox/value\";\n\n// ============== 类型定义 ==============\n\n/** Schema 配置接口 */\nexport interface SchemaConfig {\n  body?: TSchema;\n  query?: TSchema;\n  params?: TSchema;\n  headers?: TSchema;\n  cookies?: TSchema;\n}\n\n/** 验证错误接口 */\nexport interface ValidationError {\n  path: string;\n  message: string;\n  code: string;\n  value?: unknown;\n}\n\n/** 验证结果 */\nexport type ValidationResult<T = unknown> =\n  | { success: true; data: T }\n  | { success: false; errors: ValidationError[] };\n\n// ============== 缓存 ==============\n\n/** 编译器缓存 - WeakMap 避免内存泄漏 */\nconst compilerCache = new WeakMap<TSchema, TypeCheck<TSchema>>();\n\n// ============== 核心函数 ==============\n\n/**\n * 获取或创建编译后的验证器\n */\nfunction getCompiledValidator<T extends TSchema>(schema: T): TypeCheck<T> {\n  let compiler = compilerCache.get(schema);\n  if (!compiler) {\n    compiler = TypeCompiler.Compile(schema);\n    compilerCache.set(schema, compiler);\n  }\n  return compiler as TypeCheck<T>;\n}\n\n/**\n * 验证单个 Schema（返回结果对象）\n */\nexport function validateSchema<T extends TSchema>(\n  schema: T,\n  data: unknown,\n): ValidationResult<Static<T>> {\n  try {\n    const compiler = getCompiledValidator(schema);\n\n    if (compiler.Check(data)) {\n      return { success: true, data: data as Static<T> };\n    }\n\n    // 收集错误\n    const errors: ValidationError[] = [];\n    for (const error of compiler.Errors(data)) {\n      errors.push({\n        path: error.path,\n        message: error.message,\n        code: \"VALIDATION_FAILED\",\n        value: error.value,\n      });\n    }\n    return { success: false, errors };\n  } catch (error) {\n    return {\n      success: false,\n      errors: [\n        {\n          path: \"\",\n          message: error instanceof Error ? error.message : \"验证异常\",\n          code: \"VALIDATION_EXCEPTION\",\n        },\n      ],\n    };\n  }\n}\n\n/**\n * 验证 Schema（抛出异常版本，用于框架内部）\n */\nexport function validateSchemaOrThrow<T extends TSchema>(\n  schema: T,\n  data: unknown,\n  context: string,\n): Static<T> {\n  const compiler = getCompiledValidator(schema);\n\n  if (!compiler.Check(data)) {\n    throw new Error(`${context}验证失败`);\n  }\n\n  return data as Static<T>;\n}\n\n/**\n * 快速验证（只返回布尔值）\n */\nexport function validateFast<T extends TSchema>(\n  schema: T,\n  data: unknown,\n): data is Static<T> {\n  const compiler = getCompiledValidator(schema);\n  return compiler.Check(data);\n}\n\n/**\n * 批量验证所有 Schema（用于请求验证）\n */\nexport function validateAllSchemas(\n  config: SchemaConfig,\n  data: {\n    body: unknown;\n    query: unknown;\n    params: unknown;\n    headers: unknown;\n    cookies: unknown;\n  },\n): typeof data {\n  if (config.body) {\n    validateSchemaOrThrow(config.body, data.body, \"请求体\");\n  }\n  if (config.query) {\n    validateSchemaOrThrow(config.query, data.query, \"Query参数\");\n  }\n  if (config.params) {\n    validateSchemaOrThrow(config.params, data.params, \"路径参数\");\n  }\n  if (config.headers) {\n    validateSchemaOrThrow(config.headers, data.headers, \"请求头\");\n  }\n  if (config.cookies) {\n    validateSchemaOrThrow(config.cookies, data.cookies, \"Cookie\");\n  }\n  return data;\n}\n\n/**\n * 预编译 Schema（启动时调用，避免首次请求开销）\n */\nexport function precompileSchemas(config: SchemaConfig): void {\n  if (config.body) getCompiledValidator(config.body);\n  if (config.query) getCompiledValidator(config.query);\n  if (config.params) getCompiledValidator(config.params);\n  if (config.headers) getCompiledValidator(config.headers);\n  if (config.cookies) getCompiledValidator(config.cookies);\n}\n\n/**\n * 创建类型特化的验证器（高频使用场景）\n */\nexport function createValidator<T extends TSchema>(\n  schema: T,\n): (data: unknown) => ValidationResult<Static<T>> {\n  return (data: unknown) => validateSchema(schema, data);\n}\n\n/**\n * 获取缓存统计（调试用）\n */\nexport function getValidatorCacheStats(): { cacheType: string; note: string } {\n  return {\n    cacheType: \"WeakMap\",\n    note: \"WeakMap 缓存会随 Schema 对象自动清理，无内存泄漏风险\",\n  };\n}\n\n// 导出 TypeBox 类型\nexport { Type, Static, TSchema };\n","/**\n * Server-Sent Events (SSE) 支持\n *\n * 用于实现流式响应，如 AI 聊天、实时通知等\n *\n * @example\n * ```typescript\n * import { createSSEHandler, Type } from 'vafast'\n *\n * const streamHandler = createSSEHandler(\n *   { query: Type.Object({ prompt: Type.String() }) },\n *   async function* ({ query }) {\n *     yield { event: 'start', data: { message: 'Starting...' } }\n *\n *     for await (const chunk of aiStream(query.prompt)) {\n *       yield { data: chunk }\n *     }\n *\n *     yield { event: 'end', data: { message: 'Done!' } }\n *   }\n * )\n * ```\n */\n\nimport type { RouteSchema, HandlerContext } from \"../types/schema\";\nimport { parseQuery, parseHeaders, parseCookies } from \"./parsers\";\nimport { precompileSchemas, validateAllSchemas } from \"./validators/validators\";\n\n/**\n * SSE 事件类型\n */\nexport interface SSEEvent<T = unknown> {\n  /** 事件名称（可选，默认为 message） */\n  event?: string;\n  /** 事件数据 */\n  data: T;\n  /** 事件 ID（可选） */\n  id?: string;\n  /** 重试间隔（毫秒，可选） */\n  retry?: number;\n}\n\n/**\n * SSE 生成器函数类型\n */\nexport type SSEGenerator<T extends RouteSchema = RouteSchema> = (\n  ctx: HandlerContext<T>\n) => AsyncGenerator<SSEEvent<unknown>, void, unknown>;\n\n/**\n * 格式化 SSE 事件为字符串\n */\nfunction formatSSEEvent(event: SSEEvent): string {\n  const lines: string[] = [];\n\n  if (event.id !== undefined) {\n    lines.push(`id: ${event.id}`);\n  }\n\n  if (event.event !== undefined) {\n    lines.push(`event: ${event.event}`);\n  }\n\n  if (event.retry !== undefined) {\n    lines.push(`retry: ${event.retry}`);\n  }\n\n  // 数据可能是多行的，需要分行处理\n  const dataStr = typeof event.data === 'string'\n    ? event.data\n    : JSON.stringify(event.data);\n\n  const dataLines = dataStr.split('\\n');\n  for (const line of dataLines) {\n    lines.push(`data: ${line}`);\n  }\n\n  return lines.join('\\n') + '\\n\\n';\n}\n\n/**\n * SSE 标记类型 - 使用字面量品牌类型\n */\nexport type SSEMarker = { readonly __brand: 'SSE' }\n\n/**\n * SSE Handler 类型标记\n */\nexport interface SSEHandler<TSchema extends RouteSchema = RouteSchema> {\n  (req: Request): Promise<Response>;\n  /** 返回类型标记 - SSE 流的数据类型 */\n  readonly __returnType: unknown;\n  /** Schema 类型标记 */\n  readonly __schema: TSchema;\n  /** SSE 标记 - 使用品牌类型确保不被扩展 */\n  readonly __sse: SSEMarker;\n}\n\n/**\n * 创建 SSE 流式响应处理器\n *\n * @example\n * ```typescript\n * // 基础用法\n * const streamChat = createSSEHandler(\n *   { query: Type.Object({ message: Type.String() }) },\n *   async function* ({ query }) {\n *     const response = await ai.chat(query.message);\n *\n *     for await (const chunk of response) {\n *       yield { data: { text: chunk } };\n *     }\n *   }\n * );\n *\n * // 使用路由\n * route('GET', '/chat/stream', streamChat)\n * ```\n */\nexport function createSSEHandler<const T extends RouteSchema>(\n  schema: T,\n  generator: SSEGenerator<T>\n): SSEHandler<T>;\n\nexport function createSSEHandler(\n  generator: SSEGenerator<RouteSchema>\n): SSEHandler<RouteSchema>;\n\nexport function createSSEHandler<const T extends RouteSchema>(\n  schemaOrGenerator: T | SSEGenerator<T>,\n  maybeGenerator?: SSEGenerator<T>\n): SSEHandler<T> {\n  // 判断调用方式\n  const hasSchema = typeof schemaOrGenerator !== 'function';\n  const schema = hasSchema ? (schemaOrGenerator as T) : ({} as T);\n  const generator = hasSchema\n    ? maybeGenerator!\n    : (schemaOrGenerator as SSEGenerator<T>);\n\n  // 预编译 schema\n  if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {\n    precompileSchemas(schema);\n  }\n\n  const handlerFn = async (req: Request): Promise<Response> => {\n    try {\n      // 解析请求数据\n      const query = parseQuery(req);\n      const headers = parseHeaders(req);\n      const cookies = parseCookies(req);\n      const params = ((req as unknown as Record<string, unknown>).params as Record<string, string>) || {};\n\n      // 验证 schema\n      const data = { body: undefined, query, params, headers, cookies };\n      if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {\n        validateAllSchemas(schema, data);\n      }\n\n      // 创建 SSE 流\n      const stream = new ReadableStream({\n        async start(controller) {\n          const encoder = new TextEncoder();\n\n          try {\n            const gen = generator({\n              req,\n              body: undefined as HandlerContext<T>['body'],\n              query: query as HandlerContext<T>['query'],\n              params: params as HandlerContext<T>['params'],\n              headers: headers as HandlerContext<T>['headers'],\n              cookies: cookies as HandlerContext<T>['cookies'],\n            });\n\n            for await (const event of gen) {\n              const formatted = formatSSEEvent(event);\n              controller.enqueue(encoder.encode(formatted));\n            }\n          } catch (error) {\n            // 发送错误事件\n            const errorEvent = formatSSEEvent({\n              event: 'error',\n              data: {\n                message: error instanceof Error ? error.message : 'Unknown error'\n              }\n            });\n            controller.enqueue(encoder.encode(errorEvent));\n          } finally {\n            controller.close();\n          }\n        }\n      });\n\n      return new Response(stream, {\n        headers: {\n          'Content-Type': 'text/event-stream',\n          'Cache-Control': 'no-cache',\n          'Connection': 'keep-alive',\n          'X-Accel-Buffering': 'no', // Nginx 禁用缓冲\n        }\n      });\n    } catch (error) {\n      // 验证错误等\n      return new Response(\n        JSON.stringify({\n          success: false,\n          error: 'Validation Error',\n          message: error instanceof Error ? error.message : 'Unknown error'\n        }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' }\n        }\n      );\n    }\n  };\n\n  // 添加类型标记\n  const handler = handlerFn as SSEHandler<T>;\n  (handler as unknown as { __sse: SSEMarker }).__sse = { __brand: 'SSE' } as const;\n  (handler as unknown as { __schema: T }).__schema = schema;\n  (handler as unknown as { __returnType: unknown }).__returnType = undefined;\n  return handler;\n}\n\n\n"],"mappings":"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","names":[]}