{"version":3,"sources":["../../src/utils/path-matcher.ts"],"sourcesContent":["/**\n * 路径匹配工具类\n * 提供统一的路径匹配和参数提取功能\n */\nexport class PathMatcher {\n  /**\n   * 路径匹配\n   */\n  static matchPath(pattern: string, path: string): boolean {\n    const patternParts = pattern.split(\"/\").filter(Boolean);\n    const pathParts = path.split(\"/\").filter(Boolean);\n\n    if (patternParts.length !== pathParts.length) {\n      return false;\n    }\n\n    for (let i = 0; i < patternParts.length; i++) {\n      if (\n        patternParts[i] !== pathParts[i] &&\n        !patternParts[i].startsWith(\":\")\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * 提取路径参数\n   */\n  static extractParams(pattern: string, path: string): Record<string, string> {\n    const params: Record<string, string> = {};\n    const patternParts = pattern.split(\"/\").filter(Boolean);\n    const pathParts = path.split(\"/\").filter(Boolean);\n\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(\":\")) {\n        const paramName = patternParts[i].slice(1);\n        params[paramName] = pathParts[i];\n      }\n    }\n\n    return params;\n  }\n\n  /**\n   * 计算路径特异性分数\n   * 用于路由排序：静态 > 动态(:param) > 通配符(*)\n   */\n  static calculatePathScore(path: string): number {\n    const parts = path.split(\"/\").filter(Boolean);\n    let score = 0;\n    for (const p of parts) {\n      if (p === \"*\")\n        score += 1; // 最弱\n      else if (p.startsWith(\":\"))\n        score += 2; // 中等\n      else score += 3; // 静态最强\n    }\n    // 更长的路径更具体，略微提升\n    return score * 10 + parts.length;\n  }\n\n  /**\n   * 判断两个路径是否可能冲突\n   */\n  static pathsMayConflict(path1: string, path2: string): boolean {\n    const parts1 = path1.split(\"/\").filter(Boolean);\n    const parts2 = path2.split(\"/\").filter(Boolean);\n\n    if (parts1.length !== parts2.length) return false;\n\n    for (let i = 0; i < parts1.length; i++) {\n      const p1 = parts1[i];\n      const p2 = parts2[i];\n\n      // 如果两个部分都是静态的且不同，则不会冲突\n      if (\n        !p1.startsWith(\":\") &&\n        !p1.startsWith(\"*\") &&\n        !p2.startsWith(\":\") &&\n        !p2.startsWith(\"*\") &&\n        p1 !== p2\n      ) {\n        return false;\n      }\n\n      // 如果一个是通配符，另一个是动态参数，可能冲突\n      if (\n        (p1 === \"*\" && p2.startsWith(\":\")) ||\n        (p2 === \"*\" && p1.startsWith(\":\"))\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n"],"mappings":";AAIO,IAAM,cAAN,MAAkB;AAAA;AAAA;AAAA;AAAA,EAIvB,OAAO,UAAU,SAAiB,MAAuB;AACvD,UAAM,eAAe,QAAQ,MAAM,GAAG,EAAE,OAAO,OAAO;AACtD,UAAM,YAAY,KAAK,MAAM,GAAG,EAAE,OAAO,OAAO;AAEhD,QAAI,aAAa,WAAW,UAAU,QAAQ;AAC5C,aAAO;AAAA,IACT;AAEA,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,UACE,aAAa,CAAC,MAAM,UAAU,CAAC,KAC/B,CAAC,aAAa,CAAC,EAAE,WAAW,GAAG,GAC/B;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,cAAc,SAAiB,MAAsC;AAC1E,UAAM,SAAiC,CAAC;AACxC,UAAM,eAAe,QAAQ,MAAM,GAAG,EAAE,OAAO,OAAO;AACtD,UAAM,YAAY,KAAK,MAAM,GAAG,EAAE,OAAO,OAAO;AAEhD,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,UAAI,aAAa,CAAC,EAAE,WAAW,GAAG,GAAG;AACnC,cAAM,YAAY,aAAa,CAAC,EAAE,MAAM,CAAC;AACzC,eAAO,SAAS,IAAI,UAAU,CAAC;AAAA,MACjC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,mBAAmB,MAAsB;AAC9C,UAAM,QAAQ,KAAK,MAAM,GAAG,EAAE,OAAO,OAAO;AAC5C,QAAI,QAAQ;AACZ,eAAW,KAAK,OAAO;AACrB,UAAI,MAAM;AACR,iBAAS;AAAA,eACF,EAAE,WAAW,GAAG;AACvB,iBAAS;AAAA,UACN,UAAS;AAAA,IAChB;AAEA,WAAO,QAAQ,KAAK,MAAM;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,iBAAiB,OAAe,OAAwB;AAC7D,UAAM,SAAS,MAAM,MAAM,GAAG,EAAE,OAAO,OAAO;AAC9C,UAAM,SAAS,MAAM,MAAM,GAAG,EAAE,OAAO,OAAO;AAE9C,QAAI,OAAO,WAAW,OAAO,OAAQ,QAAO;AAE5C,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,YAAM,KAAK,OAAO,CAAC;AACnB,YAAM,KAAK,OAAO,CAAC;AAGnB,UACE,CAAC,GAAG,WAAW,GAAG,KAClB,CAAC,GAAG,WAAW,GAAG,KAClB,CAAC,GAAG,WAAW,GAAG,KAClB,CAAC,GAAG,WAAW,GAAG,KAClB,OAAO,IACP;AACA,eAAO;AAAA,MACT;AAGA,UACG,OAAO,OAAO,GAAG,WAAW,GAAG,KAC/B,OAAO,OAAO,GAAG,WAAW,GAAG,GAChC;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;","names":[]}