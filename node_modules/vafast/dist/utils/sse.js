// src/utils/parsers.ts
import qs from "qs";
import cookie from "cookie";
function extractQueryString(url) {
  const qIndex = url.indexOf("?");
  if (qIndex === -1) return "";
  const hashIndex = url.indexOf("#", qIndex);
  return hashIndex === -1 ? url.substring(qIndex + 1) : url.substring(qIndex + 1, hashIndex);
}
function parseQuery(req) {
  const queryString = extractQueryString(req.url);
  if (!queryString) return {};
  return qs.parse(queryString);
}
function parseHeaders(req) {
  const headers = /* @__PURE__ */ Object.create(null);
  req.headers.forEach((value, key) => {
    headers[key] = value;
  });
  return headers;
}
function parseCookies(req) {
  const cookieHeader = req.headers.get("cookie");
  if (!cookieHeader) return {};
  try {
    const parsed = cookie.parse(cookieHeader);
    const result = {};
    for (const [key, value] of Object.entries(parsed)) {
      if (value !== void 0 && value !== null) {
        result[key] = value;
      }
    }
    return result;
  } catch {
    return {};
  }
}

// src/utils/validators/validators.ts
import { Type } from "@sinclair/typebox";
import { TypeCompiler } from "@sinclair/typebox/compiler";
var compilerCache = /* @__PURE__ */ new WeakMap();
function getCompiledValidator(schema) {
  let compiler = compilerCache.get(schema);
  if (!compiler) {
    compiler = TypeCompiler.Compile(schema);
    compilerCache.set(schema, compiler);
  }
  return compiler;
}
function validateSchemaOrThrow(schema, data, context) {
  const compiler = getCompiledValidator(schema);
  if (!compiler.Check(data)) {
    throw new Error(`${context}\u9A8C\u8BC1\u5931\u8D25`);
  }
  return data;
}
function validateAllSchemas(config, data) {
  if (config.body) {
    validateSchemaOrThrow(config.body, data.body, "\u8BF7\u6C42\u4F53");
  }
  if (config.query) {
    validateSchemaOrThrow(config.query, data.query, "Query\u53C2\u6570");
  }
  if (config.params) {
    validateSchemaOrThrow(config.params, data.params, "\u8DEF\u5F84\u53C2\u6570");
  }
  if (config.headers) {
    validateSchemaOrThrow(config.headers, data.headers, "\u8BF7\u6C42\u5934");
  }
  if (config.cookies) {
    validateSchemaOrThrow(config.cookies, data.cookies, "Cookie");
  }
  return data;
}
function precompileSchemas(config) {
  if (config.body) getCompiledValidator(config.body);
  if (config.query) getCompiledValidator(config.query);
  if (config.params) getCompiledValidator(config.params);
  if (config.headers) getCompiledValidator(config.headers);
  if (config.cookies) getCompiledValidator(config.cookies);
}

// src/utils/sse.ts
function formatSSEEvent(event) {
  const lines = [];
  if (event.id !== void 0) {
    lines.push(`id: ${event.id}`);
  }
  if (event.event !== void 0) {
    lines.push(`event: ${event.event}`);
  }
  if (event.retry !== void 0) {
    lines.push(`retry: ${event.retry}`);
  }
  const dataStr = typeof event.data === "string" ? event.data : JSON.stringify(event.data);
  const dataLines = dataStr.split("\n");
  for (const line of dataLines) {
    lines.push(`data: ${line}`);
  }
  return lines.join("\n") + "\n\n";
}
function createSSEHandler(schemaOrGenerator, maybeGenerator) {
  const hasSchema = typeof schemaOrGenerator !== "function";
  const schema = hasSchema ? schemaOrGenerator : {};
  const generator = hasSchema ? maybeGenerator : schemaOrGenerator;
  if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
    precompileSchemas(schema);
  }
  const handlerFn = async (req) => {
    try {
      const query = parseQuery(req);
      const headers = parseHeaders(req);
      const cookies = parseCookies(req);
      const params = req.params || {};
      const data = { body: void 0, query, params, headers, cookies };
      if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
        validateAllSchemas(schema, data);
      }
      const stream = new ReadableStream({
        async start(controller) {
          const encoder = new TextEncoder();
          try {
            const gen = generator({
              req,
              body: void 0,
              query,
              params,
              headers,
              cookies
            });
            for await (const event of gen) {
              const formatted = formatSSEEvent(event);
              controller.enqueue(encoder.encode(formatted));
            }
          } catch (error) {
            const errorEvent = formatSSEEvent({
              event: "error",
              data: {
                message: error instanceof Error ? error.message : "Unknown error"
              }
            });
            controller.enqueue(encoder.encode(errorEvent));
          } finally {
            controller.close();
          }
        }
      });
      return new Response(stream, {
        headers: {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          "Connection": "keep-alive",
          "X-Accel-Buffering": "no"
          // Nginx 禁用缓冲
        }
      });
    } catch (error) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Validation Error",
          message: error instanceof Error ? error.message : "Unknown error"
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
  };
  const handler = handlerFn;
  handler.__sse = { __brand: "SSE" };
  handler.__schema = schema;
  handler.__returnType = void 0;
  return handler;
}
export {
  createSSEHandler
};
//# sourceMappingURL=sse.js.map