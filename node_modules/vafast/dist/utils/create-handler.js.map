{"version":3,"sources":["../../src/utils/parsers.ts","../../src/utils/go-await.ts","../../src/utils/response.ts","../../src/utils/validators/validators.ts","../../src/utils/create-handler.ts"],"sourcesContent":["// src/parsers.ts\nimport qs from \"qs\";\nimport cookie from \"cookie\";\n\n// 文件信息接口\nexport interface FileInfo {\n  name: string;\n  type: string;\n  size: number;\n  data: ArrayBuffer;\n}\n\n// 表单数据接口\nexport interface FormData {\n  fields: Record<string, string>;\n  files: Record<string, FileInfo>;\n}\n\n/**\n * 简化的请求体解析函数\n * 优先简洁性，处理最常见的场景\n */\nexport async function parseBody(req: Request): Promise<unknown> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n  if (contentType.includes(\"application/json\")) {\n    return await req.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const text = await req.text();\n    return Object.fromEntries(new URLSearchParams(text));\n  }\n  return await req.text(); // fallback\n}\n\n/**\n * 解析 multipart/form-data 格式\n * 支持文件上传和普通表单字段\n */\nasync function parseMultipartFormData(req: Request): Promise<FormData> {\n  const formData = await req.formData();\n  const result: FormData = {\n    fields: {},\n    files: {},\n  };\n\n  for (const [key, value] of formData.entries()) {\n    if (\n      typeof value === \"object\" &&\n      value !== null &&\n      \"name\" in value &&\n      \"type\" in value &&\n      \"size\" in value\n    ) {\n      // 处理文件\n      const file = value as any;\n      const arrayBuffer = await file.arrayBuffer();\n      result.files[key] = {\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        data: arrayBuffer,\n      };\n    } else {\n      // 处理普通字段\n      result.fields[key] = value as string;\n    }\n  }\n\n  return result;\n}\n\n/**\n * 解析请求体为特定类型\n * 提供类型安全的解析方法\n */\nexport async function parseBodyAs<T>(req: Request): Promise<T> {\n  const body = await parseBody(req);\n  return body as T;\n}\n\n/**\n * 解析请求体为表单数据\n * 专门用于处理 multipart/form-data\n */\nexport async function parseFormData(req: Request): Promise<FormData> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n\n  if (!contentType.includes(\"multipart/form-data\")) {\n    throw new Error(\"请求不是 multipart/form-data 格式\");\n  }\n\n  return await parseMultipartFormData(req);\n}\n\n/**\n * 解析请求体为文件\n * 专门用于处理文件上传\n */\nexport async function parseFile(req: Request): Promise<FileInfo> {\n  const contentType = req.headers.get(\"content-type\") || \"\";\n\n  if (!contentType.includes(\"multipart/form-data\")) {\n    throw new Error(\"请求不是 multipart/form-data 格式\");\n  }\n\n  const formData = await parseMultipartFormData(req);\n  const fileKeys = Object.keys(formData.files);\n\n  if (fileKeys.length === 0) {\n    throw new Error(\"请求中没有文件\");\n  }\n\n  if (fileKeys.length > 1) {\n    throw new Error(\"请求中包含多个文件，请使用 parseFormData\");\n  }\n\n  return formData.files[fileKeys[0]];\n}\n\n/**\n * 快速提取 query string（避免创建 URL 对象）\n */\nfunction extractQueryString(url: string): string {\n  const qIndex = url.indexOf(\"?\");\n  if (qIndex === -1) return \"\";\n\n  const hashIndex = url.indexOf(\"#\", qIndex);\n  return hashIndex === -1\n    ? url.substring(qIndex + 1)\n    : url.substring(qIndex + 1, hashIndex);\n}\n\n/** 获取查询字符串，直接返回对象 */\nexport function parseQuery(req: Request): Record<string, unknown> {\n  const queryString = extractQueryString(req.url);\n  if (!queryString) return {};\n  return qs.parse(queryString);\n}\n\n/**\n * 快速解析简单查询字符串（不支持嵌套，但更快）\n * 适用于简单的 key=value&key2=value2 场景\n */\nexport function parseQueryFast(req: Request): Record<string, string> {\n  const queryString = extractQueryString(req.url);\n  if (!queryString) return {};\n\n  const result: Record<string, string> = Object.create(null);\n  const pairs = queryString.split(\"&\");\n\n  for (const pair of pairs) {\n    const eqIndex = pair.indexOf(\"=\");\n    if (eqIndex === -1) {\n      result[decodeURIComponent(pair)] = \"\";\n    } else {\n      const key = decodeURIComponent(pair.substring(0, eqIndex));\n      const value = decodeURIComponent(pair.substring(eqIndex + 1));\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\n/** 解析请求头，返回对象 */\nexport function parseHeaders(req: Request): Record<string, string> {\n  const headers: Record<string, string> = Object.create(null);\n  req.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n/**\n * 获取单个请求头（避免解析全部）\n */\nexport function getHeader(req: Request, name: string): string | null {\n  return req.headers.get(name);\n}\n\n/** 使用cookie库解析Cookie，保证可靠性 */\nexport function parseCookies(req: Request): Record<string, string> {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return {};\n\n  try {\n    const parsed = cookie.parse(cookieHeader);\n    // 过滤掉undefined和null值\n    const result: Record<string, string> = {};\n    for (const [key, value] of Object.entries(parsed)) {\n      if (value !== undefined && value !== null) {\n        result[key] = value;\n      }\n    }\n    return result;\n  } catch {\n    return {};\n  }\n}\n\n/**\n * 快速解析 Cookie（简化版，不使用外部库）\n * 适用于简单的 cookie 场景\n */\nexport function parseCookiesFast(req: Request): Record<string, string> {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return {};\n\n  const result: Record<string, string> = Object.create(null);\n  const pairs = cookieHeader.split(\";\");\n\n  for (const pair of pairs) {\n    const trimmed = pair.trim();\n    const eqIndex = trimmed.indexOf(\"=\");\n    if (eqIndex > 0) {\n      const key = trimmed.substring(0, eqIndex).trim();\n      const value = trimmed.substring(eqIndex + 1).trim();\n      // 移除引号\n      result[key] =\n        value.startsWith('\"') && value.endsWith('\"')\n          ? value.slice(1, -1)\n          : value;\n    }\n  }\n\n  return result;\n}\n\n/**\n * 获取单个 Cookie 值（避免解析全部）\n */\nexport function getCookie(req: Request, name: string): string | null {\n  const cookieHeader = req.headers.get(\"cookie\");\n  if (!cookieHeader) return null;\n\n  const prefix = `${name}=`;\n  const pairs = cookieHeader.split(\";\");\n\n  for (const pair of pairs) {\n    const trimmed = pair.trim();\n    if (trimmed.startsWith(prefix)) {\n      const value = trimmed.substring(prefix.length).trim();\n      return value.startsWith('\"') && value.endsWith('\"')\n        ? value.slice(1, -1)\n        : value;\n    }\n  }\n\n  return null;\n}\n","/**\n * Go 风格的错误处理工具\n * 将 Promise 转换为 [Error | null, T | undefined] 格式\n *\n * @author Framework Team\n * @version 1.0.0\n * @license MIT\n */\n\n/**\n * Go 风格的错误处理工具\n * 将 Promise 转换为 [Error | null, T | undefined] 格式\n *\n * @param promise 要处理的 Promise\n * @returns [Error | null, T | undefined] 元组，第一个元素是错误，第二个是结果\n *\n * @example\n * ```typescript\n * const [error, result] = await goAwait(someAsyncFunction());\n * if (error) {\n *   console.error(\"操作失败:\", error);\n * } else {\n *   console.log(\"操作成功:\", result);\n * }\n * ```\n */\nexport function goAwait<T>(\n  promise: Promise<T>,\n): Promise<[Error | null, T | undefined]> {\n  return promise\n    .then<[null, T]>((data) => [null, data])\n    .catch<\n      [Error, undefined]\n    >((err) => [err instanceof Error ? err : new Error(String(err)), undefined]);\n}\n","// src/response.ts\n\n/** 生成 JSON 响应 */\nexport function json(\n  data: unknown,\n  status = 200,\n  headers: HeadersInit = {},\n): Response {\n  const body = JSON.stringify(data);\n\n  // 优化：只在有自定义 headers 时才创建 Headers 对象\n  if (Object.keys(headers).length === 0) {\n    return new Response(body, {\n      status,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  }\n\n  // 有自定义 headers 时才创建 Headers 对象\n  const h = new Headers({\n    \"Content-Type\": \"application/json\",\n    ...headers,\n  });\n\n  return new Response(body, {\n    status,\n    headers: h,\n  });\n}\n\n// JSON 响应的预创建 headers（避免每次创建）\nconst JSON_HEADERS = { \"Content-Type\": \"application/json\" };\nconst TEXT_HEADERS = { \"Content-Type\": \"text/plain\" };\n\n/**\n * 类型特化的响应映射\n * 根据返回值类型直接生成 Response，避免不必要的检查\n */\nexport function mapResponse(response: unknown): Response {\n  // 快速路径：已经是 Response\n  if (response instanceof Response) return response;\n\n  // 使用 constructor.name 进行类型判断（比 instanceof 更快）\n  switch (response?.constructor?.name) {\n    case \"String\":\n      return new Response(response as string, { headers: TEXT_HEADERS });\n\n    case \"Object\":\n    case \"Array\":\n      return new Response(JSON.stringify(response), { headers: JSON_HEADERS });\n\n    case \"Number\":\n    case \"Boolean\":\n      return new Response(String(response), { headers: TEXT_HEADERS });\n\n    case undefined:\n      // null 或 undefined\n      return new Response(null, { status: 204 });\n\n    case \"ReadableStream\":\n      return new Response(response as ReadableStream);\n\n    case \"Blob\":\n      return new Response(response as Blob);\n\n    case \"ArrayBuffer\":\n      return new Response(response as ArrayBuffer);\n\n    case \"Uint8Array\":\n      return new Response(response as unknown as BodyInit);\n\n    default:\n      // Promise 处理\n      if (response instanceof Promise) {\n        return response.then(mapResponse) as unknown as Response;\n      }\n      // 其他情况使用 JSON 序列化\n      return new Response(JSON.stringify(response), { headers: JSON_HEADERS });\n  }\n}\n\n/** 生成重定向响应 */\nexport function redirect(location: string, status: 301 | 302 = 302): Response {\n  return new Response(null, {\n    status,\n    headers: {\n      Location: location,\n    },\n  });\n}\n\n/** 生成纯文本响应 */\nexport function text(\n  content: string,\n  status = 200,\n  headers: HeadersInit = {},\n): Response {\n  const h = new Headers({\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    ...headers,\n  });\n\n  return new Response(content, {\n    status,\n    headers: h,\n  });\n}\n\n/** 生成HTML响应 */\nexport function html(\n  content: string,\n  status = 200,\n  headers: HeadersInit = {},\n): Response {\n  const h = new Headers({\n    \"Content-Type\": \"text/html; charset=utf-8\",\n    ...headers,\n  });\n\n  return new Response(content, {\n    status,\n    headers: h,\n  });\n}\n\n/** 生成空响应（204 No Content） */\nexport function empty(status = 204, headers: HeadersInit = {}): Response {\n  return new Response(null, {\n    status,\n    headers,\n  });\n}\n\n/** 生成流式响应 */\nexport function stream(\n  stream: ReadableStream,\n  status = 200,\n  headers: HeadersInit = {},\n): Response {\n  const h = new Headers({\n    \"Content-Type\": \"application/octet-stream\",\n    ...headers,\n  });\n\n  return new Response(stream, {\n    status,\n    headers: h,\n  });\n}\n","/**\n * Schema 验证器 - 简洁版\n *\n * 特点：\n * - WeakMap 缓存避免内存泄漏\n * - TypeCompiler JIT 编译，性能最佳\n * - 支持 FormatRegistry（需确保同一实例）\n *\n * @version 7.0.0\n */\n\nimport { Type } from \"@sinclair/typebox\";\nimport type { Static, TSchema } from \"@sinclair/typebox\";\nimport { TypeCompiler, type TypeCheck } from \"@sinclair/typebox/compiler\";\nimport { Value } from \"@sinclair/typebox/value\";\n\n// ============== 类型定义 ==============\n\n/** Schema 配置接口 */\nexport interface SchemaConfig {\n  body?: TSchema;\n  query?: TSchema;\n  params?: TSchema;\n  headers?: TSchema;\n  cookies?: TSchema;\n}\n\n/** 验证错误接口 */\nexport interface ValidationError {\n  path: string;\n  message: string;\n  code: string;\n  value?: unknown;\n}\n\n/** 验证结果 */\nexport type ValidationResult<T = unknown> =\n  | { success: true; data: T }\n  | { success: false; errors: ValidationError[] };\n\n// ============== 缓存 ==============\n\n/** 编译器缓存 - WeakMap 避免内存泄漏 */\nconst compilerCache = new WeakMap<TSchema, TypeCheck<TSchema>>();\n\n// ============== 核心函数 ==============\n\n/**\n * 获取或创建编译后的验证器\n */\nfunction getCompiledValidator<T extends TSchema>(schema: T): TypeCheck<T> {\n  let compiler = compilerCache.get(schema);\n  if (!compiler) {\n    compiler = TypeCompiler.Compile(schema);\n    compilerCache.set(schema, compiler);\n  }\n  return compiler as TypeCheck<T>;\n}\n\n/**\n * 验证单个 Schema（返回结果对象）\n */\nexport function validateSchema<T extends TSchema>(\n  schema: T,\n  data: unknown,\n): ValidationResult<Static<T>> {\n  try {\n    const compiler = getCompiledValidator(schema);\n\n    if (compiler.Check(data)) {\n      return { success: true, data: data as Static<T> };\n    }\n\n    // 收集错误\n    const errors: ValidationError[] = [];\n    for (const error of compiler.Errors(data)) {\n      errors.push({\n        path: error.path,\n        message: error.message,\n        code: \"VALIDATION_FAILED\",\n        value: error.value,\n      });\n    }\n    return { success: false, errors };\n  } catch (error) {\n    return {\n      success: false,\n      errors: [\n        {\n          path: \"\",\n          message: error instanceof Error ? error.message : \"验证异常\",\n          code: \"VALIDATION_EXCEPTION\",\n        },\n      ],\n    };\n  }\n}\n\n/**\n * 验证 Schema（抛出异常版本，用于框架内部）\n */\nexport function validateSchemaOrThrow<T extends TSchema>(\n  schema: T,\n  data: unknown,\n  context: string,\n): Static<T> {\n  const compiler = getCompiledValidator(schema);\n\n  if (!compiler.Check(data)) {\n    throw new Error(`${context}验证失败`);\n  }\n\n  return data as Static<T>;\n}\n\n/**\n * 快速验证（只返回布尔值）\n */\nexport function validateFast<T extends TSchema>(\n  schema: T,\n  data: unknown,\n): data is Static<T> {\n  const compiler = getCompiledValidator(schema);\n  return compiler.Check(data);\n}\n\n/**\n * 批量验证所有 Schema（用于请求验证）\n */\nexport function validateAllSchemas(\n  config: SchemaConfig,\n  data: {\n    body: unknown;\n    query: unknown;\n    params: unknown;\n    headers: unknown;\n    cookies: unknown;\n  },\n): typeof data {\n  if (config.body) {\n    validateSchemaOrThrow(config.body, data.body, \"请求体\");\n  }\n  if (config.query) {\n    validateSchemaOrThrow(config.query, data.query, \"Query参数\");\n  }\n  if (config.params) {\n    validateSchemaOrThrow(config.params, data.params, \"路径参数\");\n  }\n  if (config.headers) {\n    validateSchemaOrThrow(config.headers, data.headers, \"请求头\");\n  }\n  if (config.cookies) {\n    validateSchemaOrThrow(config.cookies, data.cookies, \"Cookie\");\n  }\n  return data;\n}\n\n/**\n * 预编译 Schema（启动时调用，避免首次请求开销）\n */\nexport function precompileSchemas(config: SchemaConfig): void {\n  if (config.body) getCompiledValidator(config.body);\n  if (config.query) getCompiledValidator(config.query);\n  if (config.params) getCompiledValidator(config.params);\n  if (config.headers) getCompiledValidator(config.headers);\n  if (config.cookies) getCompiledValidator(config.cookies);\n}\n\n/**\n * 创建类型特化的验证器（高频使用场景）\n */\nexport function createValidator<T extends TSchema>(\n  schema: T,\n): (data: unknown) => ValidationResult<Static<T>> {\n  return (data: unknown) => validateSchema(schema, data);\n}\n\n/**\n * 获取缓存统计（调试用）\n */\nexport function getValidatorCacheStats(): { cacheType: string; note: string } {\n  return {\n    cacheType: \"WeakMap\",\n    note: \"WeakMap 缓存会随 Schema 对象自动清理，无内存泄漏风险\",\n  };\n}\n\n// 导出 TypeBox 类型\nexport { Type, Static, TSchema };\n","/**\n * 类型安全的路由处理器工厂\n *\n * 非柯里化设计，API 更简洁\n *\n * @author Framework Team\n * @version 3.0.0\n * @license MIT\n */\n\nimport type {\n  RouteSchema,\n  HandlerContext,\n  HandlerContextWithExtra,\n} from \"../types/schema\";\nimport { parseBody, parseQuery, parseHeaders, parseCookies } from \"./parsers\";\nimport { goAwait } from \"./go-await\";\nimport { json } from \"./response\";\nimport {\n  validateAllSchemas,\n  precompileSchemas,\n} from \"./validators/validators\";\n\n/**\n * 自动响应转换\n * 将各种返回值类型转换为 Response 对象\n */\nfunction autoResponse(result: unknown): Response {\n  // 已经是 Response\n  if (result instanceof Response) {\n    return result;\n  }\n\n  // null/undefined -> 204\n  if (result === null || result === undefined) {\n    return new Response(null, { status: 204 });\n  }\n\n  // 字符串 -> text/plain\n  if (typeof result === \"string\") {\n    return new Response(result, {\n      headers: { \"Content-Type\": \"text/plain; charset=utf-8\" },\n    });\n  }\n\n  // 数字/布尔 -> text/plain\n  if (typeof result === \"number\" || typeof result === \"boolean\") {\n    return new Response(String(result), {\n      headers: { \"Content-Type\": \"text/plain; charset=utf-8\" },\n    });\n  }\n\n  // 对象 -> 检查是否是 { data, status, headers } 格式\n  if (typeof result === \"object\") {\n    const obj = result as Record<string, unknown>;\n    if (\"data\" in obj && (\"status\" in obj || \"headers\" in obj)) {\n      const { data, status = 200, headers = {} } = obj;\n\n      if (data === null || data === undefined) {\n        return new Response(null, {\n          status: status === 200 ? 204 : (status as number),\n          headers: headers as HeadersInit,\n        });\n      }\n\n      if (\n        typeof data === \"string\" ||\n        typeof data === \"number\" ||\n        typeof data === \"boolean\"\n      ) {\n        return new Response(String(data), {\n          status: status as number,\n          headers: {\n            \"Content-Type\": \"text/plain; charset=utf-8\",\n            ...(headers as Record<string, string>),\n          },\n        });\n      }\n\n      return json(data, status as number, headers as Record<string, string>);\n    }\n\n    // 普通对象 -> JSON\n    return json(result);\n  }\n\n  // 其他类型 -> 204\n  return new Response(null, { status: 204 });\n}\n\n/**\n * 处理验证错误\n */\nfunction handleValidationError(error: Error): Response {\n  return json(\n    {\n      success: false,\n      error: \"Validation Error\",\n      message: error.message,\n      timestamp: new Date().toISOString(),\n    },\n    400,\n  );\n}\n\n/**\n * 处理内部错误\n */\nfunction handleInternalError(error: unknown): Response {\n  return json(\n    {\n      success: false,\n      error: \"Internal Error\",\n      message: error instanceof Error ? error.message : \"未知错误\",\n    },\n    500,\n  );\n}\n\n/** 空 schema 的上下文类型 */\ntype EmptySchemaContext = {\n  req: Request;\n  body: unknown;\n  query: Record<string, string>;\n  params: Record<string, string>;\n  headers: Record<string, string>;\n  cookies: Record<string, string>;\n};\n\n/**\n * 判断是否为 handler 函数\n */\nfunction isHandler(value: unknown): value is (...args: unknown[]) => unknown {\n  return typeof value === \"function\";\n}\n\n/**\n * 创建类型安全的路由处理器\n *\n * @example\n * ```typescript\n * // 无 schema - 直接传入 handler\n * createHandler(({ params }) => `User: ${params.id}`)\n *\n * // 有 schema - 传入 schema 和 handler\n * createHandler(\n *   { body: Type.Object({ name: Type.String() }) },\n *   ({ body }) => ({ hello: body.name })\n * )\n * ```\n */\n/**\n * 带类型推断的 Handler - 保留返回类型信息用于客户端类型推断\n */\nexport type InferableHandler<TReturn, TSchema extends RouteSchema = RouteSchema> = ((req: Request) => Promise<Response>) & {\n  /** 返回类型标记（仅用于类型推断，运行时不存在） */\n  __returnType: TReturn;\n  /** Schema 类型标记 */\n  __schema: TSchema;\n};\n\n\n// 重载 1: 无 schema\nexport function createHandler<R>(\n  handler: (ctx: EmptySchemaContext) => R | Promise<R>,\n): InferableHandler<R>;\n\n// 重载 2: 有 schema\nexport function createHandler<const T extends RouteSchema, R>(\n  schema: T,\n  handler: (ctx: HandlerContext<T>) => R | Promise<R>,\n): InferableHandler<R, T>;\n\n// 实现\nexport function createHandler<const T extends RouteSchema, R>(\n  schemaOrHandler: T | ((ctx: EmptySchemaContext) => R | Promise<R>),\n  maybeHandler?: (ctx: HandlerContext<T>) => R | Promise<R>,\n): InferableHandler<R, T> {\n  // 判断调用方式\n  const hasSchema = !isHandler(schemaOrHandler);\n  const schema = hasSchema ? (schemaOrHandler as T) : ({} as T);\n  const handler = hasSchema\n    ? maybeHandler!\n    : (schemaOrHandler as (ctx: HandlerContext<T>) => R | Promise<R>);\n\n  // 预编译 schema\n  if (\n    schema.body ||\n    schema.query ||\n    schema.params ||\n    schema.headers ||\n    schema.cookies\n  ) {\n    precompileSchemas(schema);\n  }\n\n  const handlerFn = async (req: Request): Promise<Response> => {\n    try {\n      // 解析请求数据\n      const query = parseQuery(req);\n      const headers = parseHeaders(req);\n      const cookies = parseCookies(req);\n      const params =\n        ((req as unknown as Record<string, unknown>).params as Record<\n          string,\n          string\n        >) || {};\n\n      // 解析请求体\n      let body: unknown = undefined;\n      if (req.method !== \"GET\" && req.method !== \"HEAD\") {\n        const [, parsedBody] = await goAwait(parseBody(req));\n        body = parsedBody;\n      }\n\n      // 验证 schema\n      const data = { body, query, params, headers, cookies };\n      if (\n        schema.body ||\n        schema.query ||\n        schema.params ||\n        schema.headers ||\n        schema.cookies\n      ) {\n        validateAllSchemas(schema, data);\n      }\n\n      // 调用 handler\n      const result = await handler({\n        req,\n        body: body as HandlerContext<T>[\"body\"],\n        query: query as HandlerContext<T>[\"query\"],\n        params: params as HandlerContext<T>[\"params\"],\n        headers: headers as HandlerContext<T>[\"headers\"],\n        cookies: cookies as HandlerContext<T>[\"cookies\"],\n      });\n\n      return autoResponse(result);\n    } catch (error) {\n      if (error instanceof Error && error.message.includes(\"验证失败\")) {\n        return handleValidationError(error);\n      }\n      return handleInternalError(error);\n    }\n  };\n\n  // 类型断言：这些属性只在编译时用于类型推断，运行时不存在\n  return handlerFn as InferableHandler<R, T>;\n}\n\n/**\n * 创建带额外上下文的路由处理器\n *\n * 用于中间件注入额外数据的场景\n *\n * @example\n * ```typescript\n * // 定义中间件注入的类型\n * type AuthContext = { user: { id: string; role: string } };\n *\n * // 无 schema\n * createHandlerWithExtra<AuthContext>(({ user }) => {\n *   return { userId: user.id };\n * })\n *\n * // 有 schema\n * createHandlerWithExtra<AuthContext>(\n *   { body: Type.Object({ action: Type.String() }) },\n *   ({ body, user }) => ({ success: true, userId: user.id })\n * )\n * ```\n */\n// 重载 1: 无 schema\nexport function createHandlerWithExtra<\n  TExtra extends Record<string, unknown> = Record<string, never>,\n  R = unknown,\n>(\n  handler: (ctx: EmptySchemaContext & TExtra) => R | Promise<R>,\n): (req: Request) => Promise<Response>;\n\n// 重载 2: 有 schema\nexport function createHandlerWithExtra<\n  TExtra extends Record<string, unknown> = Record<string, never>,\n  const T extends RouteSchema = RouteSchema,\n  R = unknown,\n>(\n  schema: T,\n  handler: (ctx: HandlerContextWithExtra<T, TExtra>) => R | Promise<R>,\n): (req: Request) => Promise<Response>;\n\n// 实现\nexport function createHandlerWithExtra<\n  TExtra extends Record<string, unknown> = Record<string, never>,\n  const T extends RouteSchema = RouteSchema,\n  R = unknown,\n>(\n  schemaOrHandler: T | ((ctx: EmptySchemaContext & TExtra) => R | Promise<R>),\n  maybeHandler?: (ctx: HandlerContextWithExtra<T, TExtra>) => R | Promise<R>,\n): (req: Request) => Promise<Response> {\n  // 判断调用方式\n  const hasSchema = !isHandler(schemaOrHandler);\n  const schema = hasSchema ? (schemaOrHandler as T) : ({} as T);\n  const handler = hasSchema\n    ? maybeHandler!\n    : (schemaOrHandler as (\n        ctx: HandlerContextWithExtra<T, TExtra>,\n      ) => R | Promise<R>);\n\n  // 预编译 schema\n  if (\n    schema.body ||\n    schema.query ||\n    schema.params ||\n    schema.headers ||\n    schema.cookies\n  ) {\n    precompileSchemas(schema);\n  }\n\n  return async (req: Request): Promise<Response> => {\n    try {\n      // 解析请求数据\n      const query = parseQuery(req);\n      const headers = parseHeaders(req);\n      const cookies = parseCookies(req);\n      const params =\n        ((req as unknown as Record<string, unknown>).params as Record<\n          string,\n          string\n        >) || {};\n\n      // 解析请求体\n      let body: unknown = undefined;\n      if (req.method !== \"GET\" && req.method !== \"HEAD\") {\n        const [, parsedBody] = await goAwait(parseBody(req));\n        body = parsedBody;\n      }\n\n      // 验证 schema\n      const data = { body, query, params, headers, cookies };\n      if (\n        schema.body ||\n        schema.query ||\n        schema.params ||\n        schema.headers ||\n        schema.cookies\n      ) {\n        validateAllSchemas(schema, data);\n      }\n\n      // 获取中间件注入的额外数据\n      const extras = ((req as unknown as Record<string, unknown>).__locals ??\n        {}) as TExtra;\n\n      // 调用 handler\n      const result = await handler({\n        req,\n        body: body as HandlerContext<T>[\"body\"],\n        query: query as HandlerContext<T>[\"query\"],\n        params: params as HandlerContext<T>[\"params\"],\n        headers: headers as HandlerContext<T>[\"headers\"],\n        cookies: cookies as HandlerContext<T>[\"cookies\"],\n        ...extras,\n      } as HandlerContextWithExtra<T, TExtra>);\n\n      return autoResponse(result);\n    } catch (error) {\n      if (error instanceof Error && error.message.includes(\"验证失败\")) {\n        return handleValidationError(error);\n      }\n      return handleInternalError(error);\n    }\n  };\n}\n\n/**\n * 简单的路由处理器 (无 schema 验证，只有 req)\n *\n * @example\n * ```typescript\n * simpleHandler(({ req }) => {\n *   return { message: \"Hello World\" };\n * })\n * ```\n */\nexport function simpleHandler<R>(\n  handler: (ctx: { req: Request }) => R | Promise<R>,\n): (req: Request) => Promise<Response> {\n  return async (req: Request): Promise<Response> => {\n    try {\n      const result = await handler({ req });\n      return autoResponse(result);\n    } catch (error) {\n      return handleInternalError(error);\n    }\n  };\n}\n"],"mappings":"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","names":[]}