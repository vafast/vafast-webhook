// src/utils/parsers.ts
import qs from "qs";
import cookie from "cookie";
async function parseBody(req) {
  const contentType = req.headers.get("content-type") || "";
  if (contentType.includes("application/json")) {
    return await req.json();
  }
  if (contentType.includes("application/x-www-form-urlencoded")) {
    const text2 = await req.text();
    return Object.fromEntries(new URLSearchParams(text2));
  }
  return await req.text();
}
function extractQueryString(url) {
  const qIndex = url.indexOf("?");
  if (qIndex === -1) return "";
  const hashIndex = url.indexOf("#", qIndex);
  return hashIndex === -1 ? url.substring(qIndex + 1) : url.substring(qIndex + 1, hashIndex);
}
function parseQuery(req) {
  const queryString = extractQueryString(req.url);
  if (!queryString) return {};
  return qs.parse(queryString);
}
function parseQueryFast(req) {
  const queryString = extractQueryString(req.url);
  if (!queryString) return {};
  const result = /* @__PURE__ */ Object.create(null);
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const eqIndex = pair.indexOf("=");
    if (eqIndex === -1) {
      result[decodeURIComponent(pair)] = "";
    } else {
      const key = decodeURIComponent(pair.substring(0, eqIndex));
      const value = decodeURIComponent(pair.substring(eqIndex + 1));
      result[key] = value;
    }
  }
  return result;
}
function parseHeaders(req) {
  const headers = /* @__PURE__ */ Object.create(null);
  req.headers.forEach((value, key) => {
    headers[key] = value;
  });
  return headers;
}
function getHeader(req, name) {
  return req.headers.get(name);
}
function parseCookies(req) {
  const cookieHeader = req.headers.get("cookie");
  if (!cookieHeader) return {};
  try {
    const parsed = cookie.parse(cookieHeader);
    const result = {};
    for (const [key, value] of Object.entries(parsed)) {
      if (value !== void 0 && value !== null) {
        result[key] = value;
      }
    }
    return result;
  } catch {
    return {};
  }
}
function parseCookiesFast(req) {
  const cookieHeader = req.headers.get("cookie");
  if (!cookieHeader) return {};
  const result = /* @__PURE__ */ Object.create(null);
  const pairs = cookieHeader.split(";");
  for (const pair of pairs) {
    const trimmed = pair.trim();
    const eqIndex = trimmed.indexOf("=");
    if (eqIndex > 0) {
      const key = trimmed.substring(0, eqIndex).trim();
      const value = trimmed.substring(eqIndex + 1).trim();
      result[key] = value.startsWith('"') && value.endsWith('"') ? value.slice(1, -1) : value;
    }
  }
  return result;
}
function getCookie(req, name) {
  const cookieHeader = req.headers.get("cookie");
  if (!cookieHeader) return null;
  const prefix = `${name}=`;
  const pairs = cookieHeader.split(";");
  for (const pair of pairs) {
    const trimmed = pair.trim();
    if (trimmed.startsWith(prefix)) {
      const value = trimmed.substring(prefix.length).trim();
      return value.startsWith('"') && value.endsWith('"') ? value.slice(1, -1) : value;
    }
  }
  return null;
}

// src/utils/go-await.ts
function goAwait(promise) {
  return promise.then((data) => [null, data]).catch((err) => [err instanceof Error ? err : new Error(String(err)), void 0]);
}

// src/utils/response.ts
function json(data, status = 200, headers = {}) {
  const body = JSON.stringify(data);
  if (Object.keys(headers).length === 0) {
    return new Response(body, {
      status,
      headers: { "Content-Type": "application/json" }
    });
  }
  const h = new Headers({
    "Content-Type": "application/json",
    ...headers
  });
  return new Response(body, {
    status,
    headers: h
  });
}
function redirect(location, status = 302) {
  return new Response(null, {
    status,
    headers: {
      Location: location
    }
  });
}
function text(content, status = 200, headers = {}) {
  const h = new Headers({
    "Content-Type": "text/plain; charset=utf-8",
    ...headers
  });
  return new Response(content, {
    status,
    headers: h
  });
}
function html(content, status = 200, headers = {}) {
  const h = new Headers({
    "Content-Type": "text/html; charset=utf-8",
    ...headers
  });
  return new Response(content, {
    status,
    headers: h
  });
}
function empty(status = 204, headers = {}) {
  return new Response(null, {
    status,
    headers
  });
}
function stream(stream2, status = 200, headers = {}) {
  const h = new Headers({
    "Content-Type": "application/octet-stream",
    ...headers
  });
  return new Response(stream2, {
    status,
    headers: h
  });
}

// src/utils/validators/validators.ts
import { Type } from "@sinclair/typebox";
import { TypeCompiler } from "@sinclair/typebox/compiler";
var compilerCache = /* @__PURE__ */ new WeakMap();
function getCompiledValidator(schema) {
  let compiler = compilerCache.get(schema);
  if (!compiler) {
    compiler = TypeCompiler.Compile(schema);
    compilerCache.set(schema, compiler);
  }
  return compiler;
}
function validateSchema(schema, data) {
  try {
    const compiler = getCompiledValidator(schema);
    if (compiler.Check(data)) {
      return { success: true, data };
    }
    const errors = [];
    for (const error of compiler.Errors(data)) {
      errors.push({
        path: error.path,
        message: error.message,
        code: "VALIDATION_FAILED",
        value: error.value
      });
    }
    return { success: false, errors };
  } catch (error) {
    return {
      success: false,
      errors: [
        {
          path: "",
          message: error instanceof Error ? error.message : "\u9A8C\u8BC1\u5F02\u5E38",
          code: "VALIDATION_EXCEPTION"
        }
      ]
    };
  }
}
function validateSchemaOrThrow(schema, data, context) {
  const compiler = getCompiledValidator(schema);
  if (!compiler.Check(data)) {
    throw new Error(`${context}\u9A8C\u8BC1\u5931\u8D25`);
  }
  return data;
}
function validateFast(schema, data) {
  const compiler = getCompiledValidator(schema);
  return compiler.Check(data);
}
function validateAllSchemas(config, data) {
  if (config.body) {
    validateSchemaOrThrow(config.body, data.body, "\u8BF7\u6C42\u4F53");
  }
  if (config.query) {
    validateSchemaOrThrow(config.query, data.query, "Query\u53C2\u6570");
  }
  if (config.params) {
    validateSchemaOrThrow(config.params, data.params, "\u8DEF\u5F84\u53C2\u6570");
  }
  if (config.headers) {
    validateSchemaOrThrow(config.headers, data.headers, "\u8BF7\u6C42\u5934");
  }
  if (config.cookies) {
    validateSchemaOrThrow(config.cookies, data.cookies, "Cookie");
  }
  return data;
}
function precompileSchemas(config) {
  if (config.body) getCompiledValidator(config.body);
  if (config.query) getCompiledValidator(config.query);
  if (config.params) getCompiledValidator(config.params);
  if (config.headers) getCompiledValidator(config.headers);
  if (config.cookies) getCompiledValidator(config.cookies);
}
function createValidator(schema) {
  return (data) => validateSchema(schema, data);
}
function getValidatorCacheStats() {
  return {
    cacheType: "WeakMap",
    note: "WeakMap \u7F13\u5B58\u4F1A\u968F Schema \u5BF9\u8C61\u81EA\u52A8\u6E05\u7406\uFF0C\u65E0\u5185\u5B58\u6CC4\u6F0F\u98CE\u9669"
  };
}

// src/utils/create-handler.ts
function autoResponse(result) {
  if (result instanceof Response) {
    return result;
  }
  if (result === null || result === void 0) {
    return new Response(null, { status: 204 });
  }
  if (typeof result === "string") {
    return new Response(result, {
      headers: { "Content-Type": "text/plain; charset=utf-8" }
    });
  }
  if (typeof result === "number" || typeof result === "boolean") {
    return new Response(String(result), {
      headers: { "Content-Type": "text/plain; charset=utf-8" }
    });
  }
  if (typeof result === "object") {
    const obj = result;
    if ("data" in obj && ("status" in obj || "headers" in obj)) {
      const { data, status = 200, headers = {} } = obj;
      if (data === null || data === void 0) {
        return new Response(null, {
          status: status === 200 ? 204 : status,
          headers
        });
      }
      if (typeof data === "string" || typeof data === "number" || typeof data === "boolean") {
        return new Response(String(data), {
          status,
          headers: {
            "Content-Type": "text/plain; charset=utf-8",
            ...headers
          }
        });
      }
      return json(data, status, headers);
    }
    return json(result);
  }
  return new Response(null, { status: 204 });
}
function handleValidationError(error) {
  return json(
    {
      success: false,
      error: "Validation Error",
      message: error.message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    },
    400
  );
}
function handleInternalError(error) {
  return json(
    {
      success: false,
      error: "Internal Error",
      message: error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF"
    },
    500
  );
}
function isHandler(value) {
  return typeof value === "function";
}
function createHandler(schemaOrHandler, maybeHandler) {
  const hasSchema = !isHandler(schemaOrHandler);
  const schema = hasSchema ? schemaOrHandler : {};
  const handler = hasSchema ? maybeHandler : schemaOrHandler;
  if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
    precompileSchemas(schema);
  }
  const handlerFn = async (req) => {
    try {
      const query = parseQuery(req);
      const headers = parseHeaders(req);
      const cookies = parseCookies(req);
      const params = req.params || {};
      let body = void 0;
      if (req.method !== "GET" && req.method !== "HEAD") {
        const [, parsedBody] = await goAwait(parseBody(req));
        body = parsedBody;
      }
      const data = { body, query, params, headers, cookies };
      if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
        validateAllSchemas(schema, data);
      }
      const result = await handler({
        req,
        body,
        query,
        params,
        headers,
        cookies
      });
      return autoResponse(result);
    } catch (error) {
      if (error instanceof Error && error.message.includes("\u9A8C\u8BC1\u5931\u8D25")) {
        return handleValidationError(error);
      }
      return handleInternalError(error);
    }
  };
  return handlerFn;
}
function createHandlerWithExtra(schemaOrHandler, maybeHandler) {
  const hasSchema = !isHandler(schemaOrHandler);
  const schema = hasSchema ? schemaOrHandler : {};
  const handler = hasSchema ? maybeHandler : schemaOrHandler;
  if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
    precompileSchemas(schema);
  }
  return async (req) => {
    try {
      const query = parseQuery(req);
      const headers = parseHeaders(req);
      const cookies = parseCookies(req);
      const params = req.params || {};
      let body = void 0;
      if (req.method !== "GET" && req.method !== "HEAD") {
        const [, parsedBody] = await goAwait(parseBody(req));
        body = parsedBody;
      }
      const data = { body, query, params, headers, cookies };
      if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
        validateAllSchemas(schema, data);
      }
      const extras = req.__locals ?? {};
      const result = await handler({
        req,
        body,
        query,
        params,
        headers,
        cookies,
        ...extras
      });
      return autoResponse(result);
    } catch (error) {
      if (error instanceof Error && error.message.includes("\u9A8C\u8BC1\u5931\u8D25")) {
        return handleValidationError(error);
      }
      return handleInternalError(error);
    }
  };
}
function simpleHandler(handler) {
  return async (req) => {
    try {
      const result = await handler({ req });
      return autoResponse(result);
    } catch (error) {
      return handleInternalError(error);
    }
  };
}

// src/utils/base64url.ts
function base64urlEncode(str) {
  return btoa(str).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64urlDecode(str) {
  const pad = str.length % 4 === 0 ? "" : "=".repeat(4 - str.length % 4);
  const base64 = str.replace(/-/g, "+").replace(/_/g, "/") + pad;
  return atob(base64);
}

// src/utils/handle.ts
function setLocals(req, extras) {
  const target = req;
  target.__locals = { ...target.__locals ?? {}, ...extras };
}
function getLocals(req) {
  const target = req;
  return target.__locals ?? {};
}

// src/utils/request-validator.ts
async function parseRequest(request, params) {
  const requestData = {
    body: void 0,
    query: parseQuery(request),
    params: params || {},
    headers: parseHeaders(request),
    cookies: parseCookies(request)
  };
  if (request.method !== "GET" && request.method !== "HEAD") {
    requestData.body = await parseBody(request);
  }
  return requestData;
}
function validateRequest(config, requestData) {
  try {
    const validatedData = validateAllSchemas(config, requestData);
    return {
      success: true,
      data: validatedData
    };
  } catch (error) {
    return {
      success: false,
      errors: [
        {
          field: "unknown",
          message: error instanceof Error ? error.message : "\u9A8C\u8BC1\u5931\u8D25"
        }
      ]
    };
  }
}
async function parseAndValidateRequest(request, config, params) {
  try {
    const requestData = await parseRequest(request, params);
    return validateRequest(config, requestData);
  } catch (error) {
    return {
      success: false,
      errors: [
        {
          field: "unknown",
          message: error instanceof Error ? error.message : "\u8BF7\u6C42\u89E3\u6790\u5931\u8D25"
        }
      ]
    };
  }
}
function createRequestValidator(config) {
  return async (request, params) => {
    return parseAndValidateRequest(request, config, params);
  };
}

// src/utils/html-renderer.ts
var HtmlRenderer = class {
  /**
   * 生成基础HTML模板
   */
  static generateBaseHtml(content, context, clientScriptPath = "/client.js") {
    return `
      <!doctype html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>Vafast SSR App</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
        </head>
        <body>
          <div id="app">${content}</div>
          <script>
            window.__ROUTE_INFO__ = {
              params: ${JSON.stringify(context.params || {})},
              query: ${JSON.stringify(context.query || {})},
              pathname: '${context.pathname}'
            };
          </script>
          <script type="module" src="${clientScriptPath}"></script>
        </body>
      </html>
    `;
  }
  /**
   * 生成Vue组件HTML
   */
  static generateVueHtml(content, context, clientScriptPath = "/client.js") {
    return this.generateBaseHtml(content, context, clientScriptPath);
  }
  /**
   * 生成React组件HTML
   */
  static generateReactHtml(content, context, clientScriptPath = "/client.js") {
    return `
      <!doctype html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>Vafast SSR App</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
        </head>
        <body>
          <div id="root">${content}</div>
          <script>
            window.__ROUTE_INFO__ = {
              params: ${JSON.stringify(context.params || {})},
              query: ${JSON.stringify(context.query || {})},
              pathname: '${context.pathname}'
            };
          </script>
          <script type="module" src="${clientScriptPath}"></script>
        </body>
      </html>
    `;
  }
};

// src/utils/dependency-manager.ts
var DependencyManager = class {
  dependencyCache = /* @__PURE__ */ new Map();
  /**
   * 按需获取框架依赖
   */
  async getFrameworkDeps(framework) {
    if (this.dependencyCache.has(framework)) {
      return this.dependencyCache.get(framework);
    }
    console.log(`\u{1F4E6} \u6309\u9700\u52A0\u8F7D ${framework} \u4F9D\u8D56...`);
    try {
      let deps;
      switch (framework) {
        case "vue":
          deps = await Promise.all([
            import("vue"),
            import("@vue/server-renderer")
          ]);
          break;
        case "react":
          deps = await Promise.all([
            import("react"),
            import("react-dom/server")
          ]);
          break;
        default:
          throw new Error(`\u4E0D\u652F\u6301\u7684\u6846\u67B6: ${framework}`);
      }
      this.dependencyCache.set(framework, deps);
      console.log(`\u2705 ${framework} \u4F9D\u8D56\u52A0\u8F7D\u5B8C\u6210`);
      return deps;
    } catch (error) {
      console.error(`\u274C ${framework} \u4F9D\u8D56\u52A0\u8F7D\u5931\u8D25:`, error);
      throw error;
    }
  }
  /**
   * 检测组件类型
   */
  detectComponentType(component) {
    if (component.render && typeof component.render === "function") {
      return "vue";
    }
    if (component.$$typeof) {
      return "react";
    }
    return "vue";
  }
  /**
   * 清除缓存
   */
  clearCache() {
    this.dependencyCache.clear();
    console.log("\u{1F9F9} \u4F9D\u8D56\u7F13\u5B58\u5DF2\u6E05\u9664");
  }
  /**
   * 获取缓存状态
   */
  getCacheStatus() {
    const status = {};
    for (const [framework] of this.dependencyCache) {
      status[framework] = true;
    }
    return status;
  }
};

// src/utils/formats.ts
import { FormatRegistry } from "@sinclair/typebox";
var EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
var UUID_ANY_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
var CUID_REGEX = /^c[^\s-]{8,}$/i;
var CUID2_REGEX = /^[0-9a-z]+$/;
var ULID_REGEX = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var NANOID_REGEX = /^[A-Za-z0-9_-]{21}$/;
var URL_REGEX = /^https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b[-a-zA-Z0-9()@:%_+.~#?&/=]*$/;
var IPV4_REGEX = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
var IPV6_REGEX = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^::(?:[0-9a-fA-F]{1,4}:){0,6}[0-9a-fA-F]{1,4}$|^(?:[0-9a-fA-F]{1,4}:){1,7}:$|^(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}$|^(?:[0-9a-fA-F]{1,4}:){1,5}(?::[0-9a-fA-F]{1,4}){1,2}$|^(?:[0-9a-fA-F]{1,4}:){1,4}(?::[0-9a-fA-F]{1,4}){1,3}$|^(?:[0-9a-fA-F]{1,4}:){1,3}(?::[0-9a-fA-F]{1,4}){1,4}$|^(?:[0-9a-fA-F]{1,4}:){1,2}(?::[0-9a-fA-F]{1,4}){1,5}$|^[0-9a-fA-F]{1,4}:(?::[0-9a-fA-F]{1,4}){1,6}$/;
var CIDR_REGEX = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\/(?:3[0-2]|[12]?[0-9])$/;
var DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12][0-9]|3[01])$/;
var TIME_REGEX = /^(?:[01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](?:\.\d{1,3})?$/;
var DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12][0-9]|3[01])T(?:[01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](?:\.\d{1,3})?(?:Z|[+-](?:[01][0-9]|2[0-3]):[0-5][0-9])?$/;
var DURATION_REGEX = /^P(?:\d+Y)?(?:\d+M)?(?:\d+W)?(?:\d+D)?(?:T(?:\d+H)?(?:\d+M)?(?:\d+(?:\.\d+)?S)?)?$/;
var HOSTNAME_REGEX = /^(?=.{1,253}$)(?:(?!-)[a-zA-Z0-9-]{1,63}(?<!-)\.)*(?!-)[a-zA-Z0-9-]{1,63}(?<!-)$/;
var PHONE_CN_REGEX = /^1[3-9]\d{9}$/;
var PHONE_E164_REGEX = /^\+[1-9]\d{6,14}$/;
var OBJECTID_REGEX = /^[0-9a-fA-F]{24}$/;
var HEX_COLOR_REGEX = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
var RGB_COLOR_REGEX = /^rgba?\(\s*(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\s*,\s*(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\s*,\s*(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?:\s*,\s*(?:0|1|0?\.\d+))?\s*\)$/;
var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
var BASE64URL_REGEX = /^[A-Za-z0-9_-]+$/;
var JWT_REGEX = /^[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+$/;
var EMOJI_REGEX = /^[\p{Emoji}]+$/u;
var SLUG_REGEX = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
var SEMVER_REGEX = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
function isValidCreditCard(value) {
  const digits = value.replace(/\D/g, "");
  if (digits.length < 13 || digits.length > 19) return false;
  let sum = 0;
  let isEven = false;
  for (let i = digits.length - 1; i >= 0; i--) {
    let digit = parseInt(digits[i], 10);
    if (isEven) {
      digit *= 2;
      if (digit > 9) digit -= 9;
    }
    sum += digit;
    isEven = !isEven;
  }
  return sum % 10 === 0;
}
var isRegistered = false;
function registerFormats() {
  if (isRegistered) return;
  isRegistered = true;
  FormatRegistry.Set("email", (v) => EMAIL_REGEX.test(v));
  FormatRegistry.Set("uuid", (v) => UUID_REGEX.test(v));
  FormatRegistry.Set("uuid-any", (v) => UUID_ANY_REGEX.test(v));
  FormatRegistry.Set("cuid", (v) => CUID_REGEX.test(v));
  FormatRegistry.Set("cuid2", (v) => CUID2_REGEX.test(v) && v.length >= 1);
  FormatRegistry.Set("ulid", (v) => ULID_REGEX.test(v));
  FormatRegistry.Set("nanoid", (v) => NANOID_REGEX.test(v));
  FormatRegistry.Set("objectid", (v) => OBJECTID_REGEX.test(v));
  FormatRegistry.Set("slug", (v) => SLUG_REGEX.test(v));
  FormatRegistry.Set("url", (v) => URL_REGEX.test(v));
  FormatRegistry.Set("uri", (v) => URL_REGEX.test(v));
  FormatRegistry.Set("ipv4", (v) => IPV4_REGEX.test(v));
  FormatRegistry.Set("ipv6", (v) => IPV6_REGEX.test(v));
  FormatRegistry.Set("ip", (v) => IPV4_REGEX.test(v) || IPV6_REGEX.test(v));
  FormatRegistry.Set("cidr", (v) => CIDR_REGEX.test(v));
  FormatRegistry.Set("hostname", (v) => HOSTNAME_REGEX.test(v));
  FormatRegistry.Set("date", (v) => DATE_REGEX.test(v));
  FormatRegistry.Set("time", (v) => TIME_REGEX.test(v));
  FormatRegistry.Set("date-time", (v) => DATE_TIME_REGEX.test(v));
  FormatRegistry.Set("datetime", (v) => DATE_TIME_REGEX.test(v));
  FormatRegistry.Set("duration", (v) => DURATION_REGEX.test(v));
  FormatRegistry.Set("phone", (v) => PHONE_CN_REGEX.test(v));
  FormatRegistry.Set("phone-cn", (v) => PHONE_CN_REGEX.test(v));
  FormatRegistry.Set("phone-e164", (v) => PHONE_E164_REGEX.test(v));
  FormatRegistry.Set("base64", (v) => BASE64_REGEX.test(v));
  FormatRegistry.Set("base64url", (v) => BASE64URL_REGEX.test(v));
  FormatRegistry.Set("jwt", (v) => JWT_REGEX.test(v));
  FormatRegistry.Set("hex-color", (v) => HEX_COLOR_REGEX.test(v));
  FormatRegistry.Set("rgb-color", (v) => RGB_COLOR_REGEX.test(v));
  FormatRegistry.Set(
    "color",
    (v) => HEX_COLOR_REGEX.test(v) || RGB_COLOR_REGEX.test(v)
  );
  FormatRegistry.Set("emoji", (v) => EMOJI_REGEX.test(v));
  FormatRegistry.Set("semver", (v) => SEMVER_REGEX.test(v));
  FormatRegistry.Set("credit-card", isValidCreditCard);
}
function registerFormat(name, validator) {
  FormatRegistry.Set(name, validator);
}
function hasFormat(name) {
  return FormatRegistry.Has(name);
}
var Patterns = {
  EMAIL: EMAIL_REGEX,
  UUID: UUID_REGEX,
  URL: URL_REGEX,
  IPV4: IPV4_REGEX,
  IPV6: IPV6_REGEX,
  DATE: DATE_REGEX,
  TIME: TIME_REGEX,
  DATE_TIME: DATE_TIME_REGEX,
  PHONE_CN: PHONE_CN_REGEX,
  PHONE_E164: PHONE_E164_REGEX,
  OBJECTID: OBJECTID_REGEX,
  HEX_COLOR: HEX_COLOR_REGEX,
  SLUG: SLUG_REGEX,
  SEMVER: SEMVER_REGEX,
  JWT: JWT_REGEX
};

// src/utils/sse.ts
function formatSSEEvent(event) {
  const lines = [];
  if (event.id !== void 0) {
    lines.push(`id: ${event.id}`);
  }
  if (event.event !== void 0) {
    lines.push(`event: ${event.event}`);
  }
  if (event.retry !== void 0) {
    lines.push(`retry: ${event.retry}`);
  }
  const dataStr = typeof event.data === "string" ? event.data : JSON.stringify(event.data);
  const dataLines = dataStr.split("\n");
  for (const line of dataLines) {
    lines.push(`data: ${line}`);
  }
  return lines.join("\n") + "\n\n";
}
function createSSEHandler(schemaOrGenerator, maybeGenerator) {
  const hasSchema = typeof schemaOrGenerator !== "function";
  const schema = hasSchema ? schemaOrGenerator : {};
  const generator = hasSchema ? maybeGenerator : schemaOrGenerator;
  if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
    precompileSchemas(schema);
  }
  const handlerFn = async (req) => {
    try {
      const query = parseQuery(req);
      const headers = parseHeaders(req);
      const cookies = parseCookies(req);
      const params = req.params || {};
      const data = { body: void 0, query, params, headers, cookies };
      if (schema.body || schema.query || schema.params || schema.headers || schema.cookies) {
        validateAllSchemas(schema, data);
      }
      const stream2 = new ReadableStream({
        async start(controller) {
          const encoder = new TextEncoder();
          try {
            const gen = generator({
              req,
              body: void 0,
              query,
              params,
              headers,
              cookies
            });
            for await (const event of gen) {
              const formatted = formatSSEEvent(event);
              controller.enqueue(encoder.encode(formatted));
            }
          } catch (error) {
            const errorEvent = formatSSEEvent({
              event: "error",
              data: {
                message: error instanceof Error ? error.message : "Unknown error"
              }
            });
            controller.enqueue(encoder.encode(errorEvent));
          } finally {
            controller.close();
          }
        }
      });
      return new Response(stream2, {
        headers: {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          "Connection": "keep-alive",
          "X-Accel-Buffering": "no"
          // Nginx 禁用缓冲
        }
      });
    } catch (error) {
      return new Response(
        JSON.stringify({
          success: false,
          error: "Validation Error",
          message: error instanceof Error ? error.message : "Unknown error"
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
  };
  const handler = handlerFn;
  handler.__sse = { __brand: "SSE" };
  handler.__schema = schema;
  handler.__returnType = void 0;
  return handler;
}

// src/utils/route-registry.ts
var RouteRegistry = class {
  /** 所有路由元信息 */
  routes = [];
  /** 路由映射表：METHOD:fullPath -> RouteMeta */
  routeMap = /* @__PURE__ */ new Map();
  /** 分类映射表：category -> RouteMeta[] */
  categoryMap = /* @__PURE__ */ new Map();
  constructor(routes) {
    this.buildRegistry(routes);
  }
  /**
   * 构建注册表
   */
  buildRegistry(routes) {
    for (const route of routes) {
      const meta = {
        method: route.method,
        path: route.path,
        fullPath: route.fullPath,
        name: route.name,
        description: route.description
      };
      for (const key of Object.keys(route)) {
        if (!["method", "path", "fullPath", "name", "description", "handler", "middleware", "middlewareChain"].includes(key)) {
          meta[key] = route[key];
        }
      }
      this.routes.push(meta);
      this.routeMap.set(`${route.method}:${route.fullPath}`, meta);
      const category = this.extractCategory(route.fullPath);
      if (!this.categoryMap.has(category)) {
        this.categoryMap.set(category, []);
      }
      this.categoryMap.get(category).push(meta);
    }
  }
  /**
   * 提取分类（第一段路径）
   */
  extractCategory(path) {
    const segments = path.split("/").filter(Boolean);
    return segments[0] || "root";
  }
  // ============================================
  // 查询接口
  // ============================================
  /**
   * 获取所有路由元信息
   */
  getAll() {
    return [...this.routes];
  }
  /**
   * 按 method + path 查询路由
   */
  get(method, path) {
    return this.routeMap.get(`${method}:${path}`);
  }
  /**
   * 检查路由是否存在
   */
  has(method, path) {
    return this.routeMap.has(`${method}:${path}`);
  }
  /**
   * 按分类获取路由
   */
  getByCategory(category) {
    return this.categoryMap.get(category) || [];
  }
  /**
   * 获取所有分类
   */
  getCategories() {
    return Array.from(this.categoryMap.keys()).sort();
  }
  /**
   * 筛选有特定字段的路由
   *
   * @example
   * ```typescript
   * // 获取所有配置了 webhook 的路由
   * const webhookRoutes = registry.filter('webhook')
   * ```
   */
  filter(field) {
    return this.routes.filter((r) => field in r && r[field] !== void 0);
  }
  /**
   * 按条件筛选路由
   *
   * @example
   * ```typescript
   * // 获取所有 POST 请求
   * const postRoutes = registry.filterBy(r => r.method === 'POST')
   * ```
   */
  filterBy(predicate) {
    return this.routes.filter(predicate);
  }
  /**
   * 获取路由数量
   */
  get size() {
    return this.routes.length;
  }
  /**
   * 遍历所有路由
   */
  forEach(callback) {
    this.routes.forEach(callback);
  }
  /**
   * 映射所有路由
   */
  map(callback) {
    return this.routes.map(callback);
  }
};
function createRouteRegistry(routes) {
  return new RouteRegistry(routes);
}
var globalRegistry = null;
function getRouteRegistry() {
  if (!globalRegistry) {
    throw new Error("RouteRegistry not initialized. Make sure Server is created first.");
  }
  return globalRegistry;
}
function getRoute(method, path) {
  return getRouteRegistry().get(method, path);
}
function getAllRoutes() {
  return getRouteRegistry().getAll();
}
function filterRoutes(field) {
  return getRouteRegistry().filter(field);
}
export {
  DependencyManager,
  HtmlRenderer,
  Patterns,
  RouteRegistry,
  base64urlDecode,
  base64urlEncode,
  createHandler,
  createHandlerWithExtra,
  createRequestValidator,
  createRouteRegistry,
  createSSEHandler,
  createValidator,
  empty,
  filterRoutes,
  getAllRoutes,
  getCookie,
  getHeader,
  getLocals,
  getRoute,
  getRouteRegistry,
  getValidatorCacheStats,
  goAwait,
  hasFormat,
  html,
  json,
  parseAndValidateRequest,
  parseBody,
  parseCookies,
  parseCookiesFast,
  parseHeaders,
  parseQuery,
  parseQueryFast,
  parseRequest,
  precompileSchemas,
  redirect,
  registerFormat,
  registerFormats,
  setLocals,
  simpleHandler,
  stream,
  text,
  validateAllSchemas,
  validateFast,
  validateRequest,
  validateSchema,
  validateSchemaOrThrow
};
/**
 * Go 风格的错误处理工具
 * 将 Promise 转换为 [Error | null, T | undefined] 格式
 *
 * @author Framework Team
 * @version 1.0.0
 * @license MIT
 */
/**
 * 类型安全的路由处理器工厂
 *
 * 非柯里化设计，API 更简洁
 *
 * @author Framework Team
 * @version 3.0.0
 * @license MIT
 */
/**
 * 请求解析和验证器
 *
 * 解析handler的req参数，使用Ultra验证器进行验证，
 * 并类型安全地返回解析出来的值
 *
 * @author Framework Team
 * @version 1.0.0
 * @license MIT
 */
//# sourceMappingURL=index.js.map