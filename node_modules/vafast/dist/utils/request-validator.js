// src/utils/validators/validators.ts
import { Type } from "@sinclair/typebox";
import { TypeCompiler } from "@sinclair/typebox/compiler";
var compilerCache = /* @__PURE__ */ new WeakMap();
function getCompiledValidator(schema) {
  let compiler = compilerCache.get(schema);
  if (!compiler) {
    compiler = TypeCompiler.Compile(schema);
    compilerCache.set(schema, compiler);
  }
  return compiler;
}
function validateSchemaOrThrow(schema, data, context) {
  const compiler = getCompiledValidator(schema);
  if (!compiler.Check(data)) {
    throw new Error(`${context}\u9A8C\u8BC1\u5931\u8D25`);
  }
  return data;
}
function validateAllSchemas(config, data) {
  if (config.body) {
    validateSchemaOrThrow(config.body, data.body, "\u8BF7\u6C42\u4F53");
  }
  if (config.query) {
    validateSchemaOrThrow(config.query, data.query, "Query\u53C2\u6570");
  }
  if (config.params) {
    validateSchemaOrThrow(config.params, data.params, "\u8DEF\u5F84\u53C2\u6570");
  }
  if (config.headers) {
    validateSchemaOrThrow(config.headers, data.headers, "\u8BF7\u6C42\u5934");
  }
  if (config.cookies) {
    validateSchemaOrThrow(config.cookies, data.cookies, "Cookie");
  }
  return data;
}

// src/utils/parsers.ts
import qs from "qs";
import cookie from "cookie";
async function parseBody(req) {
  const contentType = req.headers.get("content-type") || "";
  if (contentType.includes("application/json")) {
    return await req.json();
  }
  if (contentType.includes("application/x-www-form-urlencoded")) {
    const text = await req.text();
    return Object.fromEntries(new URLSearchParams(text));
  }
  return await req.text();
}
function extractQueryString(url) {
  const qIndex = url.indexOf("?");
  if (qIndex === -1) return "";
  const hashIndex = url.indexOf("#", qIndex);
  return hashIndex === -1 ? url.substring(qIndex + 1) : url.substring(qIndex + 1, hashIndex);
}
function parseQuery(req) {
  const queryString = extractQueryString(req.url);
  if (!queryString) return {};
  return qs.parse(queryString);
}
function parseHeaders(req) {
  const headers = /* @__PURE__ */ Object.create(null);
  req.headers.forEach((value, key) => {
    headers[key] = value;
  });
  return headers;
}
function parseCookies(req) {
  const cookieHeader = req.headers.get("cookie");
  if (!cookieHeader) return {};
  try {
    const parsed = cookie.parse(cookieHeader);
    const result = {};
    for (const [key, value] of Object.entries(parsed)) {
      if (value !== void 0 && value !== null) {
        result[key] = value;
      }
    }
    return result;
  } catch {
    return {};
  }
}

// src/utils/request-validator.ts
async function parseRequest(request, params) {
  const requestData = {
    body: void 0,
    query: parseQuery(request),
    params: params || {},
    headers: parseHeaders(request),
    cookies: parseCookies(request)
  };
  if (request.method !== "GET" && request.method !== "HEAD") {
    requestData.body = await parseBody(request);
  }
  return requestData;
}
function validateRequest(config, requestData) {
  try {
    const validatedData = validateAllSchemas(config, requestData);
    return {
      success: true,
      data: validatedData
    };
  } catch (error) {
    return {
      success: false,
      errors: [
        {
          field: "unknown",
          message: error instanceof Error ? error.message : "\u9A8C\u8BC1\u5931\u8D25"
        }
      ]
    };
  }
}
async function parseAndValidateRequest(request, config, params) {
  try {
    const requestData = await parseRequest(request, params);
    return validateRequest(config, requestData);
  } catch (error) {
    return {
      success: false,
      errors: [
        {
          field: "unknown",
          message: error instanceof Error ? error.message : "\u8BF7\u6C42\u89E3\u6790\u5931\u8D25"
        }
      ]
    };
  }
}
function createRequestValidator(config) {
  return async (request, params) => {
    return parseAndValidateRequest(request, config, params);
  };
}
export {
  createRequestValidator,
  parseAndValidateRequest,
  parseRequest,
  validateRequest
};
/**
 * 请求解析和验证器
 *
 * 解析handler的req参数，使用Ultra验证器进行验证，
 * 并类型安全地返回解析出来的值
 *
 * @author Framework Team
 * @version 1.0.0
 * @license MIT
 */
//# sourceMappingURL=request-validator.js.map