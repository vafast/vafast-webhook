// src/utils/base64url.ts
function base64urlEncode(str) {
  return btoa(str).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64urlDecode(str) {
  const pad = str.length % 4 === 0 ? "" : "=".repeat(4 - str.length % 4);
  const base64 = str.replace(/-/g, "+").replace(/_/g, "/") + pad;
  return atob(base64);
}

// src/auth/token.ts
var TokenError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = "TokenError";
  }
};
var encoder = new TextEncoder();
async function sign(data, secret) {
  const key = await crypto.subtle.importKey(
    "raw",
    encoder.encode(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const signature = await crypto.subtle.sign("HMAC", key, encoder.encode(data));
  return btoa(
    String.fromCharCode.apply(null, Array.from(new Uint8Array(signature)))
  );
}
async function generateToken(payload, secret, options = {}) {
  const { expiresIn = 3600, issuer, audience, subject } = options;
  const now = Math.floor(Date.now() / 1e3);
  const tokenPayload = {
    ...payload,
    iat: now,
    exp: now + expiresIn
  };
  if (issuer) tokenPayload.iss = issuer;
  if (audience) tokenPayload.aud = audience;
  if (subject) tokenPayload.sub = subject;
  const data = base64urlEncode(JSON.stringify(tokenPayload));
  const sig = await sign(data, secret);
  const token = `${data}.${base64urlEncode(sig)}`;
  return {
    payload: tokenPayload,
    token,
    expiresAt: tokenPayload.exp * 1e3
    // 转换为毫秒
  };
}
async function verifyToken(token, secret) {
  try {
    const [data, sig] = token.split(".");
    if (!data || !sig) {
      throw new TokenError("\u4EE4\u724C\u683C\u5F0F\u65E0\u6548", "MALFORMED_TOKEN");
    }
    const expectedSig = await sign(data, secret);
    const expected = base64urlEncode(expectedSig);
    if (sig !== expected) {
      throw new TokenError("\u4EE4\u724C\u7B7E\u540D\u65E0\u6548", "INVALID_SIGNATURE");
    }
    const payload = JSON.parse(base64urlDecode(data));
    if (payload.exp && Date.now() / 1e3 > payload.exp) {
      throw new TokenError("\u4EE4\u724C\u5DF2\u8FC7\u671F", "EXPIRED_TOKEN");
    }
    return payload;
  } catch (error) {
    if (error instanceof TokenError) {
      throw error;
    }
    throw new TokenError("\u4EE4\u724C\u9A8C\u8BC1\u5931\u8D25", "INVALID_TOKEN");
  }
}
function parseToken(token) {
  try {
    const [data] = token.split(".");
    if (!data) return null;
    return JSON.parse(base64urlDecode(data));
  } catch {
    return null;
  }
}
function isTokenExpired(token) {
  const payload = parseToken(token);
  if (!payload || !payload.exp) return true;
  return Date.now() / 1e3 > payload.exp;
}
function getTokenTimeRemaining(token) {
  const payload = parseToken(token);
  if (!payload || !payload.exp) return 0;
  const remaining = payload.exp - Date.now() / 1e3;
  return Math.max(0, Math.floor(remaining));
}
async function refreshToken(token, secret, options = {}) {
  try {
    const payload = await verifyToken(token, secret);
    if (!payload) return null;
    const { exp, iat, ...cleanPayload } = payload;
    await new Promise((resolve) => setTimeout(resolve, 10));
    return await generateToken(cleanPayload, secret, options);
  } catch {
    return null;
  }
}
async function createTokenPair(payload, secret, options = {}) {
  const accessToken = await generateToken(payload, secret, {
    ...options,
    expiresIn: options.expiresIn || 3600
    // 1小时
  });
  const refreshToken2 = await generateToken(payload, secret, {
    ...options,
    expiresIn: 7 * 24 * 3600
    // 7天
  });
  return { accessToken, refreshToken: refreshToken2 };
}
export {
  TokenError,
  createTokenPair,
  generateToken,
  getTokenTimeRemaining,
  isTokenExpired,
  parseToken,
  refreshToken,
  verifyToken
};
//# sourceMappingURL=token.js.map